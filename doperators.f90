MODULE DOPERATORS
 USE MATHSUBS

!**************************************************************
!******************* BOUNDARY CONDITIONS **********************
!**************************************************************
! FDMORDER     => ORDER OF THE FINITE DIFFERENCE METHOD
 INTEGER(4)              :: FDMORDER             = 4

!***************************************************************
!************************* SOLVER DOMAIN ***********************
!***************************************************************
! GOLINEAR         => SOLVING THE DIFFERENTIAL EQUATIONS IN THE LINEAR REGIME
! GONONLINEAR      => SOLVING THE DIFFERENTIAL EQUATIONS IN THE NONLINEAR REGIME
 LOGICAL                 :: GOLINEAR             =.TRUE.
 LOGICAL                 :: GONONLINEAR          =.FALSE.

!***************************************************************
!*********************** FFTW SUBROUTINES **********************
!***************************************************************
!***************** PSEDUOSPECTRAL METHOD  **********************
!******************* NORMAL DIMENSIONS *************************
 INTEGER(4)              :: rPSfDIM1,rPSfDIM2,rPSfDIM3
 INTEGER(4)              :: kPSfDIM1,kPSfDIM2,kPSfDIM3
!********************* NORMAL ARRAYS ***************************
 REAL(8),    ALLOCATABLE :: rPSFFTWfn1D(:), rPSFFTWfn2D(:,:), rPSFFTWfn3D(:,:,:)
 COMPLEX(8), ALLOCATABLE :: kPSFFTWfn1D(:), kPSFFTWfn2D(:,:), kPSFFTWfn3D(:,:,:)
!********************** NORMAL PLANS ***************************
 INTEGER(8)              ::  PSFFTWPLAN1D,  PSFFTWPLAN2D,  PSFFTWPLAN3D
 INTEGER(8)              :: iPSFFTWPLAN1D, iPSFFTWPLAN2D, iPSFFTWPLAN3D
!******************* EXTENDED DIMENSIONS ***********************
 INTEGER(4)              :: rePSfDIM1,rePSfDIM2,rePSfDIM3
 INTEGER(4)              :: kePSfDIM1,kePSfDIM2,kePSfDIM3
!********************** EXTENDED ARRAYS ************************
 REAL(8),    ALLOCATABLE :: rePSFFTWfn1D(:), rePSFFTWfn2D(:,:), rePSFFTWfn3D(:,:,:)
 COMPLEX(8), ALLOCATABLE :: kePSFFTWfn1D(:), kePSFFTWfn2D(:,:), kePSFFTWfn3D(:,:,:)
!********************* EXTENDED PLANS **************************
 INTEGER(8)              ::  ePSFFTWPLAN1D,  ePSFFTWPLAN2D,  ePSFFTWPLAN3D
 INTEGER(8)              :: iePSFFTWPLAN1D, iePSFFTWPLAN2D, iePSFFTWPLAN3D
!******************* CHEBYSHEV METHOD  *************************
!******************* NORMAL DIMENSIONS *************************
 INTEGER(4)              :: rCSfDIM1,rCSfDIM2,rCSfDIM3
 INTEGER(4)              :: kCSfDIM1,kCSfDIM2,kCSfDIM3
 INTEGER(4)              :: rCSDCTWfDIM1,rCSDCTWfDIM2,rCSDCTWfDIM3
 INTEGER(4)              :: kCSDCTWfDIM1,kCSDCTWfDIM2,kCSDCTWfDIM3
!********************* NORMAL ARRAYS ***************************
 REAL(8),    ALLOCATABLE :: rCSDCTWIfn1D(:), rCSDCTWIfn2D(:,:), rCSDCTWIfn3D(:,:,:)
 REAL(8),    ALLOCATABLE :: rCSDCTWOfn1D(:), rCSDCTWOfn2D(:,:), rCSDCTWOfn3D(:,:,:)
 REAL(8),    ALLOCATABLE :: rCSFFTWfn1D(:),  rCSFFTWfn2D(:,:),  rCSFFTWfn3D(:,:,:)
 COMPLEX(8), ALLOCATABLE :: kCSFFTWfn1D(:),  kCSFFTWfn2D(:,:),  kCSFFTWfn3D(:,:,:)
!********************** NORMAL PLANS ***************************
 INTEGER(8)              ::  CSFFTWPLAN1D,  CSFFTWPLAN2D,  CSFFTWPLAN3D
 INTEGER(8)              :: iCSFFTWPLAN1D, iCSFFTWPLAN2D, iCSFFTWPLAN3D
 INTEGER(8)              ::  CSDCTWPLAN1D,  CSDCTWPLAN2D,  CSDCTWPLAN3D
 INTEGER(8)              :: iCSDCTWPLAN1D, iCSDCTWPLAN2D, iCSDCTWPLAN3D
!******************* EXTENDED DIMENSIONS ***********************
 INTEGER(4)              :: reCSfDIM1,reCSfDIM2,reCSfDIM3
 INTEGER(4)              :: keCSfDIM1,keCSfDIM2,keCSfDIM3
 INTEGER(4)              :: reCSDCTWfDIM1,reCSDCTWfDIM2,reCSDCTWfDIM3
 INTEGER(4)              :: keCSDCTWfDIM1,keCSDCTWfDIM2,keCSDCTWfDIM3
!********************** EXTENDED ARRAYS ************************
 REAL(8),    ALLOCATABLE :: reCSDCTWIfn1D(:), reCSDCTWIfn2D(:,:), reCSDCTWIfn3D(:,:,:)
 REAL(8),    ALLOCATABLE :: reCSDCTWOfn1D(:), reCSDCTWOfn2D(:,:), reCSDCTWOfn3D(:,:,:)
 REAL(8),    ALLOCATABLE :: reCSFFTWfn1D(:),  reCSFFTWfn2D(:,:),  reCSFFTWfn3D(:,:,:)
 COMPLEX(8), ALLOCATABLE :: keCSFFTWfn1D(:),  keCSFFTWfn2D(:,:),  keCSFFTWfn3D(:,:,:)
!********************* EXTENDED PLANS **************************
 INTEGER(8)              ::  eCSFFTWPLAN1D,  eCSFFTWPLAN2D,  eCSFFTWPLAN3D
 INTEGER(8)              :: ieCSFFTWPLAN1D, ieCSFFTWPLAN2D, ieCSFFTWPLAN3D
 INTEGER(8)              ::  eCSDCTWPLAN1D,  eCSDCTWPLAN2D,  eCSDCTWPLAN3D
 INTEGER(8)              :: ieCSDCTWPLAN1D, ieCSDCTWPLAN2D, ieCSDCTWPLAN3D
!**************************************************************
!***************** FIELDS DERIVATIVES SCHEMES *****************
!**************************************************************
! PSMSCHEME   => PSEUDOSPECTRAL METHOD SCHEME    (ALL DIMESNSIONS)
! XPSMSCHEME  => PSEUDOSPECTRAL METHOD SCHEME    (X   DIMESNSIONS)
! YPSMSCHEME  => PSEUDOSPECTRAL METHOD SCHEME    (Y   DIMESNSIONS)
! ZPSMSCHEME  => PSEUDOSPECTRAL METHOD SCHEME    (Z   DIMESNSIONS)
! CSMSCHEME   => CHEBYSHEV METHOD SCHEME         (ALL DIMENSIONS)
! XCSMSCHEME  => CHEBYSHEV METHOD SCHEME         (X   DIMENSIONS)
! YCSMSCHEME  => CHEBYSHEV METHOD SCHEME         (Y   DIMENSIONS)
! ZCSMSCHEME  => CHEBYSHEV METHOD SCHEME         (Z   DIMENSIONS)
! FDMSCHEME   => FINITE DIFFERENCE METHOD SCHEME (ALL DIMENSIONS)
! XFDMSCHEME  => FINITE DIFFERENCE METHOD SCHEME (X   DIMENSIONS)
! YFDMSCHEME  => FINITE DIFFERENCE METHOD SCHEME (Y   DIMENSIONS)
! ZFDMSCHEME  => FINITE DIFFERENCE METHOD SCHEME (Z   DIMENSIONS)
 LOGICAL,ALLOCATABLE     ::  PSMDSCHEME(:)
 LOGICAL,ALLOCATABLE     :: XPSMDSCHEME(:)
 LOGICAL,ALLOCATABLE     :: YPSMDSCHEME(:)
 LOGICAL,ALLOCATABLE     :: ZPSMDSCHEME(:)
 LOGICAL,ALLOCATABLE     ::  CSMDSCHEME(:)
 LOGICAL,ALLOCATABLE     :: XCSMDSCHEME(:)
 LOGICAL,ALLOCATABLE     :: YCSMDSCHEME(:)
 LOGICAL,ALLOCATABLE     :: ZCSMDSCHEME(:)
 LOGICAL,ALLOCATABLE     ::  FDMDSCHEME(:)
 LOGICAL,ALLOCATABLE     :: XFDMDSCHEME(:)
 LOGICAL,ALLOCATABLE     :: YFDMDSCHEME(:)
 LOGICAL,ALLOCATABLE     :: ZFDMDSCHEME(:)
!**************************************************************
!**************** FIELDS INTEGERATIONS SCHEMES ****************
!**************************************************************
! PSMSCHEME   => PSEUDOSPECTRAL METHOD SCHEME    (ALL DIMESNSIONS)
! XPSMSCHEME  => PSEUDOSPECTRAL METHOD SCHEME    (X   DIMESNSIONS)
! YPSMSCHEME  => PSEUDOSPECTRAL METHOD SCHEME    (Y   DIMESNSIONS)
! ZPSMSCHEME  => PSEUDOSPECTRAL METHOD SCHEME    (Z   DIMESNSIONS)
! CSMSCHEME   => CHEBYSHEV METHOD SCHEME         (ALL DIMENSIONS)
! XCSMSCHEME  => CHEBYSHEV METHOD SCHEME         (X   DIMENSIONS)
! YCSMSCHEME  => CHEBYSHEV METHOD SCHEME         (Y   DIMENSIONS)
! ZCSMSCHEME  => CHEBYSHEV METHOD SCHEME         (Z   DIMENSIONS)
! FDMSCHEME   => FINITE DIFFERENCE METHOD SCHEME (ALL DIMENSIONS)
! XFDMSCHEME  => FINITE DIFFERENCE METHOD SCHEME (X   DIMENSIONS)
! YFDMSCHEME  => FINITE DIFFERENCE METHOD SCHEME (Y   DIMENSIONS)
! ZFDMSCHEME  => FINITE DIFFERENCE METHOD SCHEME (Z   DIMENSIONS)
 LOGICAL,ALLOCATABLE     ::  PSMISCHEME(:)
 LOGICAL,ALLOCATABLE     :: XPSMISCHEME(:)
 LOGICAL,ALLOCATABLE     :: YPSMISCHEME(:)
 LOGICAL,ALLOCATABLE     :: ZPSMISCHEME(:)
 LOGICAL,ALLOCATABLE     ::  CSMISCHEME(:)
 LOGICAL,ALLOCATABLE     :: XCSMISCHEME(:)
 LOGICAL,ALLOCATABLE     :: YCSMISCHEME(:)
 LOGICAL,ALLOCATABLE     :: ZCSMISCHEME(:)
 LOGICAL,ALLOCATABLE     ::  FDMISCHEME(:)
 LOGICAL,ALLOCATABLE     :: XFDMISCHEME(:)
 LOGICAL,ALLOCATABLE     :: YFDMISCHEME(:)
 LOGICAL,ALLOCATABLE     :: ZFDMISCHEME(:)
!**************************************************************
!******************* BOUNDARY CONDITIONS **********************
!**************************************************************
!*************** PERIODIC BOUNDARY CONDITIONS *****************
 ! PERIODICBC  => APPLY PERIODIC B.C. TO ALL BOUNDARIES 
 ! XPERIODICBC => APPLY PERIODIC B.C. TO X-BOUNDARIES
 ! YPERIODICBC => APPLY PERIODIC B.C. TO Y-BOUNDARIES
 ! ZPERIODICBC => APPLY PERIODIC B.C. TO Z BOUNDARIES
 LOGICAL,ALLOCATABLE     ::  PERIODICBC(:)
 LOGICAL,ALLOCATABLE     :: XPERIODICBC(:)
 LOGICAL,ALLOCATABLE     :: YPERIODICBC(:)
 LOGICAL,ALLOCATABLE     :: ZPERIODICBC(:)
!*************** WAVEFRONT BOUNDARY CONDITIONS *****************
 ! WAVEFRONTBC     => APPLY WAVEFRONT B.C. TO ALL BOUNDARIES
 ! XWAVEFRONTBC    => APPLY WAVEFRONT B.C. TO X-BOUNDARIES
 ! YWAVEFRONTBC    => APPLY WAVEFRONT B.C. TO Y-BOUNDARIES
 ! ZWAVEFRONTBC    => APPLY WAVEFRONT B.C. TO Z-BOUNDARIES
 ! LLXWAVEFRONTBC  => APPLY WAVEFRONT B.C. TO LOWER-LIMIT OF X-BOUNDARIES
 ! ULXWAVEFRONTBC  => APPLY WAVEFRONT B.C. TO UPPER-LIMIT OF X-BOUNDARIES
 ! LLYWAVEFRONTBC  => APPLY WAVEFRONT B.C. TO LOWER-LIMIT OF Y-BOUNDARIES
 ! ULYWAVEFRONTBC  => APPLY WAVEFRONT B.C. TO UPPER-LIMIT OF Y-BOUNDARIES
 ! LLZWAVEFRONTBC  => APPLY WAVEFRONT B.C. TO LOWER-LIMIT OF Z-BOUNDARIES
 ! ULZWAVEFRONTBC  => APPLY WAVEFRONT B.C. TO UPPER-LIMIT OF Z-BOUNDARIES
 LOGICAL,ALLOCATABLE     ::    WAVEFRONTBC(:)
 LOGICAL,ALLOCATABLE     ::   XWAVEFRONTBC(:)
 LOGICAL,ALLOCATABLE     ::   YWAVEFRONTBC(:)
 LOGICAL,ALLOCATABLE     ::   ZWAVEFRONTBC(:)
 LOGICAL,ALLOCATABLE     :: LLXWAVEFRONTBC(:)
 LOGICAL,ALLOCATABLE     :: ULXWAVEFRONTBC(:)
 LOGICAL,ALLOCATABLE     :: LLYWAVEFRONTBC(:)
 LOGICAL,ALLOCATABLE     :: ULYWAVEFRONTBC(:)
 LOGICAL,ALLOCATABLE     :: LLZWAVEFRONTBC(:)
 LOGICAL,ALLOCATABLE     :: ULZWAVEFRONTBC(:)
!*************** DIRICHLET BOUNDARY CONDITIONS ****************
 ! DIRICHLETBC     => APPLY DIRICHLET B.C. TO ALL BOUNDARIES
 ! XDIRICHLETBC    => APPLY DIRICHLET B.C. TO X-BOUNDARIES
 ! YDIRICHLETBC    => APPLY DIRICHLET B.C. TO Y-BOUNDARIES
 ! ZDIRICHLETBC    => APPLY DIRICHLET B.C. TO Z-BOUNDARIES
 ! LLXDIRICHLETBC  => APPLY DIRICHLET B.C. TO LOWER-LIMIT OF X-BOUNDARIES
 ! ULXDIRICHLETBC  => APPLY DIRICHLET B.C. TO UPPER-LIMIT OF X-BOUNDARIES
 ! LLYDIRICHLETBC  => APPLY DIRICHLET B.C. TO LOWER-LIMIT OF Y-BOUNDARIES
 ! ULYDIRICHLETBC  => APPLY DIRICHLET B.C. TO UPPER-LIMIT OF Y-BOUNDARIES
 ! LLZDIRICHLETBC  => APPLY DIRICHLET B.C. TO LOWER-LIMIT OF Z-BOUNDARIES
 ! ULZDIRICHLETBC  => APPLY DIRICHLET B.C. TO UPPER-LIMIT OF Z-BOUNDARIES
 LOGICAL,ALLOCATABLE     ::    DIRICHLETBC(:)
 LOGICAL,ALLOCATABLE     ::   XDIRICHLETBC(:)
 LOGICAL,ALLOCATABLE     ::   YDIRICHLETBC(:)
 LOGICAL,ALLOCATABLE     ::   ZDIRICHLETBC(:)
 LOGICAL,ALLOCATABLE     :: LLXDIRICHLETBC(:)
 LOGICAL,ALLOCATABLE     :: ULXDIRICHLETBC(:)
 LOGICAL,ALLOCATABLE     :: LLYDIRICHLETBC(:)
 LOGICAL,ALLOCATABLE     :: ULYDIRICHLETBC(:)
 LOGICAL,ALLOCATABLE     :: LLZDIRICHLETBC(:)
 LOGICAL,ALLOCATABLE     :: ULZDIRICHLETBC(:)
!***************** DIRICHLET BOUNDARY VALUES ******************
 REAL(4),ALLOCATABLE     ::    DIRICHLETVAL(:)
 REAL(4),ALLOCATABLE     ::   XDIRICHLETVAL(:)
 REAL(4),ALLOCATABLE     ::   YDIRICHLETVAL(:)
 REAL(4),ALLOCATABLE     ::   ZDIRICHLETVAL(:)
 REAL(4),ALLOCATABLE     :: LLXDIRICHLETVAL(:)
 REAL(4),ALLOCATABLE     :: ULXDIRICHLETVAL(:)
 REAL(4),ALLOCATABLE     :: LLYDIRICHLETVAL(:)
 REAL(4),ALLOCATABLE     :: ULYDIRICHLETVAL(:)
 REAL(4),ALLOCATABLE     :: LLZDIRICHLETVAL(:)
 REAL(4),ALLOCATABLE     :: ULZDIRICHLETVAL(:)
!*************** NEUMANN BOUNDARY CONDITIONS ******************
 ! NEUMANNBC       => APPLY NEUMANN B.C. TO ALL BOUNDARIES
 ! XNEUMANNBC      => APPLY NEUMANN B.C. TO X-BOUNDARIES
 ! YNEUMANNBC      => APPLY NEUMANN B.C. TO Y-BOUNDARIES
 ! ZNEUMANNBC      => APPLY NEUMANN B.C. TO Z-BOUNDARIES
 ! LLXNEUMANNBC    => APPLY NEUMANN B.C. TO LOWER-LIMIT OF X-BOUNDARIES
 ! ULXNEUMANNBC    => APPLY NEUMANN B.C. TO UPPER-LIMIT OF X-BOUNDARIES
 ! LLYNEUMANNBC    => APPLY NEUMANN B.C. TO LOWER-LIMIT OF Y-BOUNDARIES
 ! ULYNEUMANNBC    => APPLY NEUMANN B.C. TO UPPER-LIMIT OF Y-BOUNDARIES
 ! LLZNEUMANNBC    => APPLY NEUMANN B.C. TO LOWER-LIMIT OF Z-BOUNDARIES
 ! ULZNEUMANNBC    => APPLY NEUMANN B.C. TO UPPER-LIMIT OF Z-BOUNDARIES
 LOGICAL,ALLOCATABLE     ::    NEUMANNBC(:)
 LOGICAL,ALLOCATABLE     ::   XNEUMANNBC(:)
 LOGICAL,ALLOCATABLE     ::   YNEUMANNBC(:)
 LOGICAL,ALLOCATABLE     ::   ZNEUMANNBC(:)
 LOGICAL,ALLOCATABLE     :: LLXNEUMANNBC(:)
 LOGICAL,ALLOCATABLE     :: ULXNEUMANNBC(:)
 LOGICAL,ALLOCATABLE     :: LLYNEUMANNBC(:)
 LOGICAL,ALLOCATABLE     :: ULYNEUMANNBC(:)
 LOGICAL,ALLOCATABLE     :: LLZNEUMANNBC(:)
 LOGICAL,ALLOCATABLE     :: ULZNEUMANNBC(:)
!****************** NEUMANN BOUNDARY VALUES *******************
 REAL(4),ALLOCATABLE     ::    NEUMANNVAL(:)
 REAL(4),ALLOCATABLE     ::   XNEUMANNVAL(:)
 REAL(4),ALLOCATABLE     ::   YNEUMANNVAL(:)
 REAL(4),ALLOCATABLE     ::   ZNEUMANNVAL(:)
 REAL(4),ALLOCATABLE     :: LLXNEUMANNVAL(:)
 REAL(4),ALLOCATABLE     :: ULXNEUMANNVAL(:)
 REAL(4),ALLOCATABLE     :: LLYNEUMANNVAL(:)
 REAL(4),ALLOCATABLE     :: ULYNEUMANNVAL(:)
 REAL(4),ALLOCATABLE     :: LLZNEUMANNVAL(:)
 REAL(4),ALLOCATABLE     :: ULZNEUMANNVAL(:)
!***************************************************************
!******************* K-GRID VARIABLES ARRAYS *******************
!***************************************************************
 COMPLEX(8), ALLOCATABLE :: iKx1D(:),    iKy1D(:),    iKz1D(:)
 COMPLEX(8), ALLOCATABLE :: iKx2D(:,:),  iKy2D(:,:),  iKz2D(:,:)
 COMPLEX(8), ALLOCATABLE :: iKx3D(:,:,:),iKy3D(:,:,:),iKz3D(:,:,:)

!***************************************************************
!******************* MISCELLANEOUS VARIABLES *******************
!***************************************************************
 REAL(8),    ALLOCATABLE :: invLPLC(:,:)
 REAL(8),    PARAMETER   :: PI=4.0d0*ATAN(1.0d0)



!***************************************************************
!                MODULE PROCEDURAL INTERFACES
!***************************************************************

 INTERFACE KGRIDBUILDER
   MODULE PROCEDURE r8c8KGRIDBUILDER1D,r4c8KGRIDBUILDER1D, &
 &                  r8c8KGRIDBUILDER2D,r4c8KGRIDBUILDER2D, &
 &                  r8c8KGRIDBUILDER3D,r4c8KGRIDBUILDER3D, &
 &                  r4r4KGRIDBUILDER1D,r8r8KGRIDBUILDER1D, &   
 &                  r8r4KGRIDBUILDER1D
 END INTERFACE KGRIDBUILDER

 INTERFACE FORCEBC
   MODULE PROCEDURE R4FORCEBC1D,R8FORCEBC1D, &
 &                  R4FORCEBC2D,R8FORCEBC2D, &
 &                  R4FORCEBC3D,R8FORCEBC3D
 END INTERFACE FORCEBC

 INTERFACE fg
   MODULE PROCEDURE c8c8c8fg1D,c8c8c8fg2D,c8c8c8fg3D
 END INTERFACE fg

 INTERFACE Df
   MODULE PROCEDURE r4r4r4Df1D,r4r4r4Df1DNONE,r4r4r4Df1D1INT,r4r4r4Df1D1CHR, &
 &                  r4r4r4Df2D,r4r4r4Df2DNONE,r4r4r4Df2D1INT,r4r4r4Df2D1CHR, &
 &                  r4r4r4Df3D,r4r4r4Df3DNONE,r4r4r4Df3D1INT,r4r4r4Df3D1CHR, &
 &                  r8r4r8Df1D,r8r4r8Df1DNONE,r8r4r8Df1D1INT,r8r4r8Df1D1CHR, &
 &                  r8r4r8Df2D,r8r4r8Df2DNONE,r8r4r8Df2D1INT,r8r4r8Df2D1CHR, &
 &                  r8r4r8Df3D,r8r4r8Df3DNONE,r8r4r8Df3D1INT,r8r4r8Df3D1CHR, &
 &                  r8r8r8Df1D,r8r8r8Df1DNONE,r8r8r8Df1D1INT,r8r8r8Df1D1CHR, &
 &                  r8r8r8Df2D,r8r8r8Df2DNONE,r8r8r8Df2D1INT,r8r8r8Df2D1CHR, &
 &                  r8r8r8Df3D,r8r8r8Df3DNONE,r8r8r8Df3D1INT,r8r8r8Df3D1CHR, &
 &                  r4r4c8Df1D,r4r4c8Df1DNONE,r4r4c8Df1D1INT,r4r4c8Df1D1CHR, &
 &                  r4r4c8Df2D,r4r4c8Df2DNONE,r4r4c8Df2D1INT,r4r4c8Df2D1CHR, &
 &                  r4r4c8Df3D,r4r4c8Df3DNONE,r4r4c8Df3D1INT,r4r4c8Df3D1CHR, &
 &                  r8r4c8Df1D,r8r4c8Df1DNONE,r8r4c8Df1D1INT,r8r4c8Df1D1CHR, &
 &                  r8r4c8Df2D,r8r4c8Df2DNONE,r8r4c8Df2D1INT,r8r4c8Df2D1CHR, &
 &                  r8r4c8Df3D,r8r4c8Df3DNONE,r8r4c8Df3D1INT,r8r4c8Df3D1CHR, &
 &                  r8r8c8Df1D,r8r8c8Df1DNONE,r8r8c8Df1D1INT,r8r8c8Df1D1CHR, &
 &                  r8r8c8Df2D,r8r8c8Df2DNONE,r8r8c8Df2D1INT,r8r8c8Df2D1CHR, &
 &                  r8r8c8Df3D,r8r8c8Df3DNONE,r8r8c8Df3D1INT,r8r8c8Df3D1CHR, &
 &                  c8c8c8Df1D,c8c8c8Df1DNONE,c8c8c8Df1D1INT,c8c8c8Df1D1CHR, &
 &                  c8c8c8Df2D,c8c8c8Df2DNONE,c8c8c8Df2D1INT,c8c8c8Df2D1CHR, &
 &                  c8c8c8Df3D,c8c8c8Df3DNONE,c8c8c8Df3D1INT,c8c8c8Df3D1CHR
 END INTERFACE Df

 INTERFACE fDg
   MODULE PROCEDURE c8c8c8fDg1D,c8c8c8fDg1DNONE,c8c8c8fDg1D1INT,c8c8c8fDg1D1CHR, &
 &                  c8c8c8fDg2D,c8c8c8fDg2DNONE,c8c8c8fDg2D1INT,c8c8c8fDg2D1CHR, &
 &                  c8c8c8fDg3D,c8c8c8fDg3DNONE,c8c8c8fDg3D1INT,c8c8c8fDg3D1CHR
 END INTERFACE fDg

 INTERFACE DfDg
   MODULE PROCEDURE r4r4r4DfDg1D,r4r4r4DfDg1DNONE,r4r4r4DfDg1D1INT,r4r4r4DfDg1D1CHR, &
 &                  r4r4r4DfDg2D,r4r4r4DfDg2DNONE,r4r4r4DfDg2D1INT,r4r4r4DfDg2D1CHR, &
 &                  r4r4r4DfDg3D,r4r4r4DfDg3DNONE,r4r4r4DfDg3D1INT,r4r4r4DfDg3D1CHR, &
 &                  r8r4r8DfDg1D,r8r4r8DfDg1DNONE,r8r4r8DfDg1D1INT,r8r4r8DfDg1D1CHR, &
 &                  r8r4r8DfDg2D,r8r4r8DfDg2DNONE,r8r4r8DfDg2D1INT,r8r4r8DfDg2D1CHR, &
 &                  r8r4r8DfDg3D,r8r4r8DfDg3DNONE,r8r4r8DfDg3D1INT,r8r4r8DfDg3D1CHR, &
 &                  r8r8r8DfDg1D,r8r8r8DfDg1DNONE,r8r8r8DfDg1D1INT,r8r8r8DfDg1D1CHR, &
 &                  r8r8r8DfDg2D,r8r8r8DfDg2DNONE,r8r8r8DfDg2D1INT,r8r8r8DfDg2D1CHR, &
 &                  r8r8r8DfDg3D,r8r8r8DfDg3DNONE,r8r8r8DfDg3D1INT,r8r8r8DfDg3D1CHR, &
 &                  r4r4c8DfDg1D,r4r4c8DfDg1DNONE,r4r4c8DfDg1D1INT,r4r4c8DfDg1D1CHR, &
 &                  r4r4c8DfDg2D,r4r4c8DfDg2DNONE,r4r4c8DfDg2D1INT,r4r4c8DfDg2D1CHR, &
 &                  r4r4c8DfDg3D,r4r4c8DfDg3DNONE,r4r4c8DfDg3D1INT,r4r4c8DfDg3D1CHR, &
 &                  r8r4c8DfDg1D,r8r4c8DfDg1DNONE,r8r4c8DfDg1D1INT,r8r4c8DfDg1D1CHR, &
 &                  r8r4c8DfDg2D,r8r4c8DfDg2DNONE,r8r4c8DfDg2D1INT,r8r4c8DfDg2D1CHR, &
 &                  r8r4c8DfDg3D,r8r4c8DfDg3DNONE,r8r4c8DfDg3D1INT,r8r4c8DfDg3D1CHR, &
 &                  r8r8c8DfDg1D,r8r8c8DfDg1DNONE,r8r8c8DfDg1D1INT,r8r8c8DfDg1D1CHR, &
 &                  r8r8c8DfDg2D,r8r8c8DfDg2DNONE,r8r8c8DfDg2D1INT,r8r8c8DfDg2D1CHR, &
 &                  r8r8c8DfDg3D,r8r8c8DfDg3DNONE,r8r8c8DfDg3D1INT,r8r8c8DfDg3D1CHR, &
 &                  c8c8c8DfDg1D,c8c8c8DfDg1D1INT,c8c8c8DfDg1D1CHR,c8c8c8DfDg1DNONE, &
 &                  c8c8c8DfDg2D,c8c8c8DfDg2D1INT,c8c8c8DfDg2D1CHR,c8c8c8DfDg2DNONE, &
 &                  c8c8c8DfDg3D,c8c8c8DfDg3D1INT,c8c8c8DfDg3D1CHR,c8c8c8DfDg3DNONE
 END INTERFACE DfDg

 INTERFACE GRADfGRADg
   MODULE PROCEDURE r4r4r4GRADfGRADg1D,r4r4r4GRADfGRADg1D1INT,r4r4r4GRADfGRADg1D1CHR,r4r4r4GRADfGRADg1DNONE, &
 &                  r4r4r4GRADfGRADg2D,r4r4r4GRADfGRADg2D1INT,r4r4r4GRADfGRADg2D1CHR,r4r4r4GRADfGRADg2DNONE, &
 &                  r4r4r4GRADfGRADg3D,r4r4r4GRADfGRADg3D1INT,r4r4r4GRADfGRADg3D1CHR,r4r4r4GRADfGRADg3DNONE, &
 &                  r8r4r8GRADfGRADg1D,r8r4r8GRADfGRADg1D1INT,r8r4r8GRADfGRADg1D1CHR,r8r4r8GRADfGRADg1DNONE, &
 &                  r8r4r8GRADfGRADg2D,r8r4r8GRADfGRADg2D1INT,r8r4r8GRADfGRADg2D1CHR,r8r4r8GRADfGRADg2DNONE, &
 &                  r8r4r8GRADfGRADg3D,r8r4r8GRADfGRADg3D1INT,r8r4r8GRADfGRADg3D1CHR,r8r4r8GRADfGRADg3DNONE, &
 &                  r8r8r8GRADfGRADg1D,r8r8r8GRADfGRADg1D1INT,r8r8r8GRADfGRADg1D1CHR,r8r8r8GRADfGRADg1DNONE, &
 &                  r8r8r8GRADfGRADg2D,r8r8r8GRADfGRADg2D1INT,r8r8r8GRADfGRADg2D1CHR,r8r8r8GRADfGRADg2DNONE, &
 &                  r8r8r8GRADfGRADg3D,r8r8r8GRADfGRADg3D1INT,r8r8r8GRADfGRADg3D1CHR,r8r8r8GRADfGRADg3DNONE, &
 &                  r4r4c8GRADfGRADg1D,r4r4c8GRADfGRADg1D1INT,r4r4c8GRADfGRADg1D1CHR,r4r4c8GRADfGRADg1DNONE, &
 &                  r4r4c8GRADfGRADg2D,r4r4c8GRADfGRADg2D1INT,r4r4c8GRADfGRADg2D1CHR,r4r4c8GRADfGRADg2DNONE, &
 &                  r4r4c8GRADfGRADg3D,r4r4c8GRADfGRADg3D1INT,r4r4c8GRADfGRADg3D1CHR,r4r4c8GRADfGRADg3DNONE, &
 &                  r8r4c8GRADfGRADg1D,r8r4c8GRADfGRADg1D1INT,r8r4c8GRADfGRADg1D1CHR,r8r4c8GRADfGRADg1DNONE, &
 &                  r8r4c8GRADfGRADg2D,r8r4c8GRADfGRADg2D1INT,r8r4c8GRADfGRADg2D1CHR,r8r4c8GRADfGRADg2DNONE, &
 &                  r8r4c8GRADfGRADg3D,r8r4c8GRADfGRADg3D1INT,r8r4c8GRADfGRADg3D1CHR,r8r4c8GRADfGRADg3DNONE, &
 &                  r8r8c8GRADfGRADg1D,r8r8c8GRADfGRADg1D1INT,r8r8c8GRADfGRADg1D1CHR,r8r8c8GRADfGRADg1DNONE, &
 &                  r8r8c8GRADfGRADg2D,r8r8c8GRADfGRADg2D1INT,r8r8c8GRADfGRADg2D1CHR,r8r8c8GRADfGRADg2DNONE, &
 &                  r8r8c8GRADfGRADg3D,r8r8c8GRADfGRADg3D1INT,r8r8c8GRADfGRADg3D1CHR,r8r8c8GRADfGRADg3DNONE, &
 &                  c8c8c8GRADfGRADg1D,c8c8c8GRADfGRADg1D1INT,c8c8c8GRADfGRADg1D1CHR,c8c8c8GRADfGRADg1DNONE, &
 &                  c8c8c8GRADfGRADg2D,c8c8c8GRADfGRADg2D1INT,c8c8c8GRADfGRADg2D1CHR,c8c8c8GRADfGRADg2DNONE, &
 &                  c8c8c8GRADfGRADg3D,c8c8c8GRADfGRADg3D1INT,c8c8c8GRADfGRADg3D1CHR,c8c8c8GRADfGRADg3DNONE
 END INTERFACE GRADfGRADg

 INTERFACE LPLCf
   MODULE PROCEDURE r4r4r4LPLCf2D,r4r4r4LPLCf2D1INT,r4r4r4LPLCf2D1CHR,r4r4r4LPLCf2DNONE, &
 &                  r4r4r4LPLCf3D,r4r4r4LPLCf3D1INT,r4r4r4LPLCf3D1CHR,r4r4r4LPLCf3DNONE, &
 &                  r8r4r8LPLCf2D,r8r4r8LPLCf2D1INT,r8r4r8LPLCf2D1CHR,r8r4r8LPLCf2DNONE, &
 &                  r8r4r8LPLCf3D,r8r4r8LPLCf3D1INT,r8r4r8LPLCf3D1CHR,r8r4r8LPLCf3DNONE, &
 &                  r8r8r8LPLCf2D,r8r8r8LPLCf2D1INT,r8r8r8LPLCf2D1CHR,r8r8r8LPLCf2DNONE, &
 &                  r8r8r8LPLCf3D,r8r8r8LPLCf3D1INT,r8r8r8LPLCf3D1CHR,r8r8r8LPLCf3DNONE, &
 &                  r4r4c8LPLCf2D,r4r4c8LPLCf2D1INT,r4r4c8LPLCf2D1CHR,r4r4c8LPLCf2DNONE, &
 &                  r4r4c8LPLCf3D,r4r4c8LPLCf3D1INT,r4r4c8LPLCf3D1CHR,r4r4c8LPLCf3DNONE, &
 &                  r8r4c8LPLCf2D,r8r4c8LPLCf2D1INT,r8r4c8LPLCf2D1CHR,r8r4c8LPLCf2DNONE, &
 &                  r8r4c8LPLCf3D,r8r4c8LPLCf3D1INT,r8r4c8LPLCf3D1CHR,r8r4c8LPLCf3DNONE, &
 &                  r8r8c8LPLCf2D,r8r8c8LPLCf2D1INT,r8r8c8LPLCf2D1CHR,r8r8c8LPLCf2DNONE, &
 &                  r8r8c8LPLCf3D,r8r8c8LPLCf3D1INT,r8r8c8LPLCf3D1CHR,r8r8c8LPLCf3DNONE, &
 &                  c8c8c8LPLCf2D,c8c8c8LPLCf2D1INT,c8c8c8LPLCf2D1CHR,c8c8c8LPLCf2DNONE, &
 &                  c8c8c8LPLCf3D,c8c8c8LPLCf3D1INT,c8c8c8LPLCf3D1CHR,c8c8c8LPLCf3DNONE
 END INTERFACE LPLCf

 INTERFACE PBKfg
   MODULE PROCEDURE r4r4r4PBKfg2D,r4r4r4PBKfg2D1INT,r4r4r4PBKfg2D1CHR,r4r4r4PBKfg2DNONE, &
 &                  r4r4r4PBKfg3D,r4r4r4PBKfg3D1INT,r4r4r4PBKfg3D1CHR,r4r4r4PBKfg3DNONE, &
 &                  r8r4r8PBKfg2D,r8r4r8PBKfg2D1INT,r8r4r8PBKfg2D1CHR,r8r4r8PBKfg2DNONE, &
 &                  r8r4r8PBKfg3D,r8r4r8PBKfg3D1INT,r8r4r8PBKfg3D1CHR,r8r4r8PBKfg3DNONE, &
 &                  r8r8r8PBKfg2D,r8r8r8PBKfg2D1INT,r8r8r8PBKfg2D1CHR,r8r8r8PBKfg2DNONE, &
 &                  r8r8r8PBKfg3D,r8r8r8PBKfg3D1INT,r8r8r8PBKfg3D1CHR,r8r8r8PBKfg3DNONE, &
 &                  r4r4c8PBKfg2D,r4r4c8PBKfg2D1INT,r4r4c8PBKfg2D1CHR,r4r4c8PBKfg2DNONE, &
 &                  r4r4c8PBKfg3D,r4r4c8PBKfg3D1INT,r4r4c8PBKfg3D1CHR,r4r4c8PBKfg3DNONE, &
 &                  r8r4c8PBKfg2D,r8r4c8PBKfg2D1INT,r8r4c8PBKfg2D1CHR,r8r4c8PBKfg2DNONE, &
 &                  r8r4c8PBKfg3D,r8r4c8PBKfg3D1INT,r8r4c8PBKfg3D1CHR,r8r4c8PBKfg3DNONE, &
 &                  r8r8c8PBKfg2D,r8r8c8PBKfg2D1INT,r8r8c8PBKfg2D1CHR,r8r8c8PBKfg2DNONE, &
 &                  r8r8c8PBKfg3D,r8r8c8PBKfg3D1INT,r8r8c8PBKfg3D1CHR,r8r8c8PBKfg3DNONE, &
 &                  c8c8c8PBKfg2D,c8c8c8PBKfg2D1INT,c8c8c8PBKfg2D1CHR,c8c8c8PBKfg2DNONE, &
 &                  c8c8c8PBKfg3D,c8c8c8PBKfg3D1INT,c8c8c8PBKfg3D1CHR,c8c8c8PBKfg3DNONE
 END INTERFACE PBKfg

 INTERFACE intDf
   MODULE PROCEDURE r4r4r4intDf1D,r4r4r4intDf1D1INT,r4r4r4intDf1D1CHR,r4r4r4intDf1DNONE, &
 &                  r4r4r4intDf2D,r4r4r4intDf2D1INT,r4r4r4intDf2D1CHR,r4r4r4intDf2DNONE, &
 &                  r4r4r4intDf3D,r4r4r4intDf3D1INT,r4r4r4intDf3D1CHR,r4r4r4intDf3DNONE, &
 &                  r8r4r8intDf1D,r8r4r8intDf1D1INT,r8r4r8intDf1D1CHR,r8r4r8intDf1DNONE, &
 &                  r8r4r8intDf2D,r8r4r8intDf2D1INT,r8r4r8intDf2D1CHR,r8r4r8intDf2DNONE, &
 &                  r8r4r8intDf3D,r8r4r8intDf3D1INT,r8r4r8intDf3D1CHR,r8r4r8intDf3DNONE, &
 &                  r4r4c8intDf1D,r4r4c8intDf1D1INT,r4r4c8intDf1D1CHR,r4r4c8intDf1DNONE, &
 &                  r4r4c8intDf2D,r4r4c8intDf2D1INT,r4r4c8intDf2D1CHR,r4r4c8intDf2DNONE, &
 &                  r4r4c8intDf3D,r4r4c8intDf3D1INT,r4r4c8intDf3D1CHR,r4r4c8intDf3DNONE, &
 &                  r8r4c8intDf1D,r8r4c8intDf1D1INT,r8r4c8intDf1D1CHR,r8r4c8intDf1DNONE, &
 &                  r8r4c8intDf2D,r8r4c8intDf2D1INT,r8r4c8intDf2D1CHR,r8r4c8intDf2DNONE, &
 &                  r8r4c8intDf3D,r8r4c8intDf3D1INT,r8r4c8intDf3D1CHR,r8r4c8intDf3DNONE, &
 &                  c8c8c8intDf1D,c8c8c8intDf1DNONE,c8c8c8intDf1D1INT,c8c8c8intDf1D1CHR, &
 &                  c8c8c8intDf2D,c8c8c8intDf2DNONE,c8c8c8intDf2D1INT,c8c8c8intDf2D1CHR, &
 &                  c8c8c8intDf3D,c8c8c8intDf3DNONE,c8c8c8intDf3D1INT,c8c8c8intDf3D1CHR
 END INTERFACE intDf

 INTERFACE intLPLCf
   MODULE PROCEDURE r4r4r4intLPLCf2D,r4r4r4intLPLCf2D1INT,r4r4r4intLPLCf2D1CHR,r4r4r4intLPLCf2DNONE, &
 &                  r4r4r4intLPLCf3D,r4r4r4intLPLCf3D1INT,r4r4r4intLPLCf3D1CHR,r4r4r4intLPLCf3DNONE, &
 &                  r8r4r8intLPLCf2D,r8r4r8intLPLCf2D1INT,r8r4r8intLPLCf2D1CHR,r8r4r8intLPLCf2DNONE, &
 &                  r8r4r8intLPLCf3D,r8r4r8intLPLCf3D1INT,r8r4r8intLPLCf3D1CHR,r8r4r8intLPLCf3DNONE, &
 &                  r8r8r8intLPLCf2D,r8r8r8intLPLCf2D1INT,r8r8r8intLPLCf2D1CHR,r8r8r8intLPLCf2DNONE, &
 &                  r8r8r8intLPLCf3D,r8r8r8intLPLCf3D1INT,r8r8r8intLPLCf3D1CHR,r8r8r8intLPLCf3DNONE, &
 &                  r4r4c8intLPLCf2D,r4r4c8intLPLCf2D1INT,r4r4c8intLPLCf2D1CHR,r4r4c8intLPLCf2DNONE, &
 &                  r4r4c8intLPLCf3D,r4r4c8intLPLCf3D1INT,r4r4c8intLPLCf3D1CHR,r4r4c8intLPLCf3DNONE, &
 &                  r8r4c8intLPLCf2D,r8r4c8intLPLCf2D1INT,r8r4c8intLPLCf2D1CHR,r8r4c8intLPLCf2DNONE, &
 &                  r8r4c8intLPLCf3D,r8r4c8intLPLCf3D1INT,r8r4c8intLPLCf3D1CHR,r8r4c8intLPLCf3DNONE, &
 &                  r8r8c8intLPLCf2D,r8r8c8intLPLCf2D1INT,r8r8c8intLPLCf2D1CHR,r8r8c8intLPLCf2DNONE, &
 &                  r8r8c8intLPLCf3D,r8r8c8intLPLCf3D1INT,r8r8c8intLPLCf3D1CHR,r8r8c8intLPLCf3DNONE, &
 &                  c8c8c8intLPLCf2D,c8c8c8intLPLCf2D1INT,c8c8c8intLPLCf2D1CHR,c8c8c8intLPLCf2DNONE, &
 &                  c8c8c8intLPLCf3D,c8c8c8intLPLCf3D1INT,c8c8c8intLPLCf3D1CHR,c8c8c8intLPLCf3DNONE
 END INTERFACE intLPLCf

 INTERFACE FFTW
  MODULE PROCEDURE r4c8FFTW1D,r8c8FFTW1D,r4c8FFTW2D,r8c8FFTW2D,r4c8FFTW3D,r8c8FFTW3D
 END INTERFACE FFTW

 INTERFACE iFFTW
  MODULE PROCEDURE c8r4iFFTW1D,c8r8iFFTW1D,c8r4iFFTW2D,c8r8iFFTW2D,c8r4iFFTW3D,c8r8iFFTW3D
 END INTERFACE iFFTW

 INTERFACE DCTW
  MODULE PROCEDURE r4r4DCTW1D,r8r8DCTW1D
 END INTERFACE DCTW

 INTERFACE iDCTW
  MODULE PROCEDURE r4r4iDCTW1D,r8r8iDCTW1D
 END INTERFACE iDCTW

 INTERFACE addFFTalias
   MODULE PROCEDURE C8addFFTalias1D,C8addFFTalias2D,C8addFFTalias3D
 END INTERFACE addFFTalias

 INTERFACE rmvFFTalias
   MODULE PROCEDURE C8rmvFFTalias1D,C8rmvFFTalias2D,C8rmvFFTalias3D
 END INTERFACE rmvFFTalias

 INTERFACE rmFFTalias
   MODULE PROCEDURE C8rmFFTalias1D,C8rmFFTalias2D,r8rmFFTalias2D,C8rmFFTalias3D
 END INTERFACE rmFFTalias

 INTERFACE CSARRAY
   MODULE PROCEDURE C8CSARRAY1D,C8CSARRAY2D,C8CSARRAY3D
 END INTERFACE CSARRAY


 CONTAINS



!**********************************************************************
!************************ K-SPACE GRID BUILDER ************************
!**********************************************************************
 SUBROUTINE r4r4KGRIDBUILDER1D(LX1D,LiKx1D)
  IMPLICIT NONE
  REAL(4),INTENT(IN)  :: LX1D(:)
  REAL(4)             :: Dx
  REAL(4)             :: DKx
  REAL(4),INTENT(OUT) :: LiKx1D(:)

  INTEGER(4)          :: LXDIM
  INTEGER(4)          :: iXDIM
  INTEGER(4)          :: MATDIMS

  LXDIM=SIZE(LX1D)

  IF(LXDIM.GT.1) THEN
   Dx=LX1D(LXDIM)-LX1D(LXDIM-1)
   DKx=(2.0*PI)/(LXDIM*Dx)
   DO iXDIM=1,LXDIM/2+1
    LiKx1D(iXDIM)=(iXDIM-1)*DKx
   END DO
  ELSE IF(LXDIM.EQ.1) THEN
    LiKx1D(1)=0.0
  END IF

  RETURN
 END SUBROUTINE r4r4KGRIDBUILDER1D

 SUBROUTINE r8r4KGRIDBUILDER1D(LX1D,LiKx1D)
  IMPLICIT NONE
  REAL(8),INTENT(IN)  :: LX1D(:)
  REAL(4)             :: Dx
  REAL(4)             :: DKx
  REAL(4),INTENT(OUT) :: LiKx1D(:)

  INTEGER(4)          :: LXDIM
  INTEGER(4)          :: iXDIM
  INTEGER(4)          :: MATDIMS

  LXDIM=SIZE(LX1D)

  IF(LXDIM.GT.1) THEN
   Dx=LX1D(LXDIM)-LX1D(LXDIM-1)
   DKx=(2.0*PI)/(LXDIM*Dx)
   DO iXDIM=1,LXDIM/2+1
    LiKx1D(iXDIM)=(iXDIM-1)*DKx
   END DO
  ELSE IF(LXDIM.EQ.1) THEN
    LiKx1D(1)=0.0
  END IF

  RETURN
 END SUBROUTINE r8r4KGRIDBUILDER1D

 SUBROUTINE r8r8KGRIDBUILDER1D(LX1D,LiKx1D)
  IMPLICIT NONE
  REAL(8),INTENT(IN)  :: LX1D(:)
  REAL(8)             :: Dx
  REAL(8)             :: DKx
  REAL(8),INTENT(OUT) :: LiKx1D(:)

  INTEGER(4)          :: LXDIM
  INTEGER(4)          :: iXDIM
  INTEGER(4)          :: MATDIMS

  LXDIM=SIZE(LX1D)

  IF(LXDIM.GT.1) THEN
   Dx=LX1D(LXDIM)-LX1D(LXDIM-1)
   DKx=(2.0d0*PI)/(LXDIM*Dx)
   DO iXDIM=1,LXDIM/2+1
    LiKx1D(iXDIM)=(iXDIM-1)*DKx
   END DO
  ELSE IF(LXDIM.EQ.1) THEN
    LiKx1D(1)=0.0d0
  END IF

  RETURN
 END SUBROUTINE r8r8KGRIDBUILDER1D

 SUBROUTINE r4c8KGRIDBUILDER1D(LX1D,LiKx1D)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)  :: LX1D(:)
  REAL(8)                 :: Dx
  REAL(8)                 :: DKx

  COMPLEX(8), INTENT(OUT) :: LiKx1D(:)
  
  INTEGER(4)              :: LXDIM
  INTEGER(4)              :: iXDIM

  LXDIM=SIZE(LX1D)

  IF(LXDIM.GT.1) THEN
   Dx=1.0d0*(LX1D(LXDIM)-LX1D(LXDIM-1))
   DKx=(2.0d0*PI)/(LXDIM*Dx)
   DO iXDIM=1,LXDIM/2+1
    LiKx1D(iXDIM)=(0.0d0,1.0d0)*((iXDIM-1)*DKx)
   END DO
  ELSE IF(LXDIM.EQ.1) THEN
    LiKx1D(1)=CMPLX(0.0d0,0.0d0)
  END IF

  RETURN
 END SUBROUTINE r4c8KGRIDBUILDER1D

 SUBROUTINE r8c8KGRIDBUILDER1D(LX1D,LiKx1D)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)  :: LX1D(:)
  REAL(8)                 :: Dx
  REAL(8)                 :: DKx

  COMPLEX(8), INTENT(OUT) :: LiKx1D(:)

  INTEGER(4)              :: LXDIM
  INTEGER(4)              :: iXDIM

  LXDIM=SIZE(LX1D)

  IF(LXDIM.GT.1) THEN
   Dx=LX1D(LXDIM)-LX1D(LXDIM-1)
   DKx=(2.0d0*PI)/(LXDIM*Dx)
   DO iXDIM=1,LXDIM/2+1
    LiKx1D(iXDIM)=CMPLX(0.0d0,1.0d0*(iXDIM-1)*DKx)
   END DO
  ELSE IF(LXDIM.EQ.1) THEN
    LiKx1D(1)=CMPLX(0.0d0,0.0d0)
  END IF

  RETURN
 END SUBROUTINE r8c8KGRIDBUILDER1D

 SUBROUTINE r4c8KGRIDBUILDER2D(LX2D,LiKx2D)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)  :: LX2D(:,:)
  REAL(8)                 :: Dx,Dy
  REAL(8)                 :: DKx,DKy

  COMPLEX(8), INTENT(OUT) :: LiKx2D(:,:)

  INTEGER(4)              :: LXDIM,LYDIM
  INTEGER(4)              :: iXDIM,iYDIM
  INTEGER(4)              :: MATDIMS(2),DxDIR


  MATDIMS=SHAPE(LX2D)
  LXDIM=MATDIMS(1)
  LYDIM=MATDIMS(2)

  DxDIR=1
  IF(LX2D(1,LYDIM).NE.LX2D(1,1)) DxDIR=2

  IF(DxDIR.EQ.1) THEN
   Dx=1.0d0*(LX2D(LXDIM,1)-LX2D(LXDIM-1,1))
   DKx=(2.0d0*PI)/(LXDIM*Dx)
   DO iXDIM=1,LXDIM/2+1
    LiKx2D(iXDIM,:)=CMPLX(0.0d0,1.0d0*(iXDIM-1)*DKx)
   END DO
  ELSE IF(DxDIR.EQ.2) THEN
   Dy=1.0d0*(LX2D(1,LYDIM)-LX2D(1,LYDIM-1))
   DKy=(2.0d0*PI)/(LYDIM*Dy)
   DO iYDIM=1,LYDIM
    IF(iYDIM.GT.LYDIM/2+1) THEN
     LiKx2D(:,iYDIM)=CMPLX(0.0d0,1.0d0*(iYDIM-1-LYDIM)*DKy)
    ELSE IF(iYDIM.LE.LYDIM/2+1) THEN
     LiKx2D(:,iYDIM)=CMPLX(0.0d0,1.0d0*(iYDIM-1)*DKy)
    END IF
   END DO
  END IF


  RETURN
 END SUBROUTINE r4c8KGRIDBUILDER2D

 SUBROUTINE r8c8KGRIDBUILDER2D(LX2D,LiKx2D)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)  :: LX2D(:,:)
  REAL(8)                 :: Dx,Dy
  REAL(8)                 :: DKx,DKy

  COMPLEX(8), INTENT(OUT) :: LiKx2D(:,:)

  INTEGER(4)              :: LXDIM,LYDIM
  INTEGER(4)              :: iXDIM,iYDIM
  INTEGER(4)              :: MATDIMS(2),DxDIR

  MATDIMS=SHAPE(LX2D)
  LXDIM=MATDIMS(1)
  LYDIM=MATDIMS(2)

  DxDIR=1
  IF(LX2D(1,LYDIM).NE.LX2D(1,1)) DxDIR=2

  IF(DxDIR.EQ.1) THEN
   Dx=LX2D(LXDIM,1)-LX2D(LXDIM-1,1)
   DKx=(2.0d0*PI)/(LXDIM*Dx)
   DO iXDIM=1,LXDIM/2+1
    LiKx2D(iXDIM,:)=CMPLX(0.0d0,1.0d0*(iXDIM-1)*DKx)
   END DO
  ELSE IF(DxDIR.EQ.2) THEN
   Dy=LX2D(1,LYDIM)-LX2D(1,LYDIM-1)
   DKy=(2.0d0*PI)/(LYDIM*Dy)
   DO iYDIM=1,LYDIM
    IF(iYDIM.GT.LYDIM/2+1) THEN
     LiKx2D(:,iYDIM)=CMPLX(0.0d0,1.0d0*(iYDIM-1-LYDIM)*DKy)
    ELSE IF(iYDIM.LE.LYDIM/2+1) THEN
     LiKx2D(:,iYDIM)=CMPLX(0.0d0,1.0d0*(iYDIM-1)*DKy)
    END IF
   END DO
  END IF

  RETURN
 END SUBROUTINE r8c8KGRIDBUILDER2D

 SUBROUTINE r4c8KGRIDBUILDER3D(LX3D,LiKx3D)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)  :: LX3D(:,:,:)
  REAL(8)                 :: Dx,Dy,Dz
  REAL(8)                 :: DKx,DKy,DKz

  COMPLEX(8), INTENT(OUT) :: LiKx3D(:,:,:)

  INTEGER(4)              :: LXDIM,LYDIM,LZDIM
  INTEGER(4)              :: iXDIM,iYDIM,iZDIM
  INTEGER(4)              :: MATDIMS(3),DxDIR

  MATDIMS=SHAPE(LX3D)
  LXDIM=MATDIMS(1)
  LYDIM=MATDIMS(2)
  LZDIM=MATDIMS(3)

  DxDIR=1
  IF(LX3D(1,LYDIM,1).NE.LX3D(1,1,1)) THEN
    DxDIR=2
  ELSE IF(LX3D(1,1,LZDIM).NE.LX3D(1,1,1)) THEN
    DxDIR=3
  END IF

  IF(DxDIR.EQ.1) THEN
   Dx=1.0d0*(LX3D(LXDIM,1,1)-LX3D(LXDIM-1,1,1))
   DKx=(2.0d0*PI)/(LXDIM*Dx)
   DO iXDIM=1,LXDIM/2+1
    LiKx3D(iXDIM,:,:)=CMPLX(0.0d0,1.0d0*(iXDIM-1)*DKx)
   END DO
  ELSE IF(DxDIR.EQ.2) THEN
   Dy=1.0d0*(LX3D(1,LYDIM,1)-LX3D(1,LYDIM-1,1))
   DKy=(2.0d0*PI)/(LYDIM*Dy)
   DO iYDIM=1,LYDIM
    IF(iYDIM.GT.LYDIM/2+1) THEN
     LiKx3D(:,iYDIM,:)=CMPLX(0.0d0,1.0d0*(iYDIM-1-LYDIM)*DKy)
    ELSE IF(iYDIM.LE.LYDIM/2+1) THEN
     LiKx3D(:,iYDIM,:)=CMPLX(0.0d0,1.0d0*(iYDIM-1)*DKy)
    END IF
   END DO
  ELSE IF(DxDIR.EQ.3) THEN
   Dz=1.0d0*(LX3D(1,1,LZDIM)-LX3D(1,1,LZDIM-1))
   DKz=(2.0d0*PI)/(LZDIM*Dz)
   DO iZDIM=1,LZDIM
    IF(iZDIM.GT.LZDIM/2+1) THEN
     LiKx3D(:,:,iZDIM)=CMPLX(0.0d0,1.0d0*(iZDIM-1-LZDIM)*DKz)
    ELSE IF(iZDIM.LE.LZDIM/2+1) THEN
     LiKx3D(:,:,iZDIM)=CMPLX(0.0d0,1.0d0*(iZDIM-1)*DKz)
    END IF
   END DO
  END IF

  RETURN
 END SUBROUTINE r4c8KGRIDBUILDER3D

 SUBROUTINE r8c8KGRIDBUILDER3D(LX3D,LiKx3D)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)  :: LX3D(:,:,:)
  REAL(8)                 :: Dx,Dy,Dz
  REAL(8)                 :: DKx,DKy,DKz

  COMPLEX(8), INTENT(OUT) :: LiKx3D(:,:,:)

  INTEGER(4)              :: LXDIM,LYDIM,LZDIM
  INTEGER(4)              :: iXDIM,iYDIM,iZDIM
  INTEGER(4)              :: MATDIMS(3),DxDIR


  MATDIMS=SHAPE(LX3D)
  LXDIM=MATDIMS(1)
  LYDIM=MATDIMS(2)
  LZDIM=MATDIMS(3)

  DxDIR=1
  IF(LX3D(1,LYDIM,1).NE.LX3D(1,1,1)) THEN
   DxDIR=2
  ELSE IF(LX3D(1,1,LZDIM).NE.LX3D(1,1,1)) THEN
   DxDIR=3
  END IF

  IF(DxDIR.EQ.1) THEN
   Dx=LX3D(LXDIM,1,1)-LX3D(LXDIM-1,1,1)
   DKx=(2.0d0*PI)/(LXDIM*Dx)
   DO iXDIM=1,LXDIM/2+1
    LiKx3D(iXDIM,:,:)=CMPLX(0.0d0,1.0d0*(iXDIM-1)*DKx)
   END DO
  ELSE IF(DxDIR.EQ.2) THEN
   Dy=LX3D(1,LYDIM,1)-LX3D(1,LYDIM-1,1)
   DKy=(2.0d0*PI)/(LYDIM*Dy)
   DO iYDIM=1,LYDIM
    IF(iYDIM.GT.LYDIM/2+1) THEN
     LiKx3D(:,iYDIM,:)=CMPLX(0.0d0,1.0d0*(iYDIM-1-LYDIM)*DKy)
    ELSE IF(iYDIM.LE.LYDIM/2+1) THEN
     LiKx3D(:,iYDIM,:)=CMPLX(0.0d0,1.0d0*(iYDIM-1)*DKy)
    END IF
   END DO
  ELSE IF(DxDIR.EQ.3) THEN
   Dz=LX3D(1,1,LZDIM)-LX3D(1,1,LZDIM-1)
   DKz=(2.0d0*PI)/(LZDIM*Dz)
   DO iZDIM=1,LZDIM
    IF(iZDIM.GT.LZDIM/2+1) THEN
     LiKx3D(:,:,iZDIM)=CMPLX(0.0d0,1.0d0*(iZDIM-1-LZDIM)*DKz)
    ELSE IF(iZDIM.LE.LZDIM/2+1) THEN
     LiKx3D(:,:,iZDIM)=CMPLX(0.0d0,1.0d0*(iZDIM-1)*DKz)
    END IF
   END DO
  END IF

  RETURN
 END SUBROUTINE r8c8KGRIDBUILDER3D


!****************************************************************************
!******************** FORCE THE BOUNDARY CONDITIONS *************************
!****************************************************************************
 SUBROUTINE R4FORCEBC1D(rflds,BCD)
  IMPLICIT NONE
  REAL(4),INTENT(INOUT) :: rflds(:)
  INTEGER(4)            :: MATDIMS(1)
  INTEGER(4)            :: BCID
  INTEGER(4), OPTIONAL  :: BCD

  MATDIMS=SIZE(rflds)

  IF(PRESENT(BCD)) THEN
   BCID=BCD
  ELSE
   BCID=1
  END IF

  IF(MATDIMS(1).EQ.1) THEN
   PRINT*, "YOUR FIELD IS NOT IN ARRAY FORMAT"
   RETURN
  END IF

  IF(PERIODICBC(BCID).OR.XPERIODICBC(BCID)) THEN
   rflds(1)=rflds(MATDIMS(1))
  ELSE IF(DIRICHLETBC(BCID).OR.XDIRICHLETBC(BCID)) THEN
   rflds(1)=DIRICHLETVAL(BCID)
   rflds(MATDIMS(1))=DIRICHLETVAL(BCID)
  ELSE IF(NEUMANNBC(BCID).OR.XNEUMANNBC(BCID)) THEN
   rflds(1)=rflds(3)
   rflds(2)=rflds(3)
   rflds(MATDIMS(1)-1)=rflds(MATDIMS(1)-2)
   rflds(MATDIMS(1))  =rflds(MATDIMS(1)-2)
  END IF

  RETURN
 END SUBROUTINE R4FORCEBC1D

 SUBROUTINE R8FORCEBC1D(rflds,BCD)
  IMPLICIT NONE
  REAL(8),INTENT(INOUT) :: rflds(:)
  INTEGER(4)            :: MATDIMS(1)
  INTEGER(4)            :: BCID
  INTEGER(4), OPTIONAL  :: BCD

  MATDIMS=SIZE(rflds)

  IF(PRESENT(BCD)) THEN
   BCID=BCD
  ELSE
   BCID=1
  END IF

  IF(MATDIMS(1).EQ.1) THEN
   PRINT*, "YOUR FIELD IS NOT IN ARRAY FORMAT"
   RETURN
  END IF

  IF(PERIODICBC(BCID).OR.XPERIODICBC(BCID)) THEN
   rflds(1)=rflds(MATDIMS(1))
  ELSE IF(DIRICHLETBC(BCID).OR.XDIRICHLETBC(BCID)) THEN
   rflds(1)=DIRICHLETVAL(BCID)
   rflds(MATDIMS(1))=DIRICHLETVAL(BCID)
  ELSE IF(NEUMANNBC(BCID).OR.XNEUMANNBC(BCID)) THEN
   rflds(1)=rflds(3)
   rflds(2)=rflds(3)
   rflds(MATDIMS(1)-1)=rflds(MATDIMS(1)-2)
   rflds(MATDIMS(1))  =rflds(MATDIMS(1)-2)
  END IF

  RETURN
 END SUBROUTINE R8FORCEBC1D


 SUBROUTINE R4FORCEBC2D(rflds,BCD)
  IMPLICIT NONE
  REAL(4),INTENT(INOUT) :: rflds(:,:)
  INTEGER(4)            :: MATDIMS(2)
  INTEGER(4)            :: BCID
  INTEGER(4), OPTIONAL  :: BCD

  MATDIMS=SHAPE(rflds)

  IF(PRESENT(BCD)) THEN
   BCID=BCD
  ELSE
   BCID=1
  END IF

  IF(MATDIMS(1).EQ.1) THEN
   CALL FORCEBC(rflds(1,:),BCID)
   RETURN
  ELSE IF(MATDIMS(2).EQ.1) THEN
   CALL FORCEBC(rflds(:,1),BCID)
   RETURN
  END IF

  IF(PERIODICBC(BCID).OR.XPERIODICBC(BCID)) THEN
   rflds(1,1:MATDIMS(2))=rflds(MATDIMS(1),1:MATDIMS(2))
  ELSE IF(DIRICHLETBC(BCID)) THEN
   rflds(1,1:MATDIMS(2))=DIRICHLETVAL(BCID)
   rflds(MATDIMS(1),1:MATDIMS(2))=DIRICHLETVAL(BCID)
  ELSE IF(NEUMANNBC(BCID)) THEN
   rflds(1,1:MATDIMS(2))=rflds(3,1:MATDIMS(2))
   rflds(2,1:MATDIMS(2))=rflds(3,1:MATDIMS(2))
   rflds(MATDIMS(1)-1,1:MATDIMS(2))=rflds(MATDIMS(1)-2,1:MATDIMS(2))
   rflds(MATDIMS(1)  ,1:MATDIMS(2))=rflds(MATDIMS(1)-2,1:MATDIMS(2))
  ELSE IF(XDIRICHLETBC(BCID)) THEN
   rflds(1,1:MATDIMS(2))=XDIRICHLETVAL(BCID)
   rflds(MATDIMS(1),1:MATDIMS(2))=XDIRICHLETVAL(BCID)
  ELSE IF(XNEUMANNBC(BCID)) THEN
   rflds(1,1:MATDIMS(2))=rflds(3,1:MATDIMS(2))
   rflds(2,1:MATDIMS(2))=rflds(3,1:MATDIMS(2))
   rflds(MATDIMS(1)-1,1:MATDIMS(2))=rflds(MATDIMS(1)-2,1:MATDIMS(2))
   rflds(MATDIMS(1)  ,1:MATDIMS(2))=rflds(MATDIMS(1)-2,1:MATDIMS(2))
  ELSE IF(LLXDIRICHLETBC(BCID).OR.ULXDIRICHLETBC(BCID)) THEN
   IF(LLXDIRICHLETBC(BCID)) rflds(1,1:MATDIMS(2))=LLXDIRICHLETVAL(BCID)
   IF(ULXDIRICHLETBC(BCID)) rflds(MATDIMS(1),1:MATDIMS(2))=ULXDIRICHLETVAL(BCID)
  ELSE IF(LLXNEUMANNBC(BCID).OR.ULXNEUMANNBC(BCID)) THEN
   IF(LLXNEUMANNBC(BCID)) rflds(1,1:MATDIMS(2))=rflds(3,1:MATDIMS(2))
   IF(LLXNEUMANNBC(BCID)) rflds(2,1:MATDIMS(2))=rflds(3,1:MATDIMS(2))
   IF(ULXNEUMANNBC(BCID)) rflds(MATDIMS(1)-1,1:MATDIMS(2))=rflds(MATDIMS(1)-2,1:MATDIMS(2))
   IF(ULXNEUMANNBC(BCID)) rflds(MATDIMS(1)  ,1:MATDIMS(2))=rflds(MATDIMS(1)-2,1:MATDIMS(2))
  END IF

  IF(PERIODICBC(BCID).OR.YPERIODICBC(BCID)) THEN
   rflds(1:MATDIMS(1),1)=rflds(1:MATDIMS(1),MATDIMS(2))
  ELSE IF(DIRICHLETBC(BCID)) THEN
   rflds(1:MATDIMS(1),1)=DIRICHLETVAL(BCID)
   rflds(1:MATDIMS(1),MATDIMS(2))=DIRICHLETVAL(BCID)
  ELSE IF(NEUMANNBC(BCID)) THEN
   rflds(1:MATDIMS(1),1)=rflds(1:MATDIMS(1),3)
   rflds(1:MATDIMS(1),2)=rflds(1:MATDIMS(1),3)
   rflds(1:MATDIMS(1),MATDIMS(2)-1)=rflds(1:MATDIMS(1),MATDIMS(2)-2)
   rflds(1:MATDIMS(1),MATDIMS(2))  =rflds(1:MATDIMS(1),MATDIMS(2)-2)
  ELSE IF(YDIRICHLETBC(BCID)) THEN
   rflds(1:MATDIMS(1),1)=YDIRICHLETVAL(BCID)
   rflds(1:MATDIMS(1),MATDIMS(2))=YDIRICHLETVAL(BCID)
  ELSE IF(YNEUMANNBC(BCID)) THEN
   rflds(1:MATDIMS(1),1)=rflds(1:MATDIMS(1),3)
   rflds(1:MATDIMS(1),2)=rflds(1:MATDIMS(1),3)
   rflds(1:MATDIMS(1),MATDIMS(2)-1)=rflds(1:MATDIMS(1),MATDIMS(2)-2)
   rflds(1:MATDIMS(1),MATDIMS(2))  =rflds(1:MATDIMS(1),MATDIMS(2)-2)
  ELSE IF(LLYDIRICHLETBC(BCID).OR.ULYDIRICHLETBC(BCID)) THEN
   IF(LLYDIRICHLETBC(BCID)) rflds(1:MATDIMS(1),1)=LLYDIRICHLETVAL(BCID)
   IF(ULYDIRICHLETBC(BCID)) rflds(1:MATDIMS(1),MATDIMS(2))=ULYDIRICHLETVAL(BCID)
  ELSE IF(LLYNEUMANNBC(BCID).OR.ULYNEUMANNBC(BCID)) THEN
   IF(LLYNEUMANNBC(BCID)) rflds(1:MATDIMS(1),1)=rflds(1:MATDIMS(1),3)
   IF(LLYNEUMANNBC(BCID)) rflds(1:MATDIMS(1),2)=rflds(1:MATDIMS(1),3)
   IF(ULYNEUMANNBC(BCID)) rflds(1:MATDIMS(1),MATDIMS(2)-1)=rflds(1:MATDIMS(1),MATDIMS(2)-2)
   IF(ULYNEUMANNBC(BCID)) rflds(1:MATDIMS(1),MATDIMS(2))  =rflds(1:MATDIMS(1),MATDIMS(2)-2)
  END IF

  RETURN
 END SUBROUTINE R4FORCEBC2D

 SUBROUTINE R8FORCEBC2D(rflds,BCD)
  IMPLICIT NONE
  REAL(8),INTENT(INOUT) :: rflds(:,:)
  INTEGER(4)            :: MATDIMS(2)
  INTEGER(4)            :: BCID
  INTEGER(4), OPTIONAL  :: BCD

  MATDIMS=SHAPE(rflds)

  IF(PRESENT(BCD)) THEN
   BCID=BCD
  ELSE
   BCID=1
  END IF

  IF(MATDIMS(1).EQ.1) THEN
   CALL FORCEBC(rflds(1,:),BCID)
   RETURN
  ELSE IF(MATDIMS(2).EQ.1) THEN
   CALL FORCEBC(rflds(:,1),BCID)
   RETURN
  END IF

  IF(PERIODICBC(BCID).OR.XPERIODICBC(BCID)) THEN
   rflds(1,1:MATDIMS(2))=rflds(MATDIMS(1),1:MATDIMS(2))
  ELSE IF(DIRICHLETBC(BCID)) THEN
   rflds(1,1:MATDIMS(2))=DIRICHLETVAL(BCID)
   rflds(MATDIMS(1),1:MATDIMS(2))=DIRICHLETVAL(BCID)
  ELSE IF(NEUMANNBC(BCID)) THEN
   rflds(1,1:MATDIMS(2))=rflds(3,1:MATDIMS(2))
   rflds(2,1:MATDIMS(2))=rflds(3,1:MATDIMS(2))
   rflds(MATDIMS(1)-1,1:MATDIMS(2))=rflds(MATDIMS(1)-2,1:MATDIMS(2))
   rflds(MATDIMS(1)  ,1:MATDIMS(2))=rflds(MATDIMS(1)-2,1:MATDIMS(2))
  ELSE IF(XDIRICHLETBC(BCID)) THEN
   rflds(1,1:MATDIMS(2))=XDIRICHLETVAL(BCID)
   rflds(MATDIMS(1),1:MATDIMS(2))=XDIRICHLETVAL(BCID)
  ELSE IF(XNEUMANNBC(BCID)) THEN
   rflds(1,1:MATDIMS(2))=rflds(3,1:MATDIMS(2))
   rflds(2,1:MATDIMS(2))=rflds(3,1:MATDIMS(2))
   rflds(MATDIMS(1)-1,1:MATDIMS(2))=rflds(MATDIMS(1)-2,1:MATDIMS(2))
   rflds(MATDIMS(1)  ,1:MATDIMS(2))=rflds(MATDIMS(1)-2,1:MATDIMS(2))
  ELSE IF(LLXDIRICHLETBC(BCID).OR.ULXDIRICHLETBC(BCID)) THEN
   IF(LLXDIRICHLETBC(BCID)) rflds(1,1:MATDIMS(2))=LLXDIRICHLETVAL(BCID)
   IF(ULXDIRICHLETBC(BCID)) rflds(MATDIMS(1),1:MATDIMS(2))=ULXDIRICHLETVAL(BCID)
  ELSE IF(LLXNEUMANNBC(BCID).OR.ULXNEUMANNBC(BCID)) THEN
   IF(LLXNEUMANNBC(BCID)) rflds(1,1:MATDIMS(2))=rflds(3,1:MATDIMS(2))
   IF(LLXNEUMANNBC(BCID)) rflds(2,1:MATDIMS(2))=rflds(3,1:MATDIMS(2))
   IF(ULXNEUMANNBC(BCID)) rflds(MATDIMS(1)-1,1:MATDIMS(2))=rflds(MATDIMS(1)-2,1:MATDIMS(2))
   IF(ULXNEUMANNBC(BCID)) rflds(MATDIMS(1)  ,1:MATDIMS(2))=rflds(MATDIMS(1)-2,1:MATDIMS(2))
  END IF

  IF(PERIODICBC(BCID).OR.YPERIODICBC(BCID)) THEN
   rflds(1:MATDIMS(1),1)=rflds(1:MATDIMS(1),MATDIMS(2))
  ELSE IF(DIRICHLETBC(BCID)) THEN
   rflds(1:MATDIMS(1),1)=DIRICHLETVAL(BCID)
   rflds(1:MATDIMS(1),MATDIMS(2))=DIRICHLETVAL(BCID)
  ELSE IF(NEUMANNBC(BCID)) THEN
   rflds(1:MATDIMS(1),1)=rflds(1:MATDIMS(1),3)
   rflds(1:MATDIMS(1),2)=rflds(1:MATDIMS(1),3)
   rflds(1:MATDIMS(1),MATDIMS(2)-1)=rflds(1:MATDIMS(1),MATDIMS(2)-2)
   rflds(1:MATDIMS(1),MATDIMS(2)  )=rflds(1:MATDIMS(1),MATDIMS(2)-2)
  ELSE IF(YDIRICHLETBC(BCID)) THEN
   rflds(1:MATDIMS(1),1)=YDIRICHLETVAL(BCID)
   rflds(1:MATDIMS(1),MATDIMS(2))=YDIRICHLETVAL(BCID)
  ELSE IF(YNEUMANNBC(BCID)) THEN
   rflds(1:MATDIMS(1),1)=rflds(1:MATDIMS(1),3)
   rflds(1:MATDIMS(1),2)=rflds(1:MATDIMS(1),3)
   rflds(1:MATDIMS(1),MATDIMS(2)-1)=rflds(1:MATDIMS(1),MATDIMS(2)-2)
   rflds(1:MATDIMS(1),MATDIMS(2))  =rflds(1:MATDIMS(1),MATDIMS(2)-2)
  ELSE IF(LLYDIRICHLETBC(BCID).OR.ULYDIRICHLETBC(BCID)) THEN
   IF(LLYDIRICHLETBC(BCID)) rflds(1:MATDIMS(1),1)=LLYDIRICHLETVAL(BCID)
   IF(ULYDIRICHLETBC(BCID)) rflds(1:MATDIMS(1),MATDIMS(2))=ULYDIRICHLETVAL(BCID)
  ELSE IF(LLYNEUMANNBC(BCID).OR.ULYNEUMANNBC(BCID)) THEN
   IF(LLYNEUMANNBC(BCID)) rflds(1:MATDIMS(1),1)=rflds(1:MATDIMS(1),3)
   IF(LLYNEUMANNBC(BCID)) rflds(1:MATDIMS(1),2)=rflds(1:MATDIMS(1),3)
   IF(ULYNEUMANNBC(BCID)) rflds(1:MATDIMS(1),MATDIMS(2)-1)=rflds(1:MATDIMS(1),MATDIMS(2)-2)
   IF(ULYNEUMANNBC(BCID)) rflds(1:MATDIMS(1),MATDIMS(2))  =rflds(1:MATDIMS(1),MATDIMS(2)-2)
  END IF

  RETURN
 END SUBROUTINE R8FORCEBC2D


 SUBROUTINE R4FORCEBC3D(rflds,BCD)
  IMPLICIT NONE
  REAL(4),INTENT(INOUT) :: rflds(:,:,:)
  INTEGER(4)            :: MATDIMS(3)
  INTEGER(4)            :: BCID
  INTEGER(4), OPTIONAL  :: BCD

  MATDIMS=SHAPE(rflds)

  IF(PRESENT(BCD)) THEN
   BCID=BCD
  ELSE
   BCID=1
  END IF

  IF(MATDIMS(1).EQ.1) THEN
   CALL FORCEBC(rflds(1,:,:),BCID)
   RETURN
  ELSE IF(MATDIMS(2).EQ.1) THEN
   CALL FORCEBC(rflds(:,1,:),BCID)
   RETURN
  ELSE IF(MATDIMS(3).EQ.1) THEN
   CALL FORCEBC(rflds(:,:,1),BCID)
   RETURN
  END IF

  IF(PERIODICBC(BCID).OR.XPERIODICBC(BCID)) THEN
   rflds(1,1:MATDIMS(2),1:MATDIMS(3))=rflds(MATDIMS(1),1:MATDIMS(2),1:MATDIMS(3))
  ELSE IF(DIRICHLETBC(BCID)) THEN
   rflds(1,1:MATDIMS(2),1:MATDIMS(3))=DIRICHLETVAL(BCID)
   rflds(MATDIMS(1),1:MATDIMS(2),1:MATDIMS(3))=DIRICHLETVAL(BCID)
  ELSE IF(NEUMANNBC(BCID)) THEN
   rflds(1,1:MATDIMS(2),1:MATDIMS(3))=rflds(3,1:MATDIMS(2),1:MATDIMS(3))
   rflds(2,1:MATDIMS(2),1:MATDIMS(3))=rflds(3,1:MATDIMS(2),1:MATDIMS(3))
   rflds(MATDIMS(1)-1,1:MATDIMS(2),1:MATDIMS(3))=rflds(MATDIMS(1)-2,1:MATDIMS(2),1:MATDIMS(3))
   rflds(MATDIMS(1)  ,1:MATDIMS(2),1:MATDIMS(3))=rflds(MATDIMS(1)-2,1:MATDIMS(2),1:MATDIMS(3))
  ELSE IF(XDIRICHLETBC(BCID)) THEN
   rflds(1,1:MATDIMS(2),1:MATDIMS(3))=XDIRICHLETVAL(BCID)
   rflds(MATDIMS(1),1:MATDIMS(2),1:MATDIMS(3))=XDIRICHLETVAL(BCID)
  ELSE IF(XNEUMANNBC(BCID)) THEN
   rflds(1,1:MATDIMS(2),1:MATDIMS(3))=rflds(3,1:MATDIMS(2),1:MATDIMS(3))
   rflds(2,1:MATDIMS(2),1:MATDIMS(3))=rflds(3,1:MATDIMS(2),1:MATDIMS(3))
   rflds(MATDIMS(1)-1,1:MATDIMS(2),1:MATDIMS(3))=rflds(MATDIMS(1)-2,1:MATDIMS(2),1:MATDIMS(3))
   rflds(MATDIMS(1)  ,1:MATDIMS(2),1:MATDIMS(3))=rflds(MATDIMS(1)-2,1:MATDIMS(2),1:MATDIMS(3))
  ELSE IF(LLXDIRICHLETBC(BCID).OR.ULXDIRICHLETBC(BCID)) THEN
   IF(LLXDIRICHLETBC(BCID)) rflds(1,1:MATDIMS(2),1:MATDIMS(3))=LLXDIRICHLETVAL(BCID)
   IF(ULXDIRICHLETBC(BCID)) rflds(MATDIMS(1),1:MATDIMS(2),1:MATDIMS(3))=ULXDIRICHLETVAL(BCID)
  ELSE IF(LLXNEUMANNBC(BCID).OR.ULXNEUMANNBC(BCID)) THEN
   IF(LLXNEUMANNBC(BCID)) rflds(1,1:MATDIMS(2),1:MATDIMS(3))=rflds(3,1:MATDIMS(2),1:MATDIMS(3))
   IF(LLXNEUMANNBC(BCID)) rflds(2,1:MATDIMS(2),1:MATDIMS(3))=rflds(3,1:MATDIMS(2),1:MATDIMS(3))
   IF(ULXNEUMANNBC(BCID)) rflds(MATDIMS(1)-1,1:MATDIMS(2),1:MATDIMS(3))=rflds(MATDIMS(1)-2,1:MATDIMS(2),1:MATDIMS(3))
   IF(ULXNEUMANNBC(BCID)) rflds(MATDIMS(1)  ,1:MATDIMS(2),1:MATDIMS(3))=rflds(MATDIMS(1)-2,1:MATDIMS(2),1:MATDIMS(3))
  END IF

  IF(PERIODICBC(BCID).OR.YPERIODICBC(BCID)) THEN
   rflds(1:MATDIMS(1),1,1:MATDIMS(3))=rflds(1:MATDIMS(1),MATDIMS(2),1:MATDIMS(3))
  ELSE IF(DIRICHLETBC(BCID)) THEN
   rflds(1:MATDIMS(1),1,1:MATDIMS(3))=DIRICHLETVAL(BCID)
   rflds(1:MATDIMS(1),MATDIMS(2),1:MATDIMS(3))=DIRICHLETVAL(BCID)
  ELSE IF(NEUMANNBC(BCID)) THEN
   rflds(1:MATDIMS(1),1,1:MATDIMS(3))=rflds(1:MATDIMS(1),3,1:MATDIMS(3))
   rflds(1:MATDIMS(1),2,1:MATDIMS(3))=rflds(1:MATDIMS(1),3,1:MATDIMS(3))
   rflds(1:MATDIMS(1),MATDIMS(2)-1,1:MATDIMS(3))=rflds(1:MATDIMS(1),MATDIMS(2)-2,1:MATDIMS(3))
   rflds(1:MATDIMS(1),MATDIMS(2)  ,1:MATDIMS(3))=rflds(1:MATDIMS(1),MATDIMS(2)-2,1:MATDIMS(3))
  ELSE IF(YDIRICHLETBC(BCID)) THEN
   rflds(1:MATDIMS(1),1,1:MATDIMS(3))=YDIRICHLETVAL(BCID)
   rflds(1:MATDIMS(1),MATDIMS(2),1:MATDIMS(3))=YDIRICHLETVAL(BCID)
  ELSE IF(YNEUMANNBC(BCID)) THEN
   rflds(1:MATDIMS(1),1,1:MATDIMS(3))=rflds(1:MATDIMS(1),3,1:MATDIMS(3))
   rflds(1:MATDIMS(1),2,1:MATDIMS(3))=rflds(1:MATDIMS(1),3,1:MATDIMS(3))
   rflds(1:MATDIMS(1),MATDIMS(2)-1,1:MATDIMS(3))=rflds(1:MATDIMS(1),MATDIMS(2)-2,1:MATDIMS(3))
   rflds(1:MATDIMS(1),MATDIMS(2)  ,1:MATDIMS(3))=rflds(1:MATDIMS(1),MATDIMS(2)-2,1:MATDIMS(3))
  ELSE IF(LLYDIRICHLETBC(BCID).OR.ULYDIRICHLETBC(BCID)) THEN
   IF(LLYDIRICHLETBC(BCID)) rflds(1:MATDIMS(1),1,1:MATDIMS(3))=LLYDIRICHLETVAL(BCID)
   IF(ULYDIRICHLETBC(BCID)) rflds(1:MATDIMS(1),MATDIMS(2),1:MATDIMS(3))=ULYDIRICHLETVAL(BCID)
  ELSE IF(LLYNEUMANNBC(BCID).OR.ULYNEUMANNBC(BCID)) THEN
   IF(LLYNEUMANNBC(BCID)) rflds(1:MATDIMS(1),1,1:MATDIMS(3))=rflds(1:MATDIMS(1),3,1:MATDIMS(3))
   IF(LLYNEUMANNBC(BCID)) rflds(1:MATDIMS(1),2,1:MATDIMS(3))=rflds(1:MATDIMS(1),3,1:MATDIMS(3))
   IF(ULYNEUMANNBC(BCID)) rflds(1:MATDIMS(1),MATDIMS(2)-1,1:MATDIMS(3))=rflds(1:MATDIMS(1),MATDIMS(2)-2,1:MATDIMS(3))
   IF(ULYNEUMANNBC(BCID)) rflds(1:MATDIMS(1),MATDIMS(2)  ,1:MATDIMS(3))=rflds(1:MATDIMS(1),MATDIMS(2)-2,1:MATDIMS(3))
  END IF

  IF(PERIODICBC(BCID).OR.ZPERIODICBC(BCID)) THEN
   rflds(1:MATDIMS(1),1:MATDIMS(2),1)=rflds(1:MATDIMS(1),1:MATDIMS(2),MATDIMS(3))
  ELSE IF(DIRICHLETBC(BCID)) THEN
   rflds(1:MATDIMS(1),1:MATDIMS(2),1)=DIRICHLETVAL(BCID)
   rflds(1:MATDIMS(1),1:MATDIMS(2),MATDIMS(3))=DIRICHLETVAL(BCID)
  ELSE IF(NEUMANNBC(BCID)) THEN
   rflds(1:MATDIMS(1),1:MATDIMS(2),1)=rflds(1:MATDIMS(1),1:MATDIMS(2),3)
   rflds(1:MATDIMS(1),1:MATDIMS(2),2)=rflds(1:MATDIMS(1),1:MATDIMS(2),3)
   rflds(1:MATDIMS(1),1:MATDIMS(2),MATDIMS(3)-1)=rflds(1:MATDIMS(1),1:MATDIMS(2),MATDIMS(3)-2)
   rflds(1:MATDIMS(1),1:MATDIMS(2),MATDIMS(3))  =rflds(1:MATDIMS(1),1:MATDIMS(2),MATDIMS(3)-2)
  ELSE IF(ZDIRICHLETBC(BCID)) THEN
   rflds(1:MATDIMS(1),1:MATDIMS(2),1)=ZDIRICHLETVAL(BCID)
   rflds(1:MATDIMS(1),1:MATDIMS(2),MATDIMS(3))=ZDIRICHLETVAL(BCID)
  ELSE IF(ZNEUMANNBC(BCID)) THEN
   rflds(1:MATDIMS(1),1:MATDIMS(2),1)=rflds(1:MATDIMS(1),1:MATDIMS(2),3)
   rflds(1:MATDIMS(1),1:MATDIMS(2),2)=rflds(1:MATDIMS(1),1:MATDIMS(2),3)
   rflds(1:MATDIMS(1),1:MATDIMS(2),MATDIMS(3)-1)=rflds(1:MATDIMS(1),1:MATDIMS(2),MATDIMS(3)-2)
   rflds(1:MATDIMS(1),1:MATDIMS(2),MATDIMS(3))  =rflds(1:MATDIMS(1),1:MATDIMS(2),MATDIMS(3)-2)
  ELSE IF(LLZDIRICHLETBC(BCID).OR.ULZDIRICHLETBC(BCID)) THEN
   IF(LLZDIRICHLETBC(BCID)) rflds(1:MATDIMS(1),1:MATDIMS(2),1)=LLZDIRICHLETVAL(BCID)
   IF(ULZDIRICHLETBC(BCID)) rflds(1:MATDIMS(1),1:MATDIMS(2),MATDIMS(3))=ULZDIRICHLETVAL(BCID)
  ELSE IF(LLZNEUMANNBC(BCID).OR.ULZNEUMANNBC(BCID)) THEN
   IF(LLZNEUMANNBC(BCID)) rflds(1:MATDIMS(1),1:MATDIMS(2),1)=rflds(1:MATDIMS(1),1:MATDIMS(2),3)
   IF(LLZNEUMANNBC(BCID)) rflds(1:MATDIMS(1),1:MATDIMS(2),2)=rflds(1:MATDIMS(1),1:MATDIMS(2),3)
   IF(ULZNEUMANNBC(BCID)) rflds(1:MATDIMS(1),1:MATDIMS(2),MATDIMS(3)-1)=rflds(1:MATDIMS(1),1:MATDIMS(2),MATDIMS(3)-2)
   IF(ULZNEUMANNBC(BCID)) rflds(1:MATDIMS(1),1:MATDIMS(2),MATDIMS(3))  =rflds(1:MATDIMS(1),1:MATDIMS(2),MATDIMS(3)-2)
  END IF

  RETURN
 END SUBROUTINE R4FORCEBC3D

 SUBROUTINE R8FORCEBC3D(rflds,BCD)
  IMPLICIT NONE
  REAL(8),INTENT(INOUT) :: rflds(:,:,:)
  INTEGER(4)            :: MATDIMS(3)
  INTEGER(4)            :: BCID
  INTEGER(4), OPTIONAL  :: BCD

  MATDIMS=SHAPE(rflds)

  IF(PRESENT(BCD)) THEN
   BCID=BCD
  ELSE
   BCID=1
  END IF

  IF(MATDIMS(1).EQ.1) THEN
   CALL FORCEBC(rflds(1,:,:),BCID)
   RETURN
  ELSE IF(MATDIMS(2).EQ.1) THEN
   CALL FORCEBC(rflds(:,1,:),BCID)
   RETURN
  ELSE IF(MATDIMS(3).EQ.1) THEN
   CALL FORCEBC(rflds(:,:,1),BCID)
   RETURN
  END IF

  IF(PERIODICBC(BCID).OR.XPERIODICBC(BCID)) THEN
   rflds(1,1:MATDIMS(2),1:MATDIMS(3))=rflds(MATDIMS(1),1:MATDIMS(2),1:MATDIMS(3))
  ELSE IF(DIRICHLETBC(BCID)) THEN
   rflds(1,1:MATDIMS(2),1:MATDIMS(3))=DIRICHLETVAL(BCID)
   rflds(MATDIMS(1),1:MATDIMS(2),1:MATDIMS(3))=DIRICHLETVAL(BCID)
  ELSE IF(NEUMANNBC(BCID)) THEN
   rflds(1,1:MATDIMS(2),1:MATDIMS(3))=rflds(3,1:MATDIMS(2),1:MATDIMS(3))
   rflds(2,1:MATDIMS(2),1:MATDIMS(3))=rflds(3,1:MATDIMS(2),1:MATDIMS(3))
   rflds(MATDIMS(1)-1,1:MATDIMS(2),1:MATDIMS(3))=rflds(MATDIMS(1)-2,1:MATDIMS(2),1:MATDIMS(3))
   rflds(MATDIMS(1)  ,1:MATDIMS(2),1:MATDIMS(3))=rflds(MATDIMS(1)-2,1:MATDIMS(2),1:MATDIMS(3))
  ELSE IF(XDIRICHLETBC(BCID)) THEN
   rflds(1,1:MATDIMS(2),1:MATDIMS(3))=XDIRICHLETVAL(BCID)
   rflds(MATDIMS(1),1:MATDIMS(2),1:MATDIMS(3))=XDIRICHLETVAL(BCID)
  ELSE IF(XNEUMANNBC(BCID)) THEN
   rflds(1,1:MATDIMS(2),1:MATDIMS(3))=rflds(3,1:MATDIMS(2),1:MATDIMS(3))
   rflds(2,1:MATDIMS(2),1:MATDIMS(3))=rflds(3,1:MATDIMS(2),1:MATDIMS(3))
   rflds(MATDIMS(1)-1,1:MATDIMS(2),1:MATDIMS(3))=rflds(MATDIMS(1)-2,1:MATDIMS(2),1:MATDIMS(3))
   rflds(MATDIMS(1)  ,1:MATDIMS(2),1:MATDIMS(3))=rflds(MATDIMS(1)-2,1:MATDIMS(2),1:MATDIMS(3))
  ELSE IF(LLXDIRICHLETBC(BCID).OR.ULXDIRICHLETBC(BCID)) THEN
   IF(LLXDIRICHLETBC(BCID)) rflds(1,1:MATDIMS(2),1:MATDIMS(3))=LLXDIRICHLETVAL(BCID)
   IF(ULXDIRICHLETBC(BCID)) rflds(MATDIMS(1),1:MATDIMS(2),1:MATDIMS(3))=ULXDIRICHLETVAL(BCID)
  ELSE IF(LLXNEUMANNBC(BCID).OR.ULXNEUMANNBC(BCID)) THEN
   IF(LLXNEUMANNBC(BCID)) rflds(1,1:MATDIMS(2),1:MATDIMS(3))=rflds(2,1:MATDIMS(2),1:MATDIMS(3))
   IF(LLXNEUMANNBC(BCID)) rflds(2,1:MATDIMS(2),1:MATDIMS(3))=rflds(2,1:MATDIMS(2),1:MATDIMS(3))
   IF(ULXNEUMANNBC(BCID)) rflds(MATDIMS(1)-1,1:MATDIMS(2),1:MATDIMS(3))=rflds(MATDIMS(1)-2,1:MATDIMS(2),1:MATDIMS(3))
   IF(ULXNEUMANNBC(BCID)) rflds(MATDIMS(1)  ,1:MATDIMS(2),1:MATDIMS(3))=rflds(MATDIMS(1)-2,1:MATDIMS(2),1:MATDIMS(3))
  END IF

  IF(PERIODICBC(BCID).OR.YPERIODICBC(BCID)) THEN
   rflds(1:MATDIMS(1),1,1:MATDIMS(3))=rflds(1:MATDIMS(1),MATDIMS(2),1:MATDIMS(3))
  ELSE IF(DIRICHLETBC(BCID)) THEN
   rflds(1:MATDIMS(1),1,1:MATDIMS(3))=DIRICHLETVAL(BCID)
   rflds(1:MATDIMS(1),MATDIMS(2),1:MATDIMS(3))=DIRICHLETVAL(BCID)
  ELSE IF(NEUMANNBC(BCID)) THEN
   rflds(1:MATDIMS(1),1,1:MATDIMS(3))=rflds(1:MATDIMS(1),3,1:MATDIMS(3))
   rflds(1:MATDIMS(1),2,1:MATDIMS(3))=rflds(1:MATDIMS(1),3,1:MATDIMS(3))
   rflds(1:MATDIMS(1),MATDIMS(2)-1,1:MATDIMS(3))=rflds(1:MATDIMS(1),MATDIMS(2)-2,1:MATDIMS(3))
   rflds(1:MATDIMS(1),MATDIMS(2)  ,1:MATDIMS(3))=rflds(1:MATDIMS(1),MATDIMS(2)-2,1:MATDIMS(3))
  ELSE IF(YDIRICHLETBC(BCID)) THEN
   rflds(1:MATDIMS(1),1,1:MATDIMS(3))=YDIRICHLETVAL(BCID)
   rflds(1:MATDIMS(1),MATDIMS(2),1:MATDIMS(3))=YDIRICHLETVAL(BCID)
  ELSE IF(YNEUMANNBC(BCID)) THEN
   rflds(1:MATDIMS(1),1,1:MATDIMS(3))=rflds(1:MATDIMS(1),3,1:MATDIMS(3))
   rflds(1:MATDIMS(1),2,1:MATDIMS(3))=rflds(1:MATDIMS(1),3,1:MATDIMS(3))
   rflds(1:MATDIMS(1),MATDIMS(2)-1,1:MATDIMS(3))=rflds(1:MATDIMS(1),MATDIMS(2)-2,1:MATDIMS(3))
   rflds(1:MATDIMS(1),MATDIMS(2)  ,1:MATDIMS(3))=rflds(1:MATDIMS(1),MATDIMS(2)-2,1:MATDIMS(3))
  ELSE IF(LLYDIRICHLETBC(BCID).OR.ULYDIRICHLETBC(BCID)) THEN
   IF(LLYDIRICHLETBC(BCID)) rflds(1:MATDIMS(1),1,1:MATDIMS(3))=LLYDIRICHLETVAL(BCID)
   IF(ULYDIRICHLETBC(BCID)) rflds(1:MATDIMS(1),MATDIMS(2),1:MATDIMS(3))=ULYDIRICHLETVAL(BCID)
  ELSE IF(LLYNEUMANNBC(BCID).OR.ULYNEUMANNBC(BCID)) THEN
   IF(LLYNEUMANNBC(BCID)) rflds(1:MATDIMS(1),1,1:MATDIMS(3))=rflds(1:MATDIMS(1),3,1:MATDIMS(3))
   IF(LLYNEUMANNBC(BCID)) rflds(1:MATDIMS(1),2,1:MATDIMS(3))=rflds(1:MATDIMS(1),3,1:MATDIMS(3))
   IF(ULYNEUMANNBC(BCID)) rflds(1:MATDIMS(1),MATDIMS(2)-1,1:MATDIMS(3))=rflds(1:MATDIMS(1),MATDIMS(2)-2,1:MATDIMS(3))
   IF(ULYNEUMANNBC(BCID)) rflds(1:MATDIMS(1),MATDIMS(2)  ,1:MATDIMS(3))=rflds(1:MATDIMS(1),MATDIMS(2)-2,1:MATDIMS(3))
  END IF

  IF(PERIODICBC(BCID).OR.ZPERIODICBC(BCID)) THEN
   rflds(1:MATDIMS(1),1:MATDIMS(2),1)=rflds(1:MATDIMS(1),1:MATDIMS(2),MATDIMS(3))
  ELSE IF(DIRICHLETBC(BCID)) THEN
   rflds(1:MATDIMS(1),1:MATDIMS(2),1)=DIRICHLETVAL(BCID)
   rflds(1:MATDIMS(1),1:MATDIMS(2),MATDIMS(3))=DIRICHLETVAL(BCID)
  ELSE IF(NEUMANNBC(BCID)) THEN
   rflds(1:MATDIMS(1),1:MATDIMS(2),1)=rflds(1:MATDIMS(1),1:MATDIMS(2),3)
   rflds(1:MATDIMS(1),1:MATDIMS(2),2)=rflds(1:MATDIMS(1),1:MATDIMS(2),3)
   rflds(1:MATDIMS(1),1:MATDIMS(2)-1,MATDIMS(3))=rflds(1:MATDIMS(1),1:MATDIMS(2),MATDIMS(3)-2)
   rflds(1:MATDIMS(1),1:MATDIMS(2)  ,MATDIMS(3))=rflds(1:MATDIMS(1),1:MATDIMS(2),MATDIMS(3)-2)
  ELSE IF(ZDIRICHLETBC(BCID)) THEN
   rflds(1:MATDIMS(1),1:MATDIMS(2),1)=ZDIRICHLETVAL(BCID)
   rflds(1:MATDIMS(1),1:MATDIMS(2),MATDIMS(3))=ZDIRICHLETVAL(BCID)
  ELSE IF(ZNEUMANNBC(BCID)) THEN
   rflds(1:MATDIMS(1),1:MATDIMS(2),1)=rflds(1:MATDIMS(1),1:MATDIMS(2),3)
   rflds(1:MATDIMS(1),1:MATDIMS(2),2)=rflds(1:MATDIMS(1),1:MATDIMS(2),3)
   rflds(1:MATDIMS(1),1:MATDIMS(2),MATDIMS(3)-1)=rflds(1:MATDIMS(1),1:MATDIMS(2),MATDIMS(3)-2)
   rflds(1:MATDIMS(1),1:MATDIMS(2),MATDIMS(3))  =rflds(1:MATDIMS(1),1:MATDIMS(2),MATDIMS(3)-2)
  ELSE IF(LLZDIRICHLETBC(BCID).OR.ULZDIRICHLETBC(BCID)) THEN
   IF(LLZDIRICHLETBC(BCID)) rflds(1:MATDIMS(1),1:MATDIMS(2),1)=LLZDIRICHLETVAL(BCID)
   IF(ULZDIRICHLETBC(BCID)) rflds(1:MATDIMS(1),1:MATDIMS(2),MATDIMS(3))=ULZDIRICHLETVAL(BCID)
  ELSE IF(LLZNEUMANNBC(BCID).OR.ULZNEUMANNBC(BCID)) THEN
   IF(LLZNEUMANNBC(BCID)) rflds(1:MATDIMS(1),1:MATDIMS(2),1)=rflds(1:MATDIMS(1),1:MATDIMS(2),3)
   IF(LLZNEUMANNBC(BCID)) rflds(1:MATDIMS(1),1:MATDIMS(2),2)=rflds(1:MATDIMS(1),1:MATDIMS(2),3)
   IF(ULZNEUMANNBC(BCID)) rflds(1:MATDIMS(1),1:MATDIMS(2),MATDIMS(3)-1)=rflds(1:MATDIMS(1),1:MATDIMS(2),MATDIMS(3)-2)
   IF(ULZNEUMANNBC(BCID)) rflds(1:MATDIMS(1),1:MATDIMS(2),MATDIMS(3))  =rflds(1:MATDIMS(1),1:MATDIMS(2),MATDIMS(3)-2)
  END IF

  RETURN
 END SUBROUTINE R8FORCEBC3D



!**********************************************************************
!***************** ALLOCATE BOUNDARY CONDITIONS ARRYAS ****************
!**********************************************************************
 SUBROUTINE RESETBC(Cnfld)
  IMPLICIT NONE
  INTEGER(4),INTENT(IN) :: Cnfld

  IF(ALLOCATED( PERIODICBC)) DEALLOCATE(PERIODICBC)
  IF(ALLOCATED(XPERIODICBC)) DEALLOCATE(XPERIODICBC)
  IF(ALLOCATED(YPERIODICBC)) DEALLOCATE(YPERIODICBC)
  IF(ALLOCATED(ZPERIODICBC)) DEALLOCATE(ZPERIODICBC)
  ALLOCATE( PERIODICBC(Cnfld))
  ALLOCATE(XPERIODICBC(Cnfld))
  ALLOCATE(YPERIODICBC(Cnfld))
  ALLOCATE(ZPERIODICBC(Cnfld))

   PERIODICBC=.FALSE.
  XPERIODICBC=.FALSE.
  YPERIODICBC=.FALSE.
  ZPERIODICBC=.FALSE.

  IF(ALLOCATED(   DIRICHLETBC)) DEALLOCATE(   DIRICHLETBC)
  IF(ALLOCATED(  XDIRICHLETBC)) DEALLOCATE(  XDIRICHLETBC)
  IF(ALLOCATED(  YDIRICHLETBC)) DEALLOCATE(  YDIRICHLETBC)
  IF(ALLOCATED(  ZDIRICHLETBC)) DEALLOCATE(  ZDIRICHLETBC)
  IF(ALLOCATED(LLXDIRICHLETBC)) DEALLOCATE(LLXDIRICHLETBC)
  IF(ALLOCATED(ULXDIRICHLETBC)) DEALLOCATE(ULXDIRICHLETBC)
  IF(ALLOCATED(LLYDIRICHLETBC)) DEALLOCATE(LLYDIRICHLETBC)
  IF(ALLOCATED(ULYDIRICHLETBC)) DEALLOCATE(ULYDIRICHLETBC)
  IF(ALLOCATED(LLZDIRICHLETBC)) DEALLOCATE(LLZDIRICHLETBC)
  IF(ALLOCATED(ULZDIRICHLETBC)) DEALLOCATE(ULZDIRICHLETBC)
  ALLOCATE(   DIRICHLETBC(Cnfld))
  ALLOCATE(  XDIRICHLETBC(Cnfld))
  ALLOCATE(  YDIRICHLETBC(Cnfld))
  ALLOCATE(  ZDIRICHLETBC(Cnfld))
  ALLOCATE(LLXDIRICHLETBC(Cnfld))
  ALLOCATE(ULXDIRICHLETBC(Cnfld))
  ALLOCATE(LLYDIRICHLETBC(Cnfld))
  ALLOCATE(ULYDIRICHLETBC(Cnfld))
  ALLOCATE(LLZDIRICHLETBC(Cnfld))
  ALLOCATE(ULZDIRICHLETBC(Cnfld))

     DIRICHLETBC=.FALSE.
    XDIRICHLETBC=.FALSE.
    YDIRICHLETBC=.FALSE.
    ZDIRICHLETBC=.FALSE.
  LLXDIRICHLETBC=.FALSE.
  ULXDIRICHLETBC=.FALSE.
  LLYDIRICHLETBC=.FALSE.
  ULYDIRICHLETBC=.FALSE.
  LLZDIRICHLETBC=.FALSE.
  ULZDIRICHLETBC=.FALSE.

  IF(ALLOCATED(   NEUMANNBC)) DEALLOCATE(   NEUMANNBC)
  IF(ALLOCATED(  XNEUMANNBC)) DEALLOCATE(  XNEUMANNBC)
  IF(ALLOCATED(  YNEUMANNBC)) DEALLOCATE(  YNEUMANNBC)
  IF(ALLOCATED(  ZNEUMANNBC)) DEALLOCATE(  ZNEUMANNBC)
  IF(ALLOCATED(LLXNEUMANNBC)) DEALLOCATE(LLXNEUMANNBC)
  IF(ALLOCATED(ULXNEUMANNBC)) DEALLOCATE(ULXNEUMANNBC)
  IF(ALLOCATED(LLYNEUMANNBC)) DEALLOCATE(LLYNEUMANNBC)
  IF(ALLOCATED(ULYNEUMANNBC)) DEALLOCATE(ULYNEUMANNBC)
  IF(ALLOCATED(LLZNEUMANNBC)) DEALLOCATE(LLZNEUMANNBC)
  IF(ALLOCATED(ULZNEUMANNBC)) DEALLOCATE(ULZNEUMANNBC)
  ALLOCATE(   NEUMANNBC(Cnfld))
  ALLOCATE(  XNEUMANNBC(Cnfld))
  ALLOCATE(  YNEUMANNBC(Cnfld))
  ALLOCATE(  ZNEUMANNBC(Cnfld))
  ALLOCATE(LLXNEUMANNBC(Cnfld))
  ALLOCATE(ULXNEUMANNBC(Cnfld))
  ALLOCATE(LLYNEUMANNBC(Cnfld))
  ALLOCATE(ULYNEUMANNBC(Cnfld))
  ALLOCATE(LLZNEUMANNBC(Cnfld))
  ALLOCATE(ULZNEUMANNBC(Cnfld))

     NEUMANNBC=.FALSE.
    XNEUMANNBC=.FALSE.
    YNEUMANNBC=.FALSE.
    ZNEUMANNBC=.FALSE.
  LLXNEUMANNBC=.FALSE.
  ULXNEUMANNBC=.FALSE.
  LLYNEUMANNBC=.FALSE.
  ULYNEUMANNBC=.FALSE.
  LLZNEUMANNBC=.FALSE.
  ULZNEUMANNBC=.FALSE.

  IF(ALLOCATED(   WAVEFRONTBC)) DEALLOCATE(   WAVEFRONTBC)
  IF(ALLOCATED(  XWAVEFRONTBC)) DEALLOCATE(  XWAVEFRONTBC)
  IF(ALLOCATED(  YWAVEFRONTBC)) DEALLOCATE(  YWAVEFRONTBC)
  IF(ALLOCATED(  ZWAVEFRONTBC)) DEALLOCATE(  ZWAVEFRONTBC)
  IF(ALLOCATED(LLXWAVEFRONTBC)) DEALLOCATE(LLXWAVEFRONTBC)
  IF(ALLOCATED(ULXWAVEFRONTBC)) DEALLOCATE(ULXWAVEFRONTBC)
  IF(ALLOCATED(LLYWAVEFRONTBC)) DEALLOCATE(LLYWAVEFRONTBC)
  IF(ALLOCATED(ULYWAVEFRONTBC)) DEALLOCATE(ULYWAVEFRONTBC)
  IF(ALLOCATED(LLZWAVEFRONTBC)) DEALLOCATE(LLZWAVEFRONTBC)
  IF(ALLOCATED(ULZWAVEFRONTBC)) DEALLOCATE(ULZWAVEFRONTBC)
  ALLOCATE(   WAVEFRONTBC(Cnfld))
  ALLOCATE(  XWAVEFRONTBC(Cnfld))
  ALLOCATE(  YWAVEFRONTBC(Cnfld))
  ALLOCATE(  ZWAVEFRONTBC(Cnfld))
  ALLOCATE(LLXWAVEFRONTBC(Cnfld))
  ALLOCATE(ULXWAVEFRONTBC(Cnfld))
  ALLOCATE(LLYWAVEFRONTBC(Cnfld))
  ALLOCATE(ULYWAVEFRONTBC(Cnfld))
  ALLOCATE(LLZWAVEFRONTBC(Cnfld))
  ALLOCATE(ULZWAVEFRONTBC(Cnfld))

     WAVEFRONTBC=.FALSE.
    XWAVEFRONTBC=.FALSE.
    YWAVEFRONTBC=.FALSE.
    ZWAVEFRONTBC=.FALSE.
  LLXWAVEFRONTBC=.FALSE.
  ULXWAVEFRONTBC=.FALSE.
  LLYWAVEFRONTBC=.FALSE.
  ULYWAVEFRONTBC=.FALSE.
  LLZWAVEFRONTBC=.FALSE.
  ULZWAVEFRONTBC=.FALSE.

  IF(ALLOCATED(   DIRICHLETVAL)) DEALLOCATE(   DIRICHLETVAL)
  IF(ALLOCATED(  XDIRICHLETVAL)) DEALLOCATE(  XDIRICHLETVAL)
  IF(ALLOCATED(  YDIRICHLETVAL)) DEALLOCATE(  YDIRICHLETVAL)
  IF(ALLOCATED(  ZDIRICHLETVAL)) DEALLOCATE(  ZDIRICHLETVAL)
  IF(ALLOCATED(LLXDIRICHLETVAL)) DEALLOCATE(LLXDIRICHLETVAL)
  IF(ALLOCATED(ULXDIRICHLETVAL)) DEALLOCATE(ULXDIRICHLETVAL)
  IF(ALLOCATED(LLYDIRICHLETVAL)) DEALLOCATE(LLYDIRICHLETVAL)
  IF(ALLOCATED(ULYDIRICHLETVAL)) DEALLOCATE(ULYDIRICHLETVAL)
  IF(ALLOCATED(LLZDIRICHLETVAL)) DEALLOCATE(LLZDIRICHLETVAL)
  IF(ALLOCATED(ULZDIRICHLETVAL)) DEALLOCATE(ULZDIRICHLETVAL)
  ALLOCATE(   DIRICHLETVAL(Cnfld))
  ALLOCATE(  XDIRICHLETVAL(Cnfld))
  ALLOCATE(  YDIRICHLETVAL(Cnfld))
  ALLOCATE(  ZDIRICHLETVAL(Cnfld))
  ALLOCATE(LLXDIRICHLETVAL(Cnfld))
  ALLOCATE(ULXDIRICHLETVAL(Cnfld))
  ALLOCATE(LLYDIRICHLETVAL(Cnfld))
  ALLOCATE(ULYDIRICHLETVAL(Cnfld))
  ALLOCATE(LLZDIRICHLETVAL(Cnfld))
  ALLOCATE(ULZDIRICHLETVAL(Cnfld))

     DIRICHLETVAL=0.0
    XDIRICHLETVAL=0.0
    YDIRICHLETVAL=0.0
    ZDIRICHLETVAL=0.0
  LLXDIRICHLETVAL=0.0
  ULXDIRICHLETVAL=0.0
  LLYDIRICHLETVAL=0.0
  ULYDIRICHLETVAL=0.0
  LLZDIRICHLETVAL=0.0
  ULZDIRICHLETVAL=0.0

  IF(ALLOCATED(   NEUMANNVAL)) DEALLOCATE(   NEUMANNVAL)
  IF(ALLOCATED(  XNEUMANNVAL)) DEALLOCATE(  XNEUMANNVAL)
  IF(ALLOCATED(  YNEUMANNVAL)) DEALLOCATE(  YNEUMANNVAL)
  IF(ALLOCATED(  ZNEUMANNVAL)) DEALLOCATE(  ZNEUMANNVAL)
  IF(ALLOCATED(LLXNEUMANNVAL)) DEALLOCATE(LLXNEUMANNVAL)
  IF(ALLOCATED(ULXNEUMANNVAL)) DEALLOCATE(ULXNEUMANNVAL)
  IF(ALLOCATED(LLYNEUMANNVAL)) DEALLOCATE(LLYNEUMANNVAL)
  IF(ALLOCATED(ULYNEUMANNVAL)) DEALLOCATE(ULYNEUMANNVAL)
  IF(ALLOCATED(LLZNEUMANNVAL)) DEALLOCATE(LLZNEUMANNVAL)
  IF(ALLOCATED(ULZNEUMANNVAL)) DEALLOCATE(ULZNEUMANNVAL)
  ALLOCATE(   NEUMANNVAL(Cnfld))
  ALLOCATE(  XNEUMANNVAL(Cnfld))
  ALLOCATE(  YNEUMANNVAL(Cnfld))
  ALLOCATE(  ZNEUMANNVAL(Cnfld))
  ALLOCATE(LLXNEUMANNVAL(Cnfld))
  ALLOCATE(ULXNEUMANNVAL(Cnfld))
  ALLOCATE(LLYNEUMANNVAL(Cnfld))
  ALLOCATE(ULYNEUMANNVAL(Cnfld))
  ALLOCATE(LLZNEUMANNVAL(Cnfld))
  ALLOCATE(ULZNEUMANNVAL(Cnfld))

     NEUMANNVAL=0.0
    XNEUMANNVAL=0.0
    YNEUMANNVAL=0.0
    ZNEUMANNVAL=0.0
  LLXNEUMANNVAL=0.0
  ULXNEUMANNVAL=0.0
  LLYNEUMANNVAL=0.0
  ULYNEUMANNVAL=0.0
  LLZNEUMANNVAL=0.0
  ULZNEUMANNVAL=0.0

  RETURN
 END SUBROUTINE RESETBC



!**********************************************************************
!************** ALLOCATE DIFFERENTIATION SCHEMES ARRYAS ***************
!**********************************************************************
 SUBROUTINE RESETDSCHEMES(Cnfld)
  IMPLICIT NONE
  INTEGER(4),INTENT(IN) :: Cnfld

  IF(ALLOCATED( PSMDSCHEME)) DEALLOCATE( PSMDSCHEME)
  IF(ALLOCATED(XPSMDSCHEME)) DEALLOCATE(XPSMDSCHEME)
  IF(ALLOCATED(YPSMDSCHEME)) DEALLOCATE(YPSMDSCHEME)
  IF(ALLOCATED(ZPSMDSCHEME)) DEALLOCATE(ZPSMDSCHEME)
  ALLOCATE( PSMDSCHEME(Cnfld))
  ALLOCATE(XPSMDSCHEME(Cnfld))
  ALLOCATE(YPSMDSCHEME(Cnfld))
  ALLOCATE(ZPSMDSCHEME(Cnfld))

   PSMDSCHEME=.FALSE.
  XPSMDSCHEME=.FALSE.
  YPSMDSCHEME=.FALSE.
  ZPSMDSCHEME=.FALSE.

  IF(ALLOCATED( CSMDSCHEME)) DEALLOCATE( CSMDSCHEME)
  IF(ALLOCATED(XCSMDSCHEME)) DEALLOCATE(XCSMDSCHEME)
  IF(ALLOCATED(YCSMDSCHEME)) DEALLOCATE(YCSMDSCHEME)
  IF(ALLOCATED(ZCSMDSCHEME)) DEALLOCATE(ZCSMDSCHEME)
  ALLOCATE( CSMDSCHEME(Cnfld))
  ALLOCATE(XCSMDSCHEME(Cnfld))
  ALLOCATE(YCSMDSCHEME(Cnfld))
  ALLOCATE(ZCSMDSCHEME(Cnfld))

   CSMDSCHEME=.FALSE.
  XCSMDSCHEME=.FALSE.
  YCSMDSCHEME=.FALSE.
  ZCSMDSCHEME=.FALSE.

  IF(ALLOCATED( FDMDSCHEME)) DEALLOCATE( FDMDSCHEME)
  IF(ALLOCATED(XFDMDSCHEME)) DEALLOCATE(XFDMDSCHEME)
  IF(ALLOCATED(YFDMDSCHEME)) DEALLOCATE(YFDMDSCHEME)
  IF(ALLOCATED(ZFDMDSCHEME)) DEALLOCATE(ZFDMDSCHEME)
  ALLOCATE( FDMDSCHEME(Cnfld))
  ALLOCATE(XFDMDSCHEME(Cnfld))
  ALLOCATE(YFDMDSCHEME(Cnfld))
  ALLOCATE(ZFDMDSCHEME(Cnfld))

   FDMDSCHEME=.FALSE.
  XFDMDSCHEME=.FALSE.
  YFDMDSCHEME=.FALSE.
  ZFDMDSCHEME=.FALSE.

  RETURN
 END SUBROUTINE RESETDSCHEMES



!**********************************************************************
!************** ALLOCATE INTEGERATION SCHEMES ARRYAS ***************
!**********************************************************************
 SUBROUTINE RESETISCHEMES(Cnfld)
  IMPLICIT NONE
  INTEGER(4),INTENT(IN) :: Cnfld

  IF(ALLOCATED( PSMISCHEME)) DEALLOCATE( PSMISCHEME)
  IF(ALLOCATED(XPSMISCHEME)) DEALLOCATE(XPSMISCHEME)
  IF(ALLOCATED(YPSMISCHEME)) DEALLOCATE(YPSMISCHEME)
  IF(ALLOCATED(ZPSMISCHEME)) DEALLOCATE(ZPSMISCHEME)
  ALLOCATE( PSMISCHEME(Cnfld))
  ALLOCATE(XPSMISCHEME(Cnfld))
  ALLOCATE(YPSMISCHEME(Cnfld))
  ALLOCATE(ZPSMISCHEME(Cnfld))

   PSMISCHEME=.FALSE.
  XPSMISCHEME=.FALSE.
  YPSMISCHEME=.FALSE.
  ZPSMISCHEME=.FALSE.

  IF(ALLOCATED( CSMISCHEME)) DEALLOCATE( CSMISCHEME)
  IF(ALLOCATED(XCSMISCHEME)) DEALLOCATE(XCSMISCHEME)
  IF(ALLOCATED(YCSMISCHEME)) DEALLOCATE(YCSMISCHEME)
  IF(ALLOCATED(ZCSMISCHEME)) DEALLOCATE(ZCSMISCHEME)
  ALLOCATE( CSMISCHEME(Cnfld))
  ALLOCATE(XCSMISCHEME(Cnfld))
  ALLOCATE(YCSMISCHEME(Cnfld))
  ALLOCATE(ZCSMISCHEME(Cnfld))

   CSMISCHEME=.FALSE.
  XCSMISCHEME=.FALSE.
  YCSMISCHEME=.FALSE.
  ZCSMISCHEME=.FALSE.

  IF(ALLOCATED( FDMISCHEME)) DEALLOCATE( FDMISCHEME)
  IF(ALLOCATED(XFDMISCHEME)) DEALLOCATE(XFDMISCHEME)
  IF(ALLOCATED(YFDMISCHEME)) DEALLOCATE(YFDMISCHEME)
  IF(ALLOCATED(ZFDMISCHEME)) DEALLOCATE(ZFDMISCHEME)
  ALLOCATE( FDMISCHEME(Cnfld))
  ALLOCATE(XFDMISCHEME(Cnfld))
  ALLOCATE(YFDMISCHEME(Cnfld))
  ALLOCATE(ZFDMISCHEME(Cnfld))

   FDMISCHEME=.FALSE.
  XFDMISCHEME=.FALSE.
  YFDMISCHEME=.FALSE.
  ZFDMISCHEME=.FALSE.

  RETURN
 END SUBROUTINE RESETISCHEMES



!****************************************************************************
!******************* DERIVATIVES OF SYSTEM FIELDS ***************************
!****************************************************************************
!************ MULTIPLICATION OF TWO FIELDS (fg) *******************
 SUBROUTINE c8c8c8fg1D(kf,kg,kfg)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)  :: kf(:),kg(:)
  COMPLEX(8),       INTENT(OUT) :: kfg(:)
  COMPLEX(8),       ALLOCATABLE :: exkg1d(:)
  COMPLEX(8),       ALLOCATABLE :: exkf1d(:)
  COMPLEX(8),       ALLOCATABLE :: exkfg1d(:)
  INTEGER(4)                    :: rD1MAT13,rfDIMS
  INTEGER(4)                    :: kD1MAT13,kfDIMS
  REAL(8),          ALLOCATABLE :: rfg(:)
  REAL(8),          ALLOCATABLE :: exrfg1d(:)
  REAL(8),          ALLOCATABLE :: exrf1d(:),exrg1d(:)

  kfDIMS=SIZE(kf)
  kD1MAT13=kfDIMS/2

  rfDIMS=2*(kfDIMS-1)
  rD1MAT13=rfDIMS/2

  IF(ALLOCATED(exkf1d).EQV..FALSE.)  ALLOCATE(exkf1d(  kfDIMS+kD1MAT13))
  IF(ALLOCATED(exrf1d).EQV..FALSE.)  ALLOCATE(exrf1d(  rfDIMS+rD1MAT13))
  IF(ALLOCATED(exkg1d).EQV..FALSE.)  ALLOCATE(exkg1d(  kfDIMS+kD1MAT13))
  IF(ALLOCATED(exrg1d).EQV..FALSE.)  ALLOCATE(exrg1d(  rfDIMS+rD1MAT13))
  IF(ALLOCATED(exkfg1d).EQV..FALSE.) ALLOCATE(exkfg1d(kfDIMS+kD1MAT13))
  IF(ALLOCATED(exrfg1d).EQV..FALSE.) ALLOCATE(exrfg1d(rfDIMS+rD1MAT13))

  CALL addFFTalias(kf,exkf1d)
  CALL iFFTW(exkf1d,exrf1d)

  CALL addFFTalias(kg,exkg1d)
  CALL iFFTW(exkg1d,exrg1d)

  exrfg1d=exrf1d*exrg1d
  CALL FFTW(exrfg1d,exkfg1d)
  CALL rmvFFTalias(exkfg1d,kfg)

  RETURN
 END SUBROUTINE c8c8c8fg1D

 SUBROUTINE c8c8c8fg2D(kf,kg,kfg)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)  :: kf(:,:),kg(:,:)
  COMPLEX(8),       INTENT(OUT) :: kfg(:,:)
  COMPLEX(8),       ALLOCATABLE :: exkg2d(:,:)
  COMPLEX(8),       ALLOCATABLE :: exkf2d(:,:)
  COMPLEX(8),       ALLOCATABLE :: exkfg2d(:,:)
  INTEGER(4)                    :: rD1MAT13,rD2MAT13,rfDIMS(2)
  INTEGER(4)                    :: kD1MAT13,kD2MAT13,kfDIMS(2)
  REAL(8),          ALLOCATABLE :: rfg(:,:)
  REAL(8),          ALLOCATABLE :: exrfg2d(:,:)
  REAL(8),          ALLOCATABLE :: exrf2d(:,:),exrg2d(:,:)

  kfDIMS=SHAPE(kf)
  kD1MAT13=kfDIMS(1)/2
  kD2MAT13=kfDIMS(2)/2

  rfDIMS(1)=2*(kfDIMS(1)-1)
  rfDIMS(2)=kfDIMS(2)
  rD1MAT13=rfDIMS(1)/2
  rD2MAT13=rfDIMS(2)/2

  IF(ALLOCATED(exkf2d).EQV..FALSE.)  ALLOCATE(exkf2d(  kfDIMS(1)+kD1MAT13,kfDIMS(2)+kD2MAT13))
  IF(ALLOCATED(exrf2d).EQV..FALSE.)  ALLOCATE(exrf2d(  rfDIMS(1)+rD1MAT13,rfDIMS(2)+rD2MAT13))
  IF(ALLOCATED(exkg2d).EQV..FALSE.)  ALLOCATE(exkg2d(  kfDIMS(1)+kD1MAT13,kfDIMS(2)+kD2MAT13))
  IF(ALLOCATED(exrg2d).EQV..FALSE.)  ALLOCATE(exrg2d(  rfDIMS(1)+rD1MAT13,rfDIMS(2)+rD2MAT13))
  IF(ALLOCATED(exkfg2d).EQV..FALSE.) ALLOCATE(exkfg2d(kfDIMS(1)+kD1MAT13,kfDIMS(2)+kD2MAT13))
  IF(ALLOCATED(exrfg2d).EQV..FALSE.) ALLOCATE(exrfg2d(rfDIMS(1)+rD1MAT13,rfDIMS(2)+rD2MAT13))

  CALL addFFTalias(kf,exkf2d)
  CALL iFFTW(exkf2d,exrf2d)

  CALL addFFTalias(kg,exkg2d)
  CALL iFFTW(exkg2d,exrg2d)

  exrfg2d=exrf2d*exrg2d
  CALL FFTW(exrfg2d,exkfg2d)
  CALL rmvFFTalias(exkfg2d,kfg)

  RETURN
 END SUBROUTINE c8c8c8fg2D

 SUBROUTINE c8c8c8fg3D(kf,kg,kfg)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)  :: kf(:,:,:),kg(:,:,:)
  COMPLEX(8),       INTENT(OUT) :: kfg(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: exkg3d(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: exkf3d(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: exkfg3d(:,:,:)
  INTEGER(4)                    :: rD1MAT13,rD2MAT13,rD3MAT13,rfDIMS(3)
  INTEGER(4)                    :: kD1MAT13,kD2MAT13,kD3MAT13,kfDIMS(3)
  REAL(8),          ALLOCATABLE :: rfg(:,:,:)
  REAL(8),          ALLOCATABLE :: exrfg3d(:,:,:)
  REAL(8),          ALLOCATABLE :: exrf3d(:,:,:),exrg3d(:,:,:)

  kfDIMS=SHAPE(kf)
  kD1MAT13=kfDIMS(1)/2
  kD2MAT13=kfDIMS(2)/2
  kD3MAT13=kfDIMS(3)/2

  rfDIMS(1)=2*(kfDIMS(1)-1)
  rfDIMS(2)=kfDIMS(2)
  rfDIMS(3)=kfDIMS(3)
  rD1MAT13=rfDIMS(1)/2
  rD2MAT13=rfDIMS(2)/2
  rD3MAT13=rfDIMS(3)/2

  IF(ALLOCATED(exkf3d).EQV..FALSE.)  ALLOCATE(exkf3d(  kfDIMS(1)+kD1MAT13,kfDIMS(2)+kD2MAT13,kfDIMS(3)+kD3MAT13))
  IF(ALLOCATED(exrf3d).EQV..FALSE.)  ALLOCATE(exrf3d(  rfDIMS(1)+rD1MAT13,rfDIMS(2)+rD2MAT13,rfDIMS(3)+rD3MAT13))
  IF(ALLOCATED(exkg3d).EQV..FALSE.)  ALLOCATE(exkg3d(  kfDIMS(1)+kD1MAT13,kfDIMS(2)+kD2MAT13,kfDIMS(3)+kD3MAT13))
  IF(ALLOCATED(exrg3d).EQV..FALSE.)  ALLOCATE(exrg3d(  rfDIMS(1)+rD1MAT13,rfDIMS(2)+rD2MAT13,rfDIMS(3)+rD3MAT13))
  IF(ALLOCATED(exkfg3d).EQV..FALSE.) ALLOCATE(exkfg3d(kfDIMS(1)+kD1MAT13,kfDIMS(2)+kD2MAT13,kfDIMS(3)+kD3MAT13))
  IF(ALLOCATED(exrfg3d).EQV..FALSE.) ALLOCATE(exrfg3d(rfDIMS(1)+rD1MAT13,rfDIMS(2)+rD2MAT13,rfDIMS(3)+rD3MAT13))

  CALL addFFTalias(kf,exkf3d)
  CALL iFFTW(exkf3d,exrf3d)

  CALL addFFTalias(kg,exkg3d)
  CALL iFFTW(exkg3d,exrg3d)

  exrfg3d=exrf3d*exrg3d
  CALL FFTW(exrfg3d,exkfg3d)
  CALL rmvFFTalias(exkfg3d,kfg)

  RETURN
 END SUBROUTINE c8c8c8fg3D



!************ MULTIPLICATION OF A FIELD WITH THE DRIVATIVE OF ANOTHER FIELD (fDg) *******************
 SUBROUTINE c8c8c8fDg1DNONE(kf,kg,likx,kfgx)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:)
  COMPLEX(8),       INTENT(IN)     :: kf(:),kg(:)
  COMPLEX(8),       INTENT(OUT)    :: kfgx(:)

  CALL fDg(kf,kg,likx,kfgx,1,"x")

  RETURN
 END SUBROUTINE c8c8c8fDg1DNONE

 SUBROUTINE c8c8c8fDg1D1INT(kf,kg,likx,kfgx,fldID)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:)
  COMPLEX(8),       INTENT(IN)     :: kf(:),kg(:)
  COMPLEX(8),       INTENT(OUT)    :: kfgx(:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL fDg(kf,kg,likx,kfgx,fldID,"x")

  RETURN
 END SUBROUTINE c8c8c8fDg1D1INT

 SUBROUTINE c8c8c8fDg1D1CHR(kf,kg,likx,kfgx,CSPACE)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:)
  COMPLEX(8),       INTENT(IN)     :: kf(:),kg(:)
  COMPLEX(8),       INTENT(OUT)    :: kfgx(:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL fDg(kf,kg,likx,kfgx,1,CSPACE)

  RETURN
 END SUBROUTINE c8c8c8fDg1D1CHR

 SUBROUTINE c8c8c8fDg1D(kf,kg,likx,kfgx,fldID,CSPACE)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)  :: likx(:)
  COMPLEX(8),       INTENT(IN)  :: kf(:),kg(:)
  COMPLEX(8),       INTENT(OUT) :: kfgx(:)
  COMPLEX(8),       ALLOCATABLE :: exlikx(:)
  COMPLEX(8),       ALLOCATABLE :: kgx(:)
  COMPLEX(8),       ALLOCATABLE :: exkgx1d(:)
  COMPLEX(8),       ALLOCATABLE :: exkf1d(:)
  COMPLEX(8),       ALLOCATABLE :: exkfgx1d(:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: rD1MAT13,rfDIMS
  INTEGER(4)                    :: kD1MAT13,kfDIMS
  INTEGER(4)                    :: DxDIR
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE    ! CURRENT SPACE
  CHARACTER(LEN=1)              :: CSPACE1
  REAL(8),          ALLOCATABLE :: rfgx(:)
  REAL(8),          ALLOCATABLE :: exrfgx1d(:)
  REAL(8),          ALLOCATABLE :: exrf1d(:),exrgx1d(:)

  kfDIMS=SIZE(kf)
  kD1MAT13=kfDIMS/2

  rfDIMS=2*(kfDIMS-1)
  rD1MAT13=rfDIMS/2

  IF(LEN(CSPACE).LT.1) THEN
   PRINT*, "ERROR, fDg: NUMBER OF CURRENT SPACES ARE NOT ENOUGH!"
   STOP
  ELSE IF(LEN(CSPACE).EQ.1) THEN
   CSPACE1=CSPACE(1:1)
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, fDg: NUMBER OF CURRENT SPACES ARE TOO MANY!"
   STOP
  END IF

   IF(ALLOCATED(kgx).EQV..FALSE.)      ALLOCATE(kgx(kfDIMS))
   IF(ALLOCATED(exkf1d).EQV..FALSE.)   ALLOCATE(exkf1d(  kfDIMS+kD1MAT13))
   IF(ALLOCATED(exrf1d).EQV..FALSE.)   ALLOCATE(exrf1d(  rfDIMS+rD1MAT13))
   IF(ALLOCATED(exkgx1d).EQV..FALSE.)  ALLOCATE(exkgx1d( kfDIMS+kD1MAT13))
   IF(ALLOCATED(exrgx1d).EQV..FALSE.)  ALLOCATE(exrgx1d( rfDIMS+rD1MAT13))
   IF(ALLOCATED(exkfgx1d).EQV..FALSE.) ALLOCATE(exkfgx1d(kfDIMS+kD1MAT13))
   IF(ALLOCATED(exrfgx1d).EQV..FALSE.) ALLOCATE(exrfgx1d(rfDIMS+rD1MAT13))

   CALL addFFTalias(kf,exkf1d)
   CALL iFFTW(exkf1d,exrf1d)

   CALL Df(kg,likx,kgx,1,fldID,CSPACE)
   CALL addFFTalias(kgx,exkgx1d)
   CALL iFFTW(exkgx1d,exrgx1d)

   exrfgx1d=exrf1d*exrgx1d
   CALL FFTW(exrfgx1d,exkfgx1d)
   CALL rmvFFTalias(exkfgx1d,kfgx)

  RETURN
 END SUBROUTINE c8c8c8fDg1D

 SUBROUTINE c8c8c8fDg2DNONE(kf,kg,likx,kfgx)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:,:)
  COMPLEX(8),       INTENT(IN)     :: kf(:,:),kg(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfgx(:,:)

  CALL fDg(kf,kg,likx,kfgx,1,"x")

  RETURN
 END SUBROUTINE c8c8c8fDg2DNONE

 SUBROUTINE c8c8c8fDg2D1INT(kf,kg,likx,kfgx,fldID)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:,:)
  COMPLEX(8),       INTENT(IN)     :: kf(:,:),kg(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfgx(:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL fDg(kf,kg,likx,kfgx,fldID,"x")

  RETURN
 END SUBROUTINE c8c8c8fDg2D1INT

 SUBROUTINE c8c8c8fDg2D1CHR(kf,kg,likx,kfgx,CSPACE)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:,:)
  COMPLEX(8),       INTENT(IN)     :: kf(:,:),kg(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfgx(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL fDg(kf,kg,likx,kfgx,1,CSPACE)

  RETURN
 END SUBROUTINE c8c8c8fDg2D1CHR

 SUBROUTINE c8c8c8fDg2D(kf,kg,likx,kfgx,fldID,CSPACE)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)  :: likx(:,:)
  COMPLEX(8),       INTENT(IN)  :: kf(:,:),kg(:,:)
  COMPLEX(8),       INTENT(OUT) :: kfgx(:,:)
  COMPLEX(8),       ALLOCATABLE :: exlikx(:,:)
  COMPLEX(8),       ALLOCATABLE :: kgx(:,:)
  COMPLEX(8),       ALLOCATABLE :: exkgx2d(:,:)
  COMPLEX(8),       ALLOCATABLE :: exkf2d(:,:)
  COMPLEX(8),       ALLOCATABLE :: exkfgx2d(:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: rD1MAT13,rD2MAT13,rfDIMS(2)
  INTEGER(4)                    :: kD1MAT13,kD2MAT13,kfDIMS(2)
  INTEGER(4)                    :: DxDIR
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE    ! CURRENT SPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2
  REAL(8),          ALLOCATABLE :: rfgx(:,:)
  REAL(8),          ALLOCATABLE :: exrfgx2d(:,:)
  REAL(8),          ALLOCATABLE :: exrf2d(:,:),exrgx2d(:,:)

  kfDIMS=SHAPE(kf)
  kD1MAT13=kfDIMS(1)/2
  kD2MAT13=kfDIMS(2)/2

  rfDIMS(1)=2*(kfDIMS(1)-1)
  rfDIMS(2)=kfDIMS(2)
  rD1MAT13=rfDIMS(1)/2
  rD2MAT13=rfDIMS(2)/2

  IF(LEN(CSPACE).LT.1) THEN
   PRINT*, "ERROR, fDg: NUMBER OF CURRENT SPACES ARE NOT ENOUGH!"
   STOP
  ELSE IF(LEN(CSPACE).EQ.1) THEN
   CSPACE1=CSPACE(1:1)
  ELSE IF(LEN(CSPACE).GT.1) THEN
   PRINT*, "ERROR, fDg: NUMBER OF CURRENT SPACES ARE TOO MANY!"
   STOP
  END IF

   IF(ALLOCATED(kgx).EQV..FALSE.)      ALLOCATE(kgx(kfDIMS(1),kfDIMS(2)))
   IF(ALLOCATED(exkf2d).EQV..FALSE.)   ALLOCATE(exkf2d(  kfDIMS(1)+kD1MAT13,kfDIMS(2)+kD2MAT13))
   IF(ALLOCATED(exrf2d).EQV..FALSE.)   ALLOCATE(exrf2d(  rfDIMS(1)+rD1MAT13,rfDIMS(2)+rD2MAT13))
   IF(ALLOCATED(exkgx2d).EQV..FALSE.)  ALLOCATE(exkgx2d(  kfDIMS(1)+kD1MAT13,kfDIMS(2)+kD2MAT13))
   IF(ALLOCATED(exrgx2d).EQV..FALSE.)  ALLOCATE(exrgx2d(  rfDIMS(1)+rD1MAT13,rfDIMS(2)+rD2MAT13))
   IF(ALLOCATED(exkfgx2d).EQV..FALSE.) ALLOCATE(exkfgx2d(kfDIMS(1)+kD1MAT13,kfDIMS(2)+kD2MAT13))
   IF(ALLOCATED(exrfgx2d).EQV..FALSE.) ALLOCATE(exrfgx2d(rfDIMS(1)+rD1MAT13,rfDIMS(2)+rD2MAT13))

   CALL addFFTalias(kf,exkf2d)
   CALL iFFTW(exkf2d,exrf2d)

   CALL Df(kg,likx,kgx,1,fldID,CSPACE)
   CALL addFFTalias(kgx,exkgx2d)
   CALL iFFTW(exkgx2d,exrgx2d)

   exrfgx2d=exrf2d*exrgx2d
   CALL FFTW(exrfgx2d,exkfgx2d)
   CALL rmvFFTalias(exkfgx2d,kfgx)

  RETURN
 END SUBROUTINE c8c8c8fDg2D


 SUBROUTINE c8c8c8fDg3DNONE(kf,kg,likx,kfgx)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:,:,:)
  COMPLEX(8),       INTENT(IN)     :: kf(:,:,:),kg(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfgx(:,:,:)

  CALL fDg(kf,kg,likx,kfgx,1,"x")

  RETURN
 END SUBROUTINE c8c8c8fDg3DNONE

 SUBROUTINE c8c8c8fDg3D1INT(kf,kg,likx,kfgx,fldID)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:,:,:)
  COMPLEX(8),       INTENT(IN)     :: kf(:,:,:),kg(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfgx(:,:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL fDg(kf,kg,likx,kfgx,fldID,"x")

  RETURN
 END SUBROUTINE c8c8c8fDg3D1INT

 SUBROUTINE c8c8c8fDg3D1CHR(kf,kg,likx,kfgx,CSPACE)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:,:,:)
  COMPLEX(8),       INTENT(IN)     :: kf(:,:,:),kg(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfgx(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL fDg(kf,kg,likx,kfgx,1,CSPACE)

  RETURN
 END SUBROUTINE c8c8c8fDg3D1CHR

 SUBROUTINE c8c8c8fDg3D(kf,kg,likx,kfgx,fldID,CSPACE)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)  :: likx(:,:,:)
  COMPLEX(8),       INTENT(IN)  :: kf(:,:,:),kg(:,:,:)
  COMPLEX(8),       INTENT(OUT) :: kfgx(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: exlikx(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: kgx(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: exkgx3d(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: exkf3d(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: exkfgx3d(:,:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: rD1MAT13,rD2MAT13,rD3MAT13,rfDIMS(3)
  INTEGER(4)                    :: kD1MAT13,kD2MAT13,kD3MAT13,kfDIMS(3)
  INTEGER(4)                    :: DxDIR
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE    ! CURRENT SPACE
  CHARACTER(LEN=1)              :: CSPACE1
  REAL(8),          ALLOCATABLE :: rfgx(:,:,:)
  REAL(8),          ALLOCATABLE :: exrfgx3d(:,:,:)
  REAL(8),          ALLOCATABLE :: exrf3d(:,:,:),exrgx3d(:,:,:)

  kfDIMS=SHAPE(kf)
  kD1MAT13=kfDIMS(1)/2
  kD2MAT13=kfDIMS(2)/2
  kD3MAT13=kfDIMS(3)/2

  rfDIMS(1)=2*(kfDIMS(1)-1)
  rfDIMS(2)=kfDIMS(2)
  rfDIMS(3)=kfDIMS(3)
  rD1MAT13=rfDIMS(1)/2
  rD2MAT13=rfDIMS(2)/2
  rD3MAT13=rfDIMS(3)/2

  IF(LEN(CSPACE).LT.1) THEN
   PRINT*, "ERROR, fDg: NUMBER OF CURRENT SPACES ARE NOT ENOUGH!"
   STOP
  ELSE IF(LEN(CSPACE).EQ.1) THEN
   CSPACE1=CSPACE(1:1)
  ELSE IF(LEN(CSPACE).GT.1) THEN
   PRINT*, "ERROR, fDg: NUMBER OF CURRENT SPACES ARE TOO MANY!"
   STOP
  END IF

   IF(ALLOCATED(kgx).EQV..FALSE.)      ALLOCATE(kgx(kfDIMS(1),kfDIMS(2),kfDIMS(3)))
   IF(ALLOCATED(exkf3d).EQV..FALSE.)   ALLOCATE(exkf3d(  kfDIMS(1)+kD1MAT13,kfDIMS(2)+kD2MAT13,kfDIMS(3)+kD3MAT13))
   IF(ALLOCATED(exrf3d).EQV..FALSE.)   ALLOCATE(exrf3d(  rfDIMS(1)+rD1MAT13,rfDIMS(2)+rD2MAT13,rfDIMS(3)+rD3MAT13))
   IF(ALLOCATED(exkgx3d).EQV..FALSE.)  ALLOCATE(exkgx3d(  kfDIMS(1)+kD1MAT13,kfDIMS(2)+kD2MAT13,kfDIMS(3)+kD3MAT13))
   IF(ALLOCATED(exrgx3d).EQV..FALSE.)  ALLOCATE(exrgx3d(  rfDIMS(1)+rD1MAT13,rfDIMS(2)+rD2MAT13,rfDIMS(3)+rD3MAT13))
   IF(ALLOCATED(exkfgx3d).EQV..FALSE.) ALLOCATE(exkfgx3d(kfDIMS(1)+kD1MAT13,kfDIMS(2)+kD2MAT13,kfDIMS(3)+kD3MAT13))
   IF(ALLOCATED(exrfgx3d).EQV..FALSE.) ALLOCATE(exrfgx3d(rfDIMS(1)+rD1MAT13,rfDIMS(2)+rD2MAT13,rfDIMS(3)+rD3MAT13))

   CALL addFFTalias(kf,exkf3d)
   CALL iFFTW(exkf3d,exrf3d)

   CALL Df(kg,likx,kgx,1,fldID,CSPACE)
   CALL addFFTalias(kgx,exkgx3d)
   CALL iFFTW(exkgx3d,exrgx3d)

   exrfgx3d=exrf3d*exrgx3d
   CALL FFTW(exrfgx3d,exkfgx3d)
   CALL rmvFFTalias(exkfgx3d,kfgx)

  RETURN
 END SUBROUTINE c8c8c8fDg3D


!************* FUNNCTION DERIVATIVE W.R.T. X (Dfx) ************
 SUBROUTINE c8c8c8Df1DNONE(kf,likx,kfx,DORDER)
  IMPLICIT NONE
  COMPLEX(8), INTENT(IN)  :: likx(:)
  COMPLEX(8), INTENT(IN)  :: kf(:)
  COMPLEX(8), INTENT(OUT) :: kfx(:)
  INTEGER(4), INTENT(IN)  :: DORDER
  INTEGER(4)              :: IORDER

  CALL Df(kf,likx,kfx,DORDER,1,"x")

  RETURN
 END SUBROUTINE c8c8c8Df1DNONE

 SUBROUTINE c8c8c8Df1D1INT(kf,likx,kfx,DORDER,fldID)
  IMPLICIT NONE
  COMPLEX(8), INTENT(IN)  :: likx(:)
  COMPLEX(8), INTENT(IN)  :: kf(:)
  COMPLEX(8), INTENT(OUT) :: kfx(:)
  INTEGER(4), INTENT(IN)  :: DORDER,fldID
  INTEGER(4)              :: IORDER

  CALL Df(kf,likx,kfx,DORDER,fldID,"x")

  RETURN
 END SUBROUTINE c8c8c8Df1D1INT

 SUBROUTINE c8c8c8Df1D1CHR(kf,likx,kfx,DORDER,CSPACE)
  IMPLICIT NONE
  COMPLEX(8), INTENT(IN)       :: likx(:)
  COMPLEX(8), INTENT(IN)       :: kf(:)
  COMPLEX(8), INTENT(OUT)      :: kfx(:)
  INTEGER(4), INTENT(IN)       :: DORDER
  CHARACTER(LEN=*), INTENT(IN) :: CSPACE        ! CURRENT SPACE

  CALL Df(kf,likx,kfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE c8c8c8Df1D1CHR

 SUBROUTINE c8c8c8Df1D(kf,likx,kfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  COMPLEX(8), INTENT(IN)       :: likx(:)
  COMPLEX(8), INTENT(IN)       :: kf(:)
  COMPLEX(8), INTENT(OUT)      :: kfx(:)
  COMPLEX(8), ALLOCATABLE      :: exkfx(:)
  COMPLEX(8), ALLOCATABLE      :: exlikx(:)
  INTEGER(4), INTENT(IN)       :: DORDER,fldID
  INTEGER(4)                   :: IORDER
  INTEGER(4)                   :: MDIMS
  INTEGER(4)                   :: D1MAT13
  CHARACTER(LEN=*), INTENT(IN) :: CSPACE        ! CURRENT SPACE

  MDIMS=SIZE(kf)
  D1MAT13=(MDIMS-1)/3

  IF(GONONLINEAR) THEN
   IF(ALLOCATED(exkfx).EQV..FALSE.)  ALLOCATE( exkfx(MDIMS+D1MAT13))
   IF(ALLOCATED(exlikx).EQV..FALSE.) ALLOCATE(exlikx(MDIMS+D1MAT13))
   CALL addFFTalias(kf,exkfx)
   CALL addFFTalias(likx,exlikx)
   DO IORDER=1,DORDER
    exkfx=exlikx*exkfx
   END DO
   CALL rmvFFTalias(exkfx,kfx)
  ELSE
   kfx=kf
   DO IORDER=1,DORDER
    kfx=likx*kfx
   END DO
  END IF

  RETURN
 END SUBROUTINE c8c8c8Df1D

 SUBROUTINE r4r4c8Df1DNONE(f,LX1D,kfx,DORDER)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX1D(:)
  REAL(4),    INTENT(IN)           :: f(:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:)
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL Df(f,LX1D,kfx,DORDER,1,"x")

  RETURN
 END SUBROUTINE r4r4c8Df1DNONE

 SUBROUTINE r4r4c8Df1D1INT(f,LX1D,kfx,DORDER,fldID)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX1D(:)
  REAL(4),    INTENT(IN)           :: f(:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:)
  INTEGER(4), INTENT(IN)           :: fldID
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL Df(f,LX1D,kfx,DORDER,fldID,"x")

  RETURN
 END SUBROUTINE r4r4c8Df1D1INT

 SUBROUTINE r4r4c8Df1D1CHR(f,LX1D,kfx,DORDER,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX1D(:)
  REAL(4),          INTENT(IN)     :: f(:)
  COMPLEX(8),       INTENT(OUT)    :: kfx(:)
  INTEGER(4),       INTENT(IN)     :: DORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE

  CALL Df(f,LX1D,kfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE r4r4c8Df1D1CHR

 SUBROUTINE r4r4c8Df1D(f,LX1D,kfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX1D(:)
  REAL(4),    INTENT(IN)           :: f(:)
  REAL(4),    ALLOCATABLE          :: rfx(:)
  COMPLEX(8), ALLOCATABLE          :: kf(:),likx(:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:)
  INTEGER(4), INTENT(IN)           :: DORDER,fldID
  INTEGER(4)                       :: IORDER
  INTEGER(4)                       :: fDIM
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1
  LOGICAL,    SAVE                 :: PSMACCESSID=.TRUE.
  LOGICAL                          :: XDIR=.FALSE.
  LOGICAL                          :: YDIR=.FALSE.
  LOGICAL                          :: ZDIR=.FALSE.

  fDIM=SIZE(f)

  CSPACE1=CSPACE(1:1)
  IF(CSPACE1.EQ."x".OR.CSPACE1.EQ."X") THEN
   XDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."y".OR.CSPACE1.EQ."Y") THEN
   YDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."z".OR.CSPACE1.EQ."Z") THEN
   ZDIR=.TRUE.
  ELSE
   XDIR=.TRUE.
  END IF

  IF(PSMDSCHEME(fldID).OR.((XDIR.AND.XPSMDSCHEME(fldID)).OR.(YDIR.AND.YPSMDSCHEME(fldID)).OR.(ZDIR.AND.ZPSMDSCHEME(fldID)))) THEN
   IF(PSMACCESSID) THEN
    IF( PSMDSCHEME(fldID)) PRINT*, " PSMDSCHEME("//CHAR(48+fldID)//")"
    IF(XPSMDSCHEME(fldID)) PRINT*, "XPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(YPSMDSCHEME(fldID)) PRINT*, "YPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(ZPSMDSCHEME(fldID)) PRINT*, "ZPSMDSCHEME("//CHAR(48+fldID)//")"
    PSMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(kf).EQV..FALSE.) ALLOCATE(kf(fDIM/2+1))
   IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIM/2+1))
   CALL KGRIDBUILDER(LX1D,likx)
   CALL FFTW(f,kf)
   CALL Df(kf,likx,kfx,DORDER,fldID,CSPACE)
  ELSE
   IF(ALLOCATED(rfx).EQV..FALSE.) ALLOCATE(rfx(fDIM))
   CALL Df(f,LX1D,rfx,DORDER,fldID,CSPACE)
   CALL FFTW(rfx,kfx)
  END IF

  RETURN
 END SUBROUTINE r4r4c8Df1D

 SUBROUTINE r4r4r4Df1DNONE(f,LX1D,rfx,DORDER)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX1D(:)
  REAL(4),    INTENT(IN)           :: f(:)
  REAL(4),    INTENT(OUT)          :: rfx(:)
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL Df(f,LX1D,rfx,DORDER,1,"x")

  RETURN
 END SUBROUTINE r4r4r4Df1DNONE

 SUBROUTINE r4r4r4Df1D1INT(f,LX1D,rfx,DORDER,fldID)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX1D(:)
  REAL(4),    INTENT(IN)           :: f(:)
  REAL(4),    INTENT(OUT)          :: rfx(:)
  INTEGER(4), INTENT(IN)           :: fldID
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL Df(f,LX1D,rfx,DORDER,fldID,"x")

  RETURN
 END SUBROUTINE r4r4r4Df1D1INT

 SUBROUTINE r4r4r4Df1D1CHR(f,LX1D,rfx,DORDER,CSPACE)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX1D(:)
  REAL(4),    INTENT(IN)           :: f(:)
  REAL(4),    INTENT(OUT)          :: rfx(:)
  INTEGER(4), INTENT(IN)           :: DORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE

  CALL Df(f,LX1D,rfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE r4r4r4Df1D1CHR

 SUBROUTINE r4r4r4Df1D(f,LX1D,rfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX1D(:)
  REAL(4),    INTENT(IN)           :: f(:)
  REAL(4),    INTENT(OUT)          :: rfx(:)
  REAL(4),    ALLOCATABLE          :: Dx(:)
  REAL(4),    ALLOCATABLE          :: Dfx(:)
  REAL(4),    ALLOCATABLE          :: tfx(:)
  COMPLEX(8), ALLOCATABLE          :: kf(:),kfx(:)
  COMPLEX(8), ALLOCATABLE          :: likx(:)
  COMPLEX(8), ALLOCATABLE          :: iK(:)
  INTEGER(4), INTENT(IN)           :: fldID
  INTEGER(4)                       :: fDIM,ifDIM
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4)                       :: IORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1
  LOGICAL,    SAVE                 :: FDMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: PSMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: CSMACCESSID=.TRUE.
  LOGICAL                          :: XDIR=.FALSE.
  LOGICAL                          :: YDIR=.FALSE.
  LOGICAL                          :: ZDIR=.FALSE.

  fDIM=SIZE(f)

  CSPACE1=CSPACE(1:1)
  IF(CSPACE1.EQ."x".OR.CSPACE1.EQ."X") THEN
   XDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."y".OR.CSPACE1.EQ."Y") THEN
   YDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."z".OR.CSPACE1.EQ."Z") THEN
   ZDIR=.TRUE.
  ELSE
   XDIR=.TRUE.
  END IF

  IF(FDMDSCHEME(fldID).OR.((XDIR.AND.XFDMDSCHEME(fldID)).OR.(YDIR.AND.YFDMDSCHEME(fldID)).OR.(ZDIR.AND.ZFDMDSCHEME(fldID)))) THEN
   IF(FDMACCESSID) THEN
    IF( FDMDSCHEME(fldID)) PRINT*, " FDMDSCHEME("//CHAR(48+fldID)//")"
    IF(XFDMDSCHEME(fldID)) PRINT*, "XFDMDSCHEME("//CHAR(48+fldID)//")"
    IF(YFDMDSCHEME(fldID)) PRINT*, "YFDMDSCHEME("//CHAR(48+fldID)//")"
    IF(ZFDMDSCHEME(fldID)) PRINT*, "ZFDMDSCHEME("//CHAR(48+fldID)//")"
    FDMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(Dx)) DEALLOCATE(Dx)
   ALLOCATE(Dx(fDIM))
   Dx(1:fDIM-1)=LX1D(2:fDIM)-LX1D(1:fDIM-1)
   Dx(fDIM)=Dx(fDIM-1)
   IF(DORDER.EQ.1) THEN
    IF(FDMORDER.EQ.2) THEN
     rfx(1)=(-3.0*f(1)+4.0*f(2)-f(3))/(2.0*Dx(1))
!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(ifDIM)
!$OMP DO SCHEDULE(DYNAMIC,10)
     DO ifDIM=2,fDIM-1
      rfx(ifDIM)=(f(ifDIM+1)-f(ifDIM-1))/(2.0*Dx(ifDIM))
     END DO
!$OMP END DO
!$OMP END PARALLEL
     rfx(fDIM)=(3.0*f(fDIM)-4.0*f(fDIM-1)+f(fDIM-2))/(2.0*Dx(fDIM))
    ELSE IF(FDMORDER.EQ.4) THEN
     rfx(1)=(-f(3)+8.0*f(2))/(12.0*Dx(1))
     rfx(2)=(-f(4)+8.0*f(3)-8.0*f(1))/(12.0*Dx(2))
!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(ifDIM)
!$OMP DO SCHEDULE(DYNAMIC,10)
     DO ifDIM=3,fDIM-2
      rfx(ifDIM)=(-f(ifDIM+2)+8.0*f(ifDIM+1)-8.0*f(ifDIM-1)+f(ifDIM-2))/(12.0*Dx(ifDIM))
     END DO
!$OMP END DO
!$OMP END PARALLEL
     rfx(fDIM-1)=(8.0*f(fDIM)-8.0*f(fDIM-2)+f(fDIM-3))/(12.0*Dx(fDIM-1))
     rfx(fDIM)=(-8.0*f(fDIM-1)+f(fDIM-2))/(12.0*Dx(fDIM))
    END IF
   ELSE IF(DORDER.EQ.2) THEN
    IF(FDMORDER.EQ.2) THEN
     rfx(1)=(2.0*f(1)-5.0*f(2)+4.0*f(3)-f(4))/(Dx(1)**2)
!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(ifDIM)
!$OMP DO SCHEDULE(DYNAMIC,10)
     DO ifDIM=2,fDIM-1
      rfx(ifDIM)=(f(ifDIM+1)-2.0*f(ifDIM)+f(ifDIM-1))/(Dx(ifDIM)**2)
     END DO
!$OMP END DO
!$OMP END PARALLEL
     rfx(fDIM)=(2.0*f(fDIM)-5.0*f(fDIM-1)+4.0*f(fDIM-2)-f(fDIM-3))/(Dx(fDIM)**2)
    ELSE IF(FDMORDER.EQ.4) THEN
     rfx(1)=(2.0*f(1)-5.0*f(2)+4.0*f(3)-f(4))/(Dx(1)**2)
     rfx(2)=(f(3)-2.0*f(2)+f(1))/(Dx(2)**2)
!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(ifDIM)
!$OMP DO SCHEDULE(DYNAMIC,10)
     DO ifDIM=3,fDIM-2
      rfx(ifDIM)=(-f(ifDIM+2)+16.0*f(ifDIM+1)-30.0*f(ifDIM)+16.0*f(ifDIM-1)-f(ifDIM-2))/(12.0*(Dx(ifDIM)**2))
     END DO
!$OMP END DO
!$OMP END PARALLEL
     rfx(fDIM-1)=(f(fDIM)-2.0*f(fDIM-1)+f(fDIM-2))/(Dx(fDIM-1)**2)
     rfx(fDIM)=(2.0*f(fDIM)-5.0*f(fDIM-1)+4.0*f(fDIM-2)-f(fDIM-3))/(Dx(fDIM)**2)
    END IF
   END IF

  ELSE IF(CSMDSCHEME(fldID).OR.((XDIR.AND.XCSMDSCHEME(fldID)).OR.(YDIR.AND.YCSMDSCHEME(fldID)).OR.(ZDIR.AND.ZCSMDSCHEME(fldID)))) THEN
   IF(CSMACCESSID) THEN
    IF( CSMDSCHEME(fldID)) PRINT*, " CSMDSCHEME("//CHAR(48+fldID)//")"
    IF(XCSMDSCHEME(fldID)) PRINT*, "XCSMDSCHEME("//CHAR(48+fldID)//")"
    IF(YCSMDSCHEME(fldID)) PRINT*, "YCSMDSCHEME("//CHAR(48+fldID)//")"
    IF(ZCSMDSCHEME(fldID)) PRINT*, "ZCSMDSCHEME("//CHAR(48+fldID)//")"
    CSMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(tfx).EQV..FALSE.) ALLOCATE(tfx(fDIM))
   IF(ALLOCATED(Dfx).EQV..FALSE.) ALLOCATE(Dfx(fDIM))
   CALL DCTW(f,tfx)
   tfx=tfx/((MAXVAL(LX1D)-MINVAL(LX1D))/2.0d0)
   !recurrence for the derivative coefficients: 
   Dfx(fDIM)   = 0.0d0
   Dfx(fDIM-1) = 2.0d0*DBLE(fDIM-1)*tfx(fDIM)
   DO ifDIM = fDIM-1, 2, -1
    Dfx(ifDIM-1) = Dfx(ifDIM+1)+2.0d0*DBLE(ifDIM-1)*tfx(ifDIM)
   END DO
   CALL iDCTW(Dfx,rfx)
   rfx=rfx/DBLE(2*fDIM)

  ELSE IF(PSMDSCHEME(fldID).OR.((XDIR.AND.XPSMDSCHEME(fldID)).OR.(YDIR.AND.YPSMDSCHEME(fldID)).OR.(ZDIR.AND.ZPSMDSCHEME(fldID)))) THEN
   IF(PSMACCESSID) THEN
    IF( PSMDSCHEME(fldID)) PRINT*, " PSMDSCHEME("//CHAR(48+fldID)//")"
    IF(XPSMDSCHEME(fldID)) PRINT*, "XPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(YPSMDSCHEME(fldID)) PRINT*, "YPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(ZPSMDSCHEME(fldID)) PRINT*, "ZPSMDSCHEME("//CHAR(48+fldID)//")"
    PSMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIM/2+1))
   IF(ALLOCATED(kfx).EQV..FALSE.)  ALLOCATE(kfx(fDIM/2+1))
   IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIM/2+1))
   CALL KGRIDBUILDER(LX1D,likx)
   CALL FFTW(f,kf)
   CALL Df(kf,likx,kfx,DORDER,fldID,CSPACE)
   CALL iFFTW(kfx,rfx)
  END IF

  XDIR=.FALSE.
  YDIR=.FALSE.
  ZDIR=.FALSE.

  RETURN
 END SUBROUTINE r4r4r4Df1D

 SUBROUTINE r8r4c8Df1DNONE(f,LX1D,kfx,DORDER)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX1D(:)
  REAL(8),    INTENT(IN)           :: f(:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:)
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL Df(f,LX1D,kfx,DORDER,1,"x")

  RETURN
 END SUBROUTINE r8r4c8Df1DNONE

 SUBROUTINE r8r4c8Df1D1INT(f,LX1D,kfx,DORDER,fldID)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX1D(:)
  REAL(8),    INTENT(IN)           :: f(:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:)
  INTEGER(4), INTENT(IN)           :: fldID
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL Df(f,LX1D,kfx,DORDER,fldID,"x")

  RETURN
 END SUBROUTINE r8r4c8Df1D1INT

 SUBROUTINE r8r4c8Df1D1CHR(f,LX1D,kfx,DORDER,CSPACE)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX1D(:)
  REAL(8),    INTENT(IN)           :: f(:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:)
  INTEGER(4), INTENT(IN)           :: DORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE

  CALL Df(f,LX1D,kfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE r8r4c8Df1D1CHR

 SUBROUTINE r8r4c8Df1D(f,LX1D,kfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX1D(:)
  REAL(8),    INTENT(IN)           :: f(:)
  REAL(8),    ALLOCATABLE          :: rfx(:)
  COMPLEX(8), ALLOCATABLE          :: likx(:),kf(:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:)
  INTEGER(4), INTENT(IN)           :: DORDER,fldID
  INTEGER(4)                       :: IORDER
  INTEGER(4)                       :: fDIM
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1
  LOGICAL,    SAVE                 :: PSMACCESSID=.TRUE.
  LOGICAL                          :: XDIR=.FALSE.
  LOGICAL                          :: YDIR=.FALSE.
  LOGICAL                          :: ZDIR=.FALSE.

  fDIM=SIZE(f)

  CSPACE1=CSPACE(1:1)
  IF(CSPACE1.EQ."x".OR.CSPACE1.EQ."X") THEN
   XDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."y".OR.CSPACE1.EQ."Y") THEN
   YDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."z".OR.CSPACE1.EQ."Z") THEN
   ZDIR=.TRUE.
  ELSE
   XDIR=.TRUE.
  END IF

  IF(PSMDSCHEME(fldID).OR.((XDIR.AND.XPSMDSCHEME(fldID)).OR.(YDIR.AND.YPSMDSCHEME(fldID)).OR.(ZDIR.AND.ZPSMDSCHEME(fldID)))) THEN
   IF(PSMACCESSID) THEN
    IF( PSMDSCHEME(fldID)) PRINT*, " PSMDSCHEME("//CHAR(48+fldID)//")"
    IF(XPSMDSCHEME(fldID)) PRINT*, "XPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(YPSMDSCHEME(fldID)) PRINT*, "YPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(ZPSMDSCHEME(fldID)) PRINT*, "ZPSMDSCHEME("//CHAR(48+fldID)//")"
    PSMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIM/2+1))
   IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIM/2+1))
   CALL KGRIDBUILDER(LX1D,likx)
   CALL FFTW(f,kf)
   CALL Df(kf,likx,kfx,DORDER,fldID,CSPACE)

  ELSE
   IF(ALLOCATED(rfx).EQV..FALSE.)   ALLOCATE(rfx(fDIM))
   CALL Df(f,LX1D,rfx,DORDER,fldID,CSPACE)
   CALL FFTW(rfx,kfx)
  END IF

  RETURN
 END SUBROUTINE r8r4c8Df1D

 SUBROUTINE r8r8c8Df1DNONE(f,LX1D,kfx,DORDER)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)           :: LX1D(:)
  REAL(8),    INTENT(IN)           :: f(:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:)
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL Df(f,LX1D,kfx,DORDER,1,"x")

  RETURN
 END SUBROUTINE r8r8c8Df1DNONE

 SUBROUTINE r8r8c8Df1D1INT(f,LX1D,kfx,DORDER,fldID)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)           :: LX1D(:)
  REAL(8),    INTENT(IN)           :: f(:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:)
  INTEGER(4), INTENT(IN)           :: fldID
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL Df(f,LX1D,kfx,DORDER,fldID,"x")

  RETURN
 END SUBROUTINE r8r8c8Df1D1INT

 SUBROUTINE r8r8c8Df1D1CHR(f,LX1D,kfx,DORDER,CSPACE)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)           :: LX1D(:)
  REAL(8),    INTENT(IN)           :: f(:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:)
  INTEGER(4), INTENT(IN)           :: DORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE

  CALL Df(f,LX1D,kfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE r8r8c8Df1D1CHR

 SUBROUTINE r8r8c8Df1D(f,LX1D,kfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)           :: LX1D(:)
  REAL(8),    INTENT(IN)           :: f(:)
  REAL(8),    ALLOCATABLE          :: rfx(:)
  COMPLEX(8), ALLOCATABLE          :: likx(:),kf(:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:)
  INTEGER(4), INTENT(IN)           :: DORDER,fldID
  INTEGER(4)                       :: IORDER
  INTEGER(4)                       :: fDIM
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1
  LOGICAL,    SAVE                 :: PSMACCESSID=.TRUE.
  LOGICAL                          :: XDIR=.FALSE.
  LOGICAL                          :: YDIR=.FALSE.
  LOGICAL                          :: ZDIR=.FALSE.

  fDIM=SIZE(f)

  CSPACE1=CSPACE(1:1)
  IF(CSPACE1.EQ."x".OR.CSPACE1.EQ."X") THEN
   XDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."y".OR.CSPACE1.EQ."Y") THEN
   YDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."z".OR.CSPACE1.EQ."Z") THEN
   ZDIR=.TRUE.
  ELSE
   XDIR=.TRUE.
  END IF

  IF(PSMDSCHEME(fldID).OR.((XDIR.AND.XPSMDSCHEME(fldID)).OR.(YDIR.AND.YPSMDSCHEME(fldID)).OR.(ZDIR.AND.ZPSMDSCHEME(fldID)))) THEN
   IF(PSMACCESSID) THEN
    IF( PSMDSCHEME(fldID)) PRINT*, " PSMDSCHEME("//CHAR(48+fldID)//")"
    IF(XPSMDSCHEME(fldID)) PRINT*, "XPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(YPSMDSCHEME(fldID)) PRINT*, "YPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(ZPSMDSCHEME(fldID)) PRINT*, "ZPSMDSCHEME("//CHAR(48+fldID)//")"
    PSMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIM/2+1))
   IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIM/2+1))
   CALL KGRIDBUILDER(LX1D,likx)
   CALL FFTW(f,kf)
   CALL Df(kf,likx,kfx,DORDER,fldID,CSPACE)
  ELSE
   IF(ALLOCATED(rfx).EQV..FALSE.)   ALLOCATE(rfx(fDIM))
   CALL Df(f,LX1D,rfx,DORDER,fldID,CSPACE)
   CALL FFTW(rfx,kfx)
  END IF

  RETURN
 END SUBROUTINE r8r8c8Df1D

 SUBROUTINE r8r4r8Df1DNONE(f,LX1D,rfx,DORDER)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX1D(:)
  REAL(8),    INTENT(IN)           :: f(:)
  REAL(8),    INTENT(OUT)          :: rfx(:)
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL Df(f,LX1D,rfx,DORDER,1,"x")

  RETURN
 END SUBROUTINE r8r4r8Df1DNONE

 SUBROUTINE r8r4r8Df1D1INT(f,LX1D,rfx,DORDER,fldID)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX1D(:)
  REAL(8),    INTENT(IN)           :: f(:)
  REAL(8),    INTENT(OUT)          :: rfx(:)
  INTEGER(4), INTENT(IN)           :: fldID
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL Df(f,LX1D,rfx,DORDER,fldID,"x")

  RETURN
 END SUBROUTINE r8r4r8Df1D1INT

 SUBROUTINE r8r4r8Df1D1CHR(f,LX1D,rfx,DORDER,CSPACE)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX1D(:)
  REAL(8),    INTENT(IN)           :: f(:)
  REAL(8),    INTENT(OUT)          :: rfx(:)
  INTEGER(4), INTENT(IN)           :: DORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE

  CALL Df(f,LX1D,rfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE r8r4r8Df1D1CHR

 SUBROUTINE r8r4r8Df1D(f,LX1D,rfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX1D(:)
  REAL(8),    INTENT(IN)           :: f(:)
  REAL(8),    INTENT(OUT)          :: rfx(:)
  REAL(4),    ALLOCATABLE          :: Dx(:)
  REAL(8),    ALLOCATABLE          :: Dfx(:)
  REAL(8),    ALLOCATABLE          :: tf(:)
  COMPLEX(8), ALLOCATABLE          :: kf(:),kfx(:)
  COMPLEX(8), ALLOCATABLE          :: iK(:)
  COMPLEX(8), ALLOCATABLE          :: likx(:)
  INTEGER(4)                       :: fDIM,ifDIM
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4)                       :: IORDER
  INTEGER(4), INTENT(IN)           :: fldID
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1
  LOGICAL,    SAVE                 :: FDMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: PSMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: CSMACCESSID=.TRUE.
  LOGICAL                          :: XDIR=.FALSE.
  LOGICAL                          :: YDIR=.FALSE.
  LOGICAL                          :: ZDIR=.FALSE.

  CSPACE1=CSPACE(1:1)
  IF(CSPACE1.EQ."x".OR.CSPACE1.EQ."X") THEN
   XDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."y".OR.CSPACE1.EQ."Y") THEN
   YDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."z".OR.CSPACE1.EQ."Z") THEN
   ZDIR=.TRUE.
  ELSE
   XDIR=.TRUE.
  END IF

  fDIM=SIZE(f)

  IF(FDMDSCHEME(fldID).OR.((XDIR.AND.XFDMDSCHEME(fldID)).OR.(YDIR.AND.YFDMDSCHEME(fldID)).OR.(ZDIR.AND.ZFDMDSCHEME(fldID)))) THEN
   IF(FDMACCESSID) THEN
    IF( FDMDSCHEME(fldID)) PRINT*, " FDMDSCHEME("//CHAR(48+fldID)//")"
    IF(XFDMDSCHEME(fldID)) PRINT*, "XFDMDSCHEME("//CHAR(48+fldID)//")"
    IF(YFDMDSCHEME(fldID)) PRINT*, "YFDMDSCHEME("//CHAR(48+fldID)//")"
    IF(ZFDMDSCHEME(fldID)) PRINT*, "ZFDMDSCHEME("//CHAR(48+fldID)//")"
    FDMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(Dx)) DEALLOCATE(Dx)
   ALLOCATE(Dx(fDIM))
   Dx(1:fDIM-1)=LX1D(2:fDIM)-LX1D(1:fDIM-1)
   Dx(fDIM)=Dx(fDIM-1)
   IF(DORDER.EQ.1) THEN
    IF(FDMORDER.EQ.2) THEN
     rfx(1)=f(2)/(2.0d0*Dx(1))
!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(ifDIM)
!$OMP DO SCHEDULE(DYNAMIC,10)
     DO ifDIM=2,fDIM-1
      rfx(ifDIM)=(f(ifDIM+1)-f(ifDIM-1))/(2.0d0*Dx(ifDIM))
     END DO
!$OMP END DO
!$OMP END PARALLEL
     rfx(fDIM)=-f(fDIM-1)/(2.0d0*Dx(fDIM))
    ELSE IF(FDMORDER.EQ.4) THEN
     rfx(1)=(-f(3)+8.0d0*f(2))/(12.0d0*Dx(1))
     rfx(2)=(-f(4)+8.0d0*f(3)-8.0d0*f(1))/(12.0d0*Dx(2))
!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(ifDIM)
!$OMP DO SCHEDULE(DYNAMIC,10)
     DO ifDIM=3,fDIM-2
      rfx(ifDIM)=(-f(ifDIM+2)+8.0d0*f(ifDIM+1)-8.0d0*f(ifDIM-1)+f(ifDIM-2))/(12.0d0*Dx(ifDIM))
     END DO
!$OMP END DO
!$OMP END PARALLEL
     rfx(fDIM-1)=(8.0d0*f(fDIM)-8.0d0*f(fDIM-2)+f(fDIM-3))/(12.0d0*Dx(fDIM-1))
     rfx(fDIM)=(-8.0d0*f(fDIM-1)+f(fDIM-2))/(12.0d0*Dx(fDIM))
    END IF
   ELSE IF(DORDER.EQ.2) THEN
    IF(FDMORDER.EQ.2) THEN
     rfx(1)=(2.0d0*f(1)-5.0d0*f(2)+4.0*f(3)-f(4))/(Dx(1)**2)
!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(ifDIM)
!$OMP DO SCHEDULE(DYNAMIC,10)
     DO ifDIM=2,fDIM-1
      rfx(ifDIM)=(f(ifDIM+1)-2.0*f(ifDIM)+f(ifDIM-1))/(Dx(ifDIM)**2)
     END DO
!$OMP END DO
!$OMP END PARALLEL
     rfx(fDIM)=(2.0*f(fDIM)-5.0*f(fDIM-1)+4.0*f(fDIM-2)-f(fDIM-3))/(Dx(fDIM)**2)
    ELSE IF(FDMORDER.EQ.4) THEN
     rfx(1)=(2.0*f(1)-5.0*f(2)+4.0*f(3)-f(4))/(Dx(1)**2)
     rfx(2)=(f(3)-2.0*f(2)+f(1))/(Dx(2)**2)
!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(ifDIM)
!$OMP DO SCHEDULE(DYNAMIC,10)
     DO ifDIM=3,fDIM-2
      rfx(ifDIM)=(-f(ifDIM+2)+16.0*f(ifDIM+1)-30.0*f(ifDIM)+16.0*f(ifDIM-1)-f(ifDIM-2))/(12.0*(Dx(ifDIM)**2))
     END DO
!$OMP END DO
!$OMP END PARALLEL
     rfx(fDIM-1)=(f(fDIM)-2.0*f(fDIM-1)+f(fDIM-2))/(Dx(fDIM-1)**2)
     rfx(fDIM)=(2.0*f(fDIM)-5.0*f(fDIM-1)+4.0*f(fDIM-2)-f(fDIM-3))/(Dx(fDIM)**2)
    END IF
   END IF
  ELSE IF(CSMDSCHEME(fldID).OR.((XDIR.AND.XCSMDSCHEME(fldID)).OR.(YDIR.AND.YCSMDSCHEME(fldID)).OR.(ZDIR.AND.ZCSMDSCHEME(fldID)))) THEN
   IF(CSMACCESSID) THEN
    IF( CSMDSCHEME(fldID)) PRINT*, " CSMDSCHEME("//CHAR(48+fldID)//")"
    IF(XCSMDSCHEME(fldID)) PRINT*, "XCSMDSCHEME("//CHAR(48+fldID)//")"
    IF(YCSMDSCHEME(fldID)) PRINT*, "YCSMDSCHEME("//CHAR(48+fldID)//")"
    IF(ZCSMDSCHEME(fldID)) PRINT*, "ZCSMDSCHEME("//CHAR(48+fldID)//")"
    CSMACCESSID=.FALSE.
   END IF
   CALL Df(f,1.0d0*LX1D,rfx,DORDER,fldID,CSPACE)

  ELSE IF(PSMDSCHEME(fldID).OR.((XDIR.AND.XPSMDSCHEME(fldID)).OR.(YDIR.AND.YPSMDSCHEME(fldID)).OR.(ZDIR.AND.ZPSMDSCHEME(fldID)))) THEN
   IF(PSMACCESSID) THEN
    IF( PSMDSCHEME(fldID)) PRINT*, " PSMDSCHEME("//CHAR(48+fldID)//")"
    IF(XPSMDSCHEME(fldID)) PRINT*, "XPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(YPSMDSCHEME(fldID)) PRINT*, "YPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(ZPSMDSCHEME(fldID)) PRINT*, "ZPSMDSCHEME("//CHAR(48+fldID)//")"
    PSMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIM/2+1))
   IF(ALLOCATED(kfx).EQV..FALSE.)  ALLOCATE(kfx(fDIM/2+1))
   IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIM/2+1))
   CALL KGRIDBUILDER(LX1D,likx)
   CALL FFTW(f,kf)
   CALL Df(kf,likx,kfx,DORDER,fldID,CSPACE)
   CALL iFFTW(kfx,rfx)
  END IF

  XDIR=.FALSE.
  YDIR=.FALSE.
  ZDIR=.FALSE.

  RETURN
 END SUBROUTINE r8r4r8Df1D

 SUBROUTINE r8r8r8Df1DNONE(f,LX1D,rfx,DORDER)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)           :: LX1D(:)
  REAL(8),    INTENT(IN)           :: f(:)
  REAL(8),    INTENT(OUT)          :: rfx(:)
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL Df(f,LX1D,rfx,DORDER,1,"x")

  RETURN
 END SUBROUTINE r8r8r8Df1DNONE

 SUBROUTINE r8r8r8Df1D1INT(f,LX1D,rfx,DORDER,fldID)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)           :: LX1D(:)
  REAL(8),    INTENT(IN)           :: f(:)
  REAL(8),    INTENT(OUT)          :: rfx(:)
  INTEGER(4), INTENT(IN)           :: fldID
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL Df(f,LX1D,rfx,DORDER,fldID,"x")

  RETURN
 END SUBROUTINE r8r8r8Df1D1INT

 SUBROUTINE r8r8r8Df1D1CHR(f,LX1D,rfx,DORDER,CSPACE)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)           :: LX1D(:)
  REAL(8),    INTENT(IN)           :: f(:)
  REAL(8),    INTENT(OUT)          :: rfx(:)
  INTEGER(4), INTENT(IN)           :: DORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE

  CALL Df(f,LX1D,rfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE r8r8r8Df1D1CHR

 SUBROUTINE r8r8r8Df1D(f,LX1D,rfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)           :: LX1D(:)
  REAL(8),    INTENT(IN)           :: f(:)
  REAL(8),    INTENT(OUT)          :: rfx(:)
  REAL(8),    ALLOCATABLE          :: Dx(:)
  REAL(8),    ALLOCATABLE          :: Dfx(:)
  REAL(8),    ALLOCATABLE          :: tfx(:)
  REAL(8),    ALLOCATABLE          :: GX1D(:)
  REAL(8)                          :: Xmax,Xmin
  COMPLEX(8), ALLOCATABLE          :: kf(:),kfx(:)
  COMPLEX(8), ALLOCATABLE          :: iK(:)
  COMPLEX(8), ALLOCATABLE          :: likx(:)
  INTEGER(4)                       :: fDIM,ifDIM
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4)                       :: IORDER
  INTEGER(4), INTENT(IN)           :: fldID
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1
  LOGICAL,    SAVE                 :: FDMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: PSMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: CSMACCESSID=.TRUE.
  LOGICAL                          :: XDIR=.FALSE.
  LOGICAL                          :: YDIR=.FALSE.
  LOGICAL                          :: ZDIR=.FALSE.

  CSPACE1=CSPACE(1:1)
  IF(CSPACE1.EQ."x".OR.CSPACE1.EQ."X") THEN
   XDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."y".OR.CSPACE1.EQ."Y") THEN
   YDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."z".OR.CSPACE1.EQ."Z") THEN
   ZDIR=.TRUE.
  ELSE
   XDIR=.TRUE.
  END IF

  fDIM=SIZE(f)

  IF(FDMDSCHEME(fldID).OR.((XDIR.AND.XFDMDSCHEME(fldID)).OR.(YDIR.AND.YFDMDSCHEME(fldID)).OR.(ZDIR.AND.ZFDMDSCHEME(fldID)))) THEN
   IF(FDMACCESSID) THEN
    IF( FDMDSCHEME(fldID)) PRINT*, " FDMDSCHEME("//CHAR(48+fldID)//")"
    IF(XFDMDSCHEME(fldID)) PRINT*, "XFDMDSCHEME("//CHAR(48+fldID)//")"
    IF(YFDMDSCHEME(fldID)) PRINT*, "YFDMDSCHEME("//CHAR(48+fldID)//")"
    IF(ZFDMDSCHEME(fldID)) PRINT*, "ZFDMDSCHEME("//CHAR(48+fldID)//")"
    FDMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(Dx)) DEALLOCATE(Dx)
   ALLOCATE(Dx(fDIM))
   Dx(1:fDIM-1)=LX1D(2:fDIM)-LX1D(1:fDIM-1)
   Dx(fDIM)=Dx(fDIM-1)
   IF(DORDER.EQ.1) THEN
    IF(FDMORDER.EQ.2) THEN
     rfx(1)=f(2)/(2.0d0*Dx(1))
!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(ifDIM)
!$OMP DO SCHEDULE(DYNAMIC,10)
     DO ifDIM=2,fDIM-1
      rfx(ifDIM)=(f(ifDIM+1)-f(ifDIM-1))/(2.0d0*Dx(ifDIM))
     END DO
!$OMP END DO
!$OMP END PARALLEL
     rfx(fDIM)=-f(fDIM-1)/(2.0d0*Dx(fDIM))
    ELSE IF(FDMORDER.EQ.4) THEN
     rfx(1)=(-f(3)+8.0d0*f(2))/(12.0d0*Dx(1))
     rfx(2)=(-f(4)+8.0d0*f(3)-8.0d0*f(1))/(12.0d0*Dx(2))
!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(ifDIM)
!$OMP DO SCHEDULE(DYNAMIC,10)
     DO ifDIM=3,fDIM-2
      rfx(ifDIM)=(-f(ifDIM+2)+8.0d0*f(ifDIM+1)-8.0d0*f(ifDIM-1)+f(ifDIM-2))/(12.0d0*Dx(ifDIM))
     END DO
!$OMP END DO
!$OMP END PARALLEL
     rfx(fDIM-1)=(8.0d0*f(fDIM)-8.0d0*f(fDIM-2)+f(fDIM-3))/(12.0d0*Dx(fDIM-1))
     rfx(fDIM)=(-8.0d0*f(fDIM-1)+f(fDIM-2))/(12.0d0*Dx(fDIM))
    END IF
   ELSE IF(DORDER.EQ.2) THEN
    IF(FDMORDER.EQ.2) THEN
     rfx(1)=(2.0d0*f(1)-5.0d0*f(2)+4.0*f(3)-f(4))/(Dx(1)**2)
!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(ifDIM)
!$OMP DO SCHEDULE(DYNAMIC,10)
     DO ifDIM=2,fDIM-1
      rfx(ifDIM)=(f(ifDIM+1)-2.0*f(ifDIM)+f(ifDIM-1))/(Dx(ifDIM)**2)
     END DO
!$OMP END DO
!$OMP END PARALLEL
     rfx(fDIM)=(2.0*f(fDIM)-5.0*f(fDIM-1)+4.0*f(fDIM-2)-f(fDIM-3))/(Dx(fDIM)**2)
    ELSE IF(FDMORDER.EQ.4) THEN
     rfx(1)=(2.0*f(1)-5.0*f(2)+4.0*f(3)-f(4))/(Dx(1)**2)
     rfx(2)=(f(3)-2.0*f(2)+f(1))/(Dx(2)**2)
!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(ifDIM)
!$OMP DO SCHEDULE(DYNAMIC,10)
     DO ifDIM=3,fDIM-2
      rfx(ifDIM)=(-f(ifDIM+2)+16.0*f(ifDIM+1)-30.0*f(ifDIM)+16.0*f(ifDIM-1)-f(ifDIM-2))/(12.0*(Dx(ifDIM)**2))
     END DO
!$OMP END DO
!$OMP END PARALLEL
     rfx(fDIM-1)=(f(fDIM)-2.0*f(fDIM-1)+f(fDIM-2))/(Dx(fDIM-1)**2)
     rfx(fDIM)=(2.0*f(fDIM)-5.0*f(fDIM-1)+4.0*f(fDIM-2)-f(fDIM-3))/(Dx(fDIM)**2)
    END IF
   END IF
  ELSE IF(CSMDSCHEME(fldID).OR.((XDIR.AND.XCSMDSCHEME(fldID)).OR.(YDIR.AND.YCSMDSCHEME(fldID)).OR.(ZDIR.AND.ZCSMDSCHEME(fldID)))) THEN
   IF(CSMACCESSID) THEN
    IF( CSMDSCHEME(fldID)) PRINT*, " CSMDSCHEME("//CHAR(48+fldID)//")"
    IF(XCSMDSCHEME(fldID)) PRINT*, "XCSMDSCHEME("//CHAR(48+fldID)//")"
    IF(YCSMDSCHEME(fldID)) PRINT*, "YCSMDSCHEME("//CHAR(48+fldID)//")"
    IF(ZCSMDSCHEME(fldID)) PRINT*, "ZCSMDSCHEME("//CHAR(48+fldID)//")"
    CSMACCESSID=.FALSE.
   END IF
   ALLOCATE(GX1D(fDIM))
   DO ifDIM=1,fDIM
    GX1D(ifDIM)=COS((2.0d0*ifDIM-1.0d0)*PI/(2.0d0*fDIM))
   END DO
   Xmax=MAXVAL(LX1D)/ABS(MAXVAL(GX1D))
   Xmin=MINVAL(LX1D)/ABS(MINVAL(GX1D))
   IF(ALLOCATED(tfx).EQV..FALSE.) ALLOCATE(tfx(fDIM))
   IF(ALLOCATED(Dfx).EQV..FALSE.) ALLOCATE(Dfx(fDIM))
   CALL DCTW(f,tfx)
   tfx=tfx/((Xmax-Xmin)/2.0d0)
   !recurrence for the derivative coefficients: 
   Dfx(fDIM)   = 0.0d0
   Dfx(fDIM-1) = 2.0d0*DBLE(fDIM-1)*tfx(fDIM)
   DO ifDIM = fDIM-1, 2, -1
    Dfx(ifDIM-1) = Dfx(ifDIM+1)+2.0d0*DBLE(ifDIM-1)*tfx(ifDIM)
   END DO
   CALL iDCTW(Dfx,rfx)
   rfx=rfx/DBLE(2*fDIM)

  ELSE IF(PSMDSCHEME(fldID).OR.((XDIR.AND.XPSMDSCHEME(fldID)).OR.(YDIR.AND.YPSMDSCHEME(fldID)).OR.(ZDIR.AND.ZPSMDSCHEME(fldID)))) THEN
   IF(PSMACCESSID) THEN
    IF( PSMDSCHEME(fldID)) PRINT*, " PSMDSCHEME("//CHAR(48+fldID)//")"
    IF(XPSMDSCHEME(fldID)) PRINT*, "XPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(YPSMDSCHEME(fldID)) PRINT*, "YPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(ZPSMDSCHEME(fldID)) PRINT*, "ZPSMDSCHEME("//CHAR(48+fldID)//")"
    PSMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIM/2+1))
   IF(ALLOCATED(kfx).EQV..FALSE.)  ALLOCATE(kfx(fDIM/2+1))
   IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIM/2+1))
   CALL KGRIDBUILDER(LX1D,likx)
   CALL FFTW(f,kf)
   CALL Df(kf,likx,kfx,DORDER,fldID,CSPACE)
   CALL iFFTW(kfx,rfx)
  END IF

  XDIR=.FALSE.
  YDIR=.FALSE.
  ZDIR=.FALSE.

  RETURN
 END SUBROUTINE r8r8r8Df1D

 SUBROUTINE c8c8c8Df2DNONE(kf,likx,kfx,DORDER)
  IMPLICIT NONE
  COMPLEX(8), INTENT(IN)  :: likx(:,:)
  COMPLEX(8), INTENT(IN)  :: kf(:,:)
  COMPLEX(8), INTENT(OUT) :: kfx(:,:)
  INTEGER(4), INTENT(IN)  :: DORDER
  INTEGER(4)              :: IORDER

  CALL Df(kf,likx,kfx,DORDER,1,"x")

  RETURN
 END SUBROUTINE c8c8c8Df2DNONE

 SUBROUTINE c8c8c8Df2D1INT(kf,likx,kfx,DORDER,fldID)
  IMPLICIT NONE
  COMPLEX(8), INTENT(IN)  :: likx(:,:)
  COMPLEX(8), INTENT(IN)  :: kf(:,:)
  COMPLEX(8), INTENT(OUT) :: kfx(:,:)
  INTEGER(4), INTENT(IN)  :: DORDER,fldID
  INTEGER(4)              :: IORDER

  CALL Df(kf,likx,kfx,DORDER,fldID,"x")

  RETURN
 END SUBROUTINE c8c8c8Df2D1INT

 SUBROUTINE c8c8c8Df2D1CHR(kf,likx,kfx,DORDER,CSPACE)
  IMPLICIT NONE
  COMPLEX(8), INTENT(IN)       :: likx(:,:)
  COMPLEX(8), INTENT(IN)       :: kf(:,:)
  COMPLEX(8), INTENT(OUT)      :: kfx(:,:)
  INTEGER(4), INTENT(IN)       :: DORDER
  CHARACTER(LEN=*), INTENT(IN) :: CSPACE        ! CURRENT SPACE

  CALL Df(kf,likx,kfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE c8c8c8Df2D1CHR

 SUBROUTINE c8c8c8Df2D(kf,likx,kfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  COMPLEX(8), INTENT(IN)       :: likx(:,:)
  COMPLEX(8), INTENT(IN)       :: kf(:,:)
  COMPLEX(8), INTENT(OUT)      :: kfx(:,:)
  COMPLEX(8), ALLOCATABLE      :: exkfx(:,:)
  COMPLEX(8), ALLOCATABLE      :: exlikx(:,:)
  INTEGER(4), INTENT(IN)       :: DORDER,fldID
  INTEGER(4)                   :: iORDER,iDIM1,iDIM2
  INTEGER(4)                   :: D1MAT13,D2MAT13,MDIMS(2)
  CHARACTER(LEN=*), INTENT(IN) :: CSPACE        ! CURRENT SPACE

  INTEGER(4) :: iD1,iD2

  MDIMS=SHAPE(kf)
  D1MAT13=(MDIMS(1)-1)/3
  D2MAT13=(MDIMS(2)-1)/3

  IF(GONONLINEAR) THEN
   MDIMS=SHAPE(kf)
   IF(ALLOCATED(exkfx).EQV..FALSE.)  ALLOCATE( exkfx(MDIMS(1)+D1MAT13,MDIMS(2)+D2MAT13))
   IF(ALLOCATED(exlikx).EQV..FALSE.) ALLOCATE(exlikx(MDIMS(1)+D1MAT13,MDIMS(2)+D2MAT13))
   CALL addFFTalias(kf,exkfx)
   CALL addFFTalias(likx,exlikx)
   DO iORDER=1,DORDER
!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(iDIM1,iDIM2)
!$OMP DO SCHEDULE(DYNAMIC,10)
    DO iDIM1=1,MDIMS(1)+D1MAT13
     DO iDIM2=1,MDIMS(2)+D2MAT13
      exkfx(iDIM1,iDIM2)=exlikx(iDIM1,iDIM2)*exkfx(iDIM1,iDIM2)
     END DO
    END DO
!$OMP END DO
!$OMP END PARALLEL
   END DO
   CALL rmvFFTalias(exkfx,kfx)
  ELSE
   kfx=kf
   DO iORDER=1,DORDER
!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(iDIM1,iDIM2)
!$OMP DO SCHEDULE(DYNAMIC,10)
    DO iDIM1=1,MDIMS(1)
     DO iDIM2=1,MDIMS(2)
      kfx(iDIM1,iDIM2)=likx(iDIM1,iDIM2)*kfx(iDIM1,iDIM2)
     END DO
    END DO
!$OMP END DO
!$OMP END PARALLEL
   END DO
  END IF

  RETURN
 END SUBROUTINE c8c8c8Df2D

 SUBROUTINE r4r4c8Df2DNONE(f,LX2D,kfx,DORDER)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX2D(:,:)
  REAL(4),    INTENT(IN)           :: f(:,:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:,:)
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL Df(f,LX2D,kfx,DORDER,1,"x")

  RETURN
 END SUBROUTINE r4r4c8Df2DNONE

 SUBROUTINE r4r4c8Df2D1INT(f,LX2D,kfx,DORDER,fldID)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX2D(:,:)
  REAL(4),    INTENT(IN)           :: f(:,:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:,:)
  INTEGER(4), INTENT(IN)           :: fldID
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL Df(f,LX2D,kfx,DORDER,fldID,"x")

  RETURN
 END SUBROUTINE r4r4c8Df2D1INT

 SUBROUTINE r4r4c8Df2D1CHR(f,LX2D,kfx,DORDER,CSPACE)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX2D(:,:)
  REAL(4),    INTENT(IN)           :: f(:,:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:,:)
  INTEGER(4), INTENT(IN)           :: DORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE

  CALL Df(f,LX2D,kfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE r4r4c8Df2D1CHR

 SUBROUTINE r4r4c8Df2D(f,LX2D,kfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX2D(:,:)
  REAL(4),    INTENT(IN)           :: f(:,:)
  REAL(4),    ALLOCATABLE          :: rfx(:,:)
  COMPLEX(8), ALLOCATABLE          :: likx(:,:),kf(:,:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:,:)
  INTEGER(4), INTENT(IN)           :: DORDER,fldID
  INTEGER(4)                       :: IORDER
  INTEGER(4)                       :: fDIMS(2)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1
  LOGICAL,    SAVE                 :: PSMACCESSID=.TRUE.
  LOGICAL                          :: XDIR=.FALSE.
  LOGICAL                          :: YDIR=.FALSE.
  LOGICAL                          :: ZDIR=.FALSE.

  fDIMS=SIZE(f)

  CSPACE1=CSPACE(1:1)
  IF(CSPACE1.EQ."x".OR.CSPACE1.EQ."X") THEN
   XDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."y".OR.CSPACE1.EQ."Y") THEN
   YDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."z".OR.CSPACE1.EQ."Z") THEN
   ZDIR=.TRUE.
  ELSE
   XDIR=.TRUE.
  END IF

  IF(PSMDSCHEME(fldID).OR.((XDIR.AND.XPSMDSCHEME(fldID)).OR.(YDIR.AND.YPSMDSCHEME(fldID)).OR.(ZDIR.AND.ZPSMDSCHEME(fldID)))) THEN
   IF(PSMACCESSID) THEN
    IF( PSMDSCHEME(fldID)) PRINT*, " PSMDSCHEME("//CHAR(48+fldID)//")"
    IF(XPSMDSCHEME(fldID)) PRINT*, "XPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(YPSMDSCHEME(fldID)) PRINT*, "YPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(ZPSMDSCHEME(fldID)) PRINT*, "ZPSMDSCHEME("//CHAR(48+fldID)//")"
    PSMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIMs(1)/2+1,fDIMS(2)))
   IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIMs(1)/2+1,fDIMS(2)))
   CALL KGRIDBUILDER(LX2D,likx)
   CALL FFTW(f,kf)
   CALL Df(kf,likx,kfx,DORDER,fldID,CSPACE)
  ELSE
   IF(ALLOCATED(rfx).EQV..FALSE.)   ALLOCATE(rfx(fDIMs(1),fDIMS(2)))
   CALL Df(f,LX2D,rfx,DORDER,fldID,CSPACE)
   CALL FFTW(rfx,kfx)
  END IF

  RETURN
 END SUBROUTINE r4r4c8Df2D

 SUBROUTINE r4r4r4Df2DNONE(f,LX2D,rfx,DORDER)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX2D(:,:)
  REAL(4),    INTENT(IN)           :: f(:,:)
  REAL(4),    INTENT(OUT)          :: rfx(:,:)
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4)                       :: fDIM(2),DxDIR,ifDIM

  fDIM=SHAPE(f)

  DxDIR=1
  DO ifDIM=1,fDIM(2)
   IF(LX2D(1,ifDIM).NE.LX2D(1,1)) THEN
    DxDIR=2
    EXIT
   END IF
  END DO

  IF(DxDIR.EQ.1) THEN
   CALL Df(f,LX2D,rfx,DORDER,1,"x")
  ELSE IF(DxDIR.EQ.2) THEN
   CALL Df(f,LX2D,rfx,DORDER,1,"y")
  END IF

  RETURN
 END SUBROUTINE r4r4r4Df2DNONE

 SUBROUTINE r4r4r4Df2D1INT(f,LX2D,rfx,DORDER,fldID)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX2D(:,:)
  REAL(4),    INTENT(IN)           :: f(:,:)
  REAL(4),    INTENT(OUT)          :: rfx(:,:)
  INTEGER(4), INTENT(IN)           :: fldID
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4)                       :: fDIM(2),DxDIR,ifDIM

  fDIM=SHAPE(f)

  DxDIR=1
  DO ifDIM=1,fDIM(2)
   IF(LX2D(1,ifDIM).NE.LX2D(1,1)) THEN
    DxDIR=2
    EXIT
   END IF
  END DO

  IF(DxDIR.EQ.1) THEN
   CALL Df(f,LX2D,rfx,DORDER,fldID,"x")
  ELSE IF(DxDIR.EQ.2) THEN
   CALL Df(f,LX2D,rfx,DORDER,fldID,"y")
  END IF

  RETURN
 END SUBROUTINE r4r4r4Df2D1INT

 SUBROUTINE r4r4r4Df2D1CHR(f,LX2D,rfx,DORDER,CSPACE)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX2D(:,:)
  REAL(4),    INTENT(IN)           :: f(:,:)
  REAL(4),    INTENT(OUT)          :: rfx(:,:)
  INTEGER(4), INTENT(IN)           :: DORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE

  CALL Df(f,LX2D,rfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE r4r4r4Df2D1CHR

 SUBROUTINE r4r4r4Df2D(f,LX2D,rfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX2D(:,:)
  REAL(4),    INTENT(IN)           :: f(:,:)
  REAL(4),    INTENT(OUT)          :: rfx(:,:)
  REAL(8),    ALLOCATABLE          :: exf2D(:,:),exrfx2D(:,:)
  REAL(8),    ALLOCATABLE          :: tf(:,:)
  COMPLEX(8), ALLOCATABLE          :: kf(:,:),kfx(:,:)
  COMPLEX(8), ALLOCATABLE          :: iK2D(:,:)
  COMPLEX(8), ALLOCATABLE          :: likx(:,:)
  INTEGER(4)                       :: fDIM(2),DxDIR,ifDIM
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4)                       :: IORDER
  INTEGER(4), INTENT(IN)           :: fldID
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1
  LOGICAL,    SAVE                 :: FDMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: PSMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: CSMACCESSID=.TRUE.
  LOGICAL                          :: XDIR=.FALSE.
  LOGICAL                          :: YDIR=.FALSE.
  LOGICAL                          :: ZDIR=.FALSE.

  fDIM=SHAPE(f)

  DxDIR=1
  IF(LX2D(1,2).NE.LX2D(1,1)) DxDIR=2

  CSPACE1=CSPACE(1:1)
  IF(CSPACE1.EQ."x".OR.CSPACE1.EQ."X") THEN
   XDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."y".OR.CSPACE1.EQ."Y") THEN
   YDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."z".OR.CSPACE1.EQ."Z") THEN
   ZDIR=.TRUE.
  END IF

  IF(PSMDSCHEME(fldID).OR.((XDIR.AND.XPSMDSCHEME(fldID)).OR.(YDIR.AND.YPSMDSCHEME(fldID)).OR.(ZDIR.AND.ZPSMDSCHEME(fldID)))) THEN
   IF(PSMACCESSID) THEN
    IF( PSMDSCHEME(fldID)) PRINT*, " PSMSCHEME("//CHAR(48+fldID)//")"
    IF(XPSMDSCHEME(fldID)) PRINT*, "XPSMSCHEME("//CHAR(48+fldID)//")"
    IF(YPSMDSCHEME(fldID)) PRINT*, "YPSMSCHEME("//CHAR(48+fldID)//")"
    IF(ZPSMDSCHEME(fldID)) PRINT*, "ZPSMSCHEME("//CHAR(48+fldID)//")"
    PSMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(kfx).EQV..FALSE.)  ALLOCATE(kfx(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIM(1)/2+1,fDIM(2)))
   CALL KGRIDBUILDER(LX2D,likx)
   CALL FFTW(f,kf)
   CALL Df(kf,likx,kfx,DORDER,fldID,CSPACE)
   CALL iFFTW(kfx,rfx)
  ELSE
   IF(DxDIR.EQ.1) THEN
    DO ifDIM=1,fDIM(2)
     CALL Df(f(:,ifDIM),LX2D(:,ifDIM),rfx(:,ifDIM),DORDER,fldID,CSPACE1)
    END DO
   ELSE IF(DxDIR.EQ.2) THEN
    DO ifDIM=1,fDIM(1)
     CALL Df(f(ifDIM,:),LX2D(ifDIM,:),rfx(ifDIM,:),DORDER,fldID,CSPACE1)
    END DO
   END IF
  END IF

  RETURN
 END SUBROUTINE r4r4r4Df2D

 SUBROUTINE r8r4c8Df2DNONE(f,LX2D,kfx,DORDER)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX2D(:,:)
  REAL(8),    INTENT(IN)           :: f(:,:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:,:)
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL Df(f,LX2D,kfx,DORDER,1,"x")

  RETURN
 END SUBROUTINE r8r4c8Df2DNONE

 SUBROUTINE r8r4c8Df2D1INT(f,LX2D,kfx,DORDER,fldID)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX2D(:,:)
  REAL(8),    INTENT(IN)           :: f(:,:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:,:)
  INTEGER(4), INTENT(IN)           :: fldID
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL Df(f,LX2D,kfx,DORDER,fldID,"x")

  RETURN
 END SUBROUTINE r8r4c8Df2D1INT

 SUBROUTINE r8r4c8Df2D1CHR(f,LX2D,kfx,DORDER,CSPACE)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX2D(:,:)
  REAL(8),    INTENT(IN)           :: f(:,:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:,:)
  INTEGER(4), INTENT(IN)           :: DORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE

  CALL Df(f,LX2D,kfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE r8r4c8Df2D1CHR

 SUBROUTINE r8r4c8Df2D(f,LX2D,kfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX2D(:,:)
  REAL(8),    INTENT(IN)           :: f(:,:)
  REAL(8),    ALLOCATABLE          :: rfx(:,:)
  COMPLEX(8), ALLOCATABLE          :: likx(:,:),kf(:,:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:,:)
  INTEGER(4), INTENT(IN)           :: DORDER,fldID
  INTEGER(4)                       :: IORDER
  INTEGER(4)                       :: fDIMS(2)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1
  LOGICAL,    SAVE                 :: PSMACCESSID=.TRUE.
  LOGICAL                          :: XDIR=.FALSE.
  LOGICAL                          :: YDIR=.FALSE.
  LOGICAL                          :: ZDIR=.FALSE.

  fDIMS=SIZE(f)

  CSPACE1=CSPACE(1:1)
  IF(CSPACE1.EQ."x".OR.CSPACE1.EQ."X") THEN
   XDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."y".OR.CSPACE1.EQ."Y") THEN
   YDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."z".OR.CSPACE1.EQ."Z") THEN
   ZDIR=.TRUE.
  ELSE
   XDIR=.TRUE.
  END IF

  IF(PSMDSCHEME(fldID).OR.((XDIR.AND.XPSMDSCHEME(fldID)).OR.(YDIR.AND.YPSMDSCHEME(fldID)).OR.(ZDIR.AND.ZPSMDSCHEME(fldID)))) THEN
   IF(PSMACCESSID) THEN
    IF( PSMDSCHEME(fldID)) PRINT*, " PSMDSCHEME("//CHAR(48+fldID)//")"
    IF(XPSMDSCHEME(fldID)) PRINT*, "XPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(YPSMDSCHEME(fldID)) PRINT*, "YPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(ZPSMDSCHEME(fldID)) PRINT*, "ZPSMDSCHEME("//CHAR(48+fldID)//")"
    PSMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(kf))   ALLOCATE(kf(fDIMs(1)/2+1,fDIMS(2)))
   IF(ALLOCATED(likx)) ALLOCATE(likx(fDIMs(1)/2+1,fDIMS(2)))
   CALL KGRIDBUILDER(LX2D,likx)
   CALL FFTW(f,kf)
   CALL Df(kf,likx,kfx,DORDER,fldID,CSPACE)
  ELSE
   IF(ALLOCATED(rfx))   ALLOCATE(rfx(fDIMs(1),fDIMS(2)))
   CALL Df(f,LX2D,rfx,DORDER,fldID,CSPACE)
   CALL FFTW(rfx,kfx)
  END IF

  RETURN
 END SUBROUTINE r8r4c8Df2D

 SUBROUTINE r8r8c8Df2DNONE(f,LX2D,kfx,DORDER)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)           :: LX2D(:,:)
  REAL(8),    INTENT(IN)           :: f(:,:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:,:)
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL Df(f,LX2D,kfx,DORDER,1,"x")

  RETURN
 END SUBROUTINE r8r8c8Df2DNONE

 SUBROUTINE r8r8c8Df2D1INT(f,LX2D,kfx,DORDER,fldID)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)           :: LX2D(:,:)
  REAL(8),    INTENT(IN)           :: f(:,:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:,:)
  INTEGER(4), INTENT(IN)           :: fldID
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL Df(f,LX2D,kfx,DORDER,fldID,"x")

  RETURN
 END SUBROUTINE r8r8c8Df2D1INT

 SUBROUTINE r8r8c8Df2D1CHR(f,LX2D,kfx,DORDER,CSPACE)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)           :: LX2D(:,:)
  REAL(8),    INTENT(IN)           :: f(:,:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:,:)
  INTEGER(4), INTENT(IN)           :: DORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE

  CALL Df(f,LX2D,kfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE r8r8c8Df2D1CHR

 SUBROUTINE r8r8c8Df2D(f,LX2D,kfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)           :: LX2D(:,:)
  REAL(8),    INTENT(IN)           :: f(:,:)
  REAL(8),    ALLOCATABLE          :: rfx(:,:)
  COMPLEX(8), ALLOCATABLE          :: likx(:,:),kf(:,:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:,:)
  INTEGER(4), INTENT(IN)           :: DORDER,fldID
  INTEGER(4)                       :: IORDER
  INTEGER(4)                       :: fDIMS(2)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1
  LOGICAL,    SAVE                 :: PSMACCESSID=.TRUE.
  LOGICAL                          :: XDIR=.FALSE.
  LOGICAL                          :: YDIR=.FALSE.
  LOGICAL                          :: ZDIR=.FALSE.

  fDIMS=SIZE(f)

  CSPACE1=CSPACE(1:1)
  IF(CSPACE1.EQ."x".OR.CSPACE1.EQ."X") THEN
   XDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."y".OR.CSPACE1.EQ."Y") THEN
   YDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."z".OR.CSPACE1.EQ."Z") THEN
   ZDIR=.TRUE.
  ELSE
   XDIR=.TRUE.
  END IF

  IF(PSMDSCHEME(fldID).OR.((XDIR.AND.XPSMDSCHEME(fldID)).OR.(YDIR.AND.YPSMDSCHEME(fldID)).OR.(ZDIR.AND.ZPSMDSCHEME(fldID)))) THEN
   IF(PSMACCESSID) THEN
    IF( PSMDSCHEME(fldID)) PRINT*, " PSMDSCHEME("//CHAR(48+fldID)//")"
    IF(XPSMDSCHEME(fldID)) PRINT*, "XPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(YPSMDSCHEME(fldID)) PRINT*, "YPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(ZPSMDSCHEME(fldID)) PRINT*, "ZPSMDSCHEME("//CHAR(48+fldID)//")"
    PSMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(kf))   ALLOCATE(kf(fDIMs(1)/2+1,fDIMS(2)))
   IF(ALLOCATED(likx)) ALLOCATE(likx(fDIMs(1)/2+1,fDIMS(2)))
   CALL KGRIDBUILDER(LX2D,likx)
   CALL FFTW(f,kf)
   CALL Df(kf,likx,kfx,DORDER,fldID,CSPACE)
  ELSE
   IF(ALLOCATED(rfx))   ALLOCATE(rfx(fDIMs(1),fDIMS(2)))
   CALL Df(f,LX2D,rfx,DORDER,fldID,CSPACE)
   CALL FFTW(rfx,kfx)
  END IF

  RETURN
 END SUBROUTINE r8r8c8Df2D

 SUBROUTINE r8r4r8Df2DNONE(f,LX2D,rfx,DORDER)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX2D(:,:)
  REAL(8),    INTENT(IN)           :: f(:,:)
  REAL(8),    INTENT(OUT)          :: rfx(:,:)
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4)                       :: fDIM(2),DxDIR,ifDIM

  fDIM=SHAPE(f)

  DxDIR=1
  DO ifDIM=1,fDIM(2)
   IF(LX2D(1,ifDIM).NE.LX2D(1,1)) THEN
    DxDIR=2
    EXIT
   END IF
  END DO

  IF(DxDIR.EQ.1) THEN
   CALL Df(f,LX2D,rfx,DORDER,1,"x")
  ELSE IF(DxDIR.EQ.2) THEN
   CALL Df(f,LX2D,rfx,DORDER,1,"y")
  END IF

  RETURN
 END SUBROUTINE r8r4r8Df2DNONE

 SUBROUTINE r8r4r8Df2D1INT(f,LX2D,rfx,DORDER,fldID)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX2D(:,:)
  REAL(8),    INTENT(IN)           :: f(:,:)
  REAL(8),    INTENT(OUT)          :: rfx(:,:)
  INTEGER(4), INTENT(IN)           :: fldID
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4)                       :: fDIM(2),DxDIR,ifDIM

  fDIM=SHAPE(f)

  DxDIR=1
  DO ifDIM=1,fDIM(2)
   IF(LX2D(1,ifDIM).NE.LX2D(1,1)) THEN
    DxDIR=2
    EXIT
   END IF
  END DO

  IF(DxDIR.EQ.1) THEN
   CALL Df(f,LX2D,rfx,DORDER,fldID,"x")
  ELSE IF(DxDIR.EQ.2) THEN
   CALL Df(f,LX2D,rfx,DORDER,fldID,"y")
  END IF

  RETURN
 END SUBROUTINE r8r4r8Df2D1INT

 SUBROUTINE r8r4r8Df2D1CHR(f,LX2D,rfx,DORDER,CSPACE)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX2D(:,:)
  REAL(8),    INTENT(IN)           :: f(:,:)
  REAL(8),    INTENT(OUT)          :: rfx(:,:)
  INTEGER(4), INTENT(IN)           :: DORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE

  CALL Df(f,LX2D,rfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE r8r4r8Df2D1CHR

 SUBROUTINE r8r4r8Df2D(f,LX2D,rfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:)
  REAL(8), INTENT(OUT)             :: rfx(:,:)
  REAL(8),    ALLOCATABLE          :: exf2D(:,:),exrfx2D(:,:)
  REAL(8),    ALLOCATABLE          :: tf(:,:)
  COMPLEX(8), ALLOCATABLE          :: kf(:,:),kfx(:,:)
  COMPLEX(8), ALLOCATABLE          :: iK2D(:,:)
  COMPLEX(8), ALLOCATABLE          :: likx(:,:)
  INTEGER(4)                       :: fDIM(2),DxDIR,ifDIM
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4)                       :: IORDER
  INTEGER(4), INTENT(IN)           :: fldID
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1
  LOGICAL,    SAVE                 :: FDMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: PSMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: CSMACCESSID=.TRUE.
  LOGICAL                          :: XDIR=.FALSE.
  LOGICAL                          :: YDIR=.FALSE.
  LOGICAL                          :: ZDIR=.FALSE.

  fDIM=SHAPE(f)

  DxDIR=1
  DO ifDIM=1,fDIM(2)
   IF(LX2D(1,ifDIM).NE.LX2D(1,1)) THEN
    DxDIR=2
    EXIT
   END IF
  END DO

  CSPACE1=CSPACE(1:1)
  IF(CSPACE1.EQ."x".OR.CSPACE1.EQ."X") THEN
   XDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."y".OR.CSPACE1.EQ."Y") THEN
   YDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."z".OR.CSPACE1.EQ."Z") THEN
   ZDIR=.TRUE.
  END IF

  IF(PSMDSCHEME(fldID).OR.((XDIR.AND.XPSMDSCHEME(fldID)).OR.(YDIR.AND.YPSMDSCHEME(fldID)).OR.(ZDIR.AND.ZPSMDSCHEME(fldID)))) THEN
   IF(PSMACCESSID) THEN
    IF( PSMDSCHEME(fldID)) PRINT*, " PSMDSCHEME("//CHAR(48+fldID)//")"
    IF(XPSMDSCHEME(fldID)) PRINT*, "XPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(YPSMDSCHEME(fldID)) PRINT*, "YPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(ZPSMDSCHEME(fldID)) PRINT*, "ZPSMDSCHEME("//CHAR(48+fldID)//")"
    PSMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(kfx).EQV..FALSE.)  ALLOCATE(kfx(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIM(1)/2+1,fDIM(2)))
   CALL KGRIDBUILDER(LX2D,likx)
   CALL FFTW(f,kf)
   CALL Df(kf,likx,kfx,DORDER,fldID,CSPACE)
   CALL iFFTW(kfx,rfx)

  ELSE
   IF(DxDIR.EQ.1) THEN
    DO ifDIM=1,fDIM(2)
     CALL Df(f(:,ifDIM),LX2D(:,ifDIM),rfx(:,ifDIM),DORDER,fldID,CSPACE1)
    END DO
   ELSE IF(DxDIR.EQ.2) THEN
    DO ifDIM=1,fDIM(1)
     CALL Df(f(ifDIM,:),LX2D(ifDIM,:),rfx(ifDIM,:),DORDER,fldID,CSPACE1)
    END DO
   END IF
  END IF

  RETURN
 END SUBROUTINE r8r4r8Df2D

 SUBROUTINE r8r8r8Df2DNONE(f,LX2D,rfx,DORDER)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)           :: LX2D(:,:)
  REAL(8),    INTENT(IN)           :: f(:,:)
  REAL(8),    INTENT(OUT)          :: rfx(:,:)
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4)                       :: fDIM(2),DxDIR,ifDIM

  fDIM=SHAPE(f)

  DxDIR=1
  DO ifDIM=1,fDIM(2)
   IF(LX2D(1,ifDIM).NE.LX2D(1,1)) THEN
    DxDIR=2
    EXIT
   END IF
  END DO

  IF(DxDIR.EQ.1) THEN
   CALL Df(f,LX2D,rfx,DORDER,1,"x")
  ELSE IF(DxDIR.EQ.2) THEN
   CALL Df(f,LX2D,rfx,DORDER,1,"y")
  END IF

  RETURN
 END SUBROUTINE r8r8r8Df2DNONE

 SUBROUTINE r8r8r8Df2D1INT(f,LX2D,rfx,DORDER,fldID)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)           :: LX2D(:,:)
  REAL(8),    INTENT(IN)           :: f(:,:)
  REAL(8),    INTENT(OUT)          :: rfx(:,:)
  INTEGER(4), INTENT(IN)           :: fldID
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4)                       :: fDIM(2),DxDIR,ifDIM

  fDIM=SHAPE(f)

  DxDIR=1
  DO ifDIM=1,fDIM(2)
   IF(LX2D(1,ifDIM).NE.LX2D(1,1)) THEN
    DxDIR=2
    EXIT
   END IF
  END DO

  IF(DxDIR.EQ.1) THEN
   CALL Df(f,LX2D,rfx,DORDER,fldID,"x")
  ELSE IF(DxDIR.EQ.2) THEN
   CALL Df(f,LX2D,rfx,DORDER,fldID,"y")
  END IF

  RETURN
 END SUBROUTINE r8r8r8Df2D1INT

 SUBROUTINE r8r8r8Df2D1CHR(f,LX2D,rfx,DORDER,CSPACE)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)           :: LX2D(:,:)
  REAL(8),    INTENT(IN)           :: f(:,:)
  REAL(8),    INTENT(OUT)          :: rfx(:,:)
  INTEGER(4), INTENT(IN)           :: DORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE

  CALL Df(f,LX2D,rfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE r8r8r8Df2D1CHR

 SUBROUTINE r8r8r8Df2D(f,LX2D,rfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:)
  REAL(8), INTENT(OUT)             :: rfx(:,:)
  REAL(8),    ALLOCATABLE          :: exf2D(:,:),exrfx2D(:,:)
  REAL(8),    ALLOCATABLE          :: tf(:,:)
  COMPLEX(8), ALLOCATABLE          :: kf(:,:),kfx(:,:)
  COMPLEX(8), ALLOCATABLE          :: iK2D(:,:)
  COMPLEX(8), ALLOCATABLE          :: likx(:,:)
  INTEGER(4)                       :: fDIM(2),DxDIR,ifDIM
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4)                       :: IORDER
  INTEGER(4), INTENT(IN)           :: fldID
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1
  LOGICAL,    SAVE                 :: FDMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: PSMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: CSMACCESSID=.TRUE.
  LOGICAL                          :: XDIR=.FALSE.
  LOGICAL                          :: YDIR=.FALSE.
  LOGICAL                          :: ZDIR=.FALSE.

  fDIM=SHAPE(f)

  DxDIR=1
  DO ifDIM=1,fDIM(2)
   IF(LX2D(1,ifDIM).NE.LX2D(1,1)) THEN
    DxDIR=2
    EXIT
   END IF
  END DO

  CSPACE1=CSPACE(1:1)
  IF(CSPACE1.EQ."x".OR.CSPACE1.EQ."X") THEN
   XDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."y".OR.CSPACE1.EQ."Y") THEN
   YDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."z".OR.CSPACE1.EQ."Z") THEN
   ZDIR=.TRUE.
  END IF

  IF(PSMDSCHEME(fldID).OR.((XDIR.AND.XPSMDSCHEME(fldID)).OR.(YDIR.AND.YPSMDSCHEME(fldID)).OR.(ZDIR.AND.ZPSMDSCHEME(fldID)))) THEN
   IF(PSMACCESSID) THEN
    IF( PSMDSCHEME(fldID)) PRINT*, " PSMDSCHEME("//CHAR(48+fldID)//")"
    IF(XPSMDSCHEME(fldID)) PRINT*, "XPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(YPSMDSCHEME(fldID)) PRINT*, "YPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(ZPSMDSCHEME(fldID)) PRINT*, "ZPSMDSCHEME("//CHAR(48+fldID)//")"
    PSMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(kfx).EQV..FALSE.)  ALLOCATE(kfx(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIM(1)/2+1,fDIM(2)))
   CALL KGRIDBUILDER(LX2D,likx)
   CALL FFTW(f,kf)
   CALL Df(kf,likx,kfx,DORDER,fldID,CSPACE)
   CALL iFFTW(kfx,rfx)

  ELSE
   IF(DxDIR.EQ.1) THEN
    DO ifDIM=1,fDIM(2)
     CALL Df(f(:,ifDIM),LX2D(:,ifDIM),rfx(:,ifDIM),DORDER,fldID,CSPACE1)
    END DO
   ELSE IF(DxDIR.EQ.2) THEN
    DO ifDIM=1,fDIM(1)
     CALL Df(f(ifDIM,:),LX2D(ifDIM,:),rfx(ifDIM,:),DORDER,fldID,CSPACE1)
    END DO
   END IF
  END IF

  RETURN
 END SUBROUTINE r8r8r8Df2D

 SUBROUTINE c8c8c8Df3DNONE(kf,likx,kfx,DORDER)
  IMPLICIT NONE
  COMPLEX(8), INTENT(IN)  :: likx(:,:,:)
  COMPLEX(8), INTENT(IN)  :: kf(:,:,:)
  COMPLEX(8), INTENT(OUT) :: kfx(:,:,:)
  INTEGER(4), INTENT(IN)  :: DORDER
  INTEGER(4)              :: IORDER
  
  CALL Df(kf,likx,kfx,DORDER,1,"x")
  
  RETURN
 END SUBROUTINE c8c8c8Df3DNONE
  
 SUBROUTINE c8c8c8Df3D1INT(kf,likx,kfx,DORDER,fldID)
  IMPLICIT NONE
  COMPLEX(8), INTENT(IN)  :: likx(:,:,:)
  COMPLEX(8), INTENT(IN)  :: kf(:,:,:)
  COMPLEX(8), INTENT(OUT) :: kfx(:,:,:)
  INTEGER(4), INTENT(IN)  :: DORDER,fldID
  INTEGER(4)              :: IORDER

  CALL Df(kf,likx,kfx,DORDER,fldID,"x")
  
  RETURN
 END SUBROUTINE c8c8c8Df3D1INT
  
 SUBROUTINE c8c8c8Df3D1CHR(kf,likx,kfx,DORDER,CSPACE)
  IMPLICIT NONE
  COMPLEX(8), INTENT(IN)       :: likx(:,:,:)
  COMPLEX(8), INTENT(IN)       :: kf(:,:,:)
  COMPLEX(8), INTENT(OUT)      :: kfx(:,:,:)
  INTEGER(4), INTENT(IN)       :: DORDER
  CHARACTER(LEN=*), INTENT(IN) :: CSPACE        ! CURRENT SPACE

  CALL Df(kf,likx,kfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE c8c8c8Df3D1CHR

 SUBROUTINE c8c8c8Df3D(kf,likx,kfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  COMPLEX(8), INTENT(IN)       :: likx(:,:,:)
  COMPLEX(8), INTENT(IN)       :: kf(:,:,:)
  COMPLEX(8), INTENT(OUT)      :: kfx(:,:,:)
  COMPLEX(8), ALLOCATABLE      :: exkfx(:,:,:)
  COMPLEX(8), ALLOCATABLE      :: exlikx(:,:,:)
  INTEGER(4), INTENT(IN)       :: DORDER,fldID
  INTEGER(4)                   :: iORDER,iDIM1,iDIM2,iDIM3
  INTEGER(4)                   :: D1MAT13,D2MAT13,D3MAT13,MDIMS(3)
  CHARACTER(LEN=*), INTENT(IN) :: CSPACE        ! CURRENT SPACE

  MDIMS=SHAPE(kf)
  D1MAT13=(MDIMS(1)-1)/3
  D2MAT13=(MDIMS(2)-1)/3
  D3MAT13=(MDIMS(3)-1)/3

  IF(GONONLINEAR) THEN
   MDIMS=SHAPE(kf)
   IF(ALLOCATED(exkfx).EQV..FALSE.)  ALLOCATE( exkfx(MDIMS(1)+D1MAT13,MDIMS(2)+D2MAT13,MDIMS(3)+D3MAT13))
   IF(ALLOCATED(exlikx).EQV..FALSE.) ALLOCATE(exlikx(MDIMS(1)+D1MAT13,MDIMS(2)+D2MAT13,MDIMS(3)+D3MAT13))
   CALL addFFTalias(kf,exkfx)
   CALL addFFTalias(likx,exlikx)
   DO iORDER=1,DORDER
!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(iDIM1,iDIM2,iDIM3)
!$OMP DO SCHEDULE(DYNAMIC,10)
    DO iDIM1=1,MDIMS(1)+D1MAT13
     DO iDIM2=1,MDIMS(2)+D2MAT13
      DO iDIM3=1,MDIMS(3)+D3MAT13
       exkfx(iDIM1,iDIM2,iDIM3)=exlikx(iDIM1,iDIM2,iDIM3)*exkfx(iDIM1,iDIM2,iDIM3)
      END DO
     END DO
    END DO
!$OMP END DO
!$OMP END PARALLEL
   END DO
   CALL rmvFFTalias(exkfx,kfx)
  ELSE
   kfx=kf
   DO iORDER=1,DORDER
!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(iDIM1,iDIM2,iDIM3)
!$OMP DO SCHEDULE(DYNAMIC,10)
    DO iDIM1=1,MDIMS(1)
     DO iDIM2=1,MDIMS(2)
      DO iDIM3=1,MDIMS(3)
       kfx(iDIM1,iDIM2,iDIM3)=likx(iDIM1,iDIM2,iDIM3)*kfx(iDIM1,iDIM2,iDIM3)
      END DO
     END DO
    END DO
!$OMP END DO
!$OMP END PARALLEL
   END DO
  END IF

  RETURN
 END SUBROUTINE c8c8c8Df3D

 SUBROUTINE r4r4c8Df3DNONE(f,LX3D,kfx,DORDER)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX3D(:,:,:)
  REAL(4),    INTENT(IN)           :: f(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:,:,:)
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL Df(f,LX3D,kfx,DORDER,1,"x")

  RETURN
 END SUBROUTINE r4r4c8Df3DNONE

 SUBROUTINE r4r4c8Df3D1INT(f,LX3D,kfx,DORDER,fldID)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX3D(:,:,:)
  REAL(4),    INTENT(IN)           :: f(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:,:,:)
  INTEGER(4), INTENT(IN)           :: fldID
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL Df(f,LX3D,kfx,DORDER,fldID,"x")

  RETURN
 END SUBROUTINE r4r4c8Df3D1INT

 SUBROUTINE r4r4c8Df3D1CHR(f,LX3D,kfx,DORDER,CSPACE)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX3D(:,:,:)
  REAL(4),    INTENT(IN)           :: f(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:,:,:)
  INTEGER(4), INTENT(IN)           :: DORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE

  CALL Df(f,LX3D,kfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE r4r4c8Df3D1CHR

 SUBROUTINE r4r4c8Df3D(f,LX3D,kfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX3D(:,:,:)
  REAL(4),    INTENT(IN)           :: f(:,:,:)
  REAL(4),    ALLOCATABLE          :: rfx(:,:,:)
  COMPLEX(8), ALLOCATABLE          :: likx(:,:,:),kf(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:,:,:)
  INTEGER(4), INTENT(IN)           :: DORDER,fldID
  INTEGER(4)                       :: IORDER
  INTEGER(4)                       :: fDIMS(3)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1
  LOGICAL,    SAVE                 :: PSMACCESSID=.TRUE.
  LOGICAL                          :: XDIR=.FALSE.
  LOGICAL                          :: YDIR=.FALSE.
  LOGICAL                          :: ZDIR=.FALSE.

  fDIMS=SIZE(f)

  CSPACE1=CSPACE(1:1)
  IF(CSPACE1.EQ."x".OR.CSPACE1.EQ."X") THEN
   XDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."y".OR.CSPACE1.EQ."Y") THEN
   YDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."z".OR.CSPACE1.EQ."Z") THEN
   ZDIR=.TRUE.
  ELSE
   XDIR=.TRUE.
  END IF

  IF(PSMDSCHEME(fldID).OR.((XDIR.AND.XPSMDSCHEME(fldID)).OR.(YDIR.AND.YPSMDSCHEME(fldID)).OR.(ZDIR.AND.ZPSMDSCHEME(fldID)))) THEN
   IF(PSMACCESSID) THEN
    IF( PSMDSCHEME(fldID)) PRINT*, " PSMDSCHEME("//CHAR(48+fldID)//")"
    IF(XPSMDSCHEME(fldID)) PRINT*, "XPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(YPSMDSCHEME(fldID)) PRINT*, "YPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(ZPSMDSCHEME(fldID)) PRINT*, "ZPSMDSCHEME("//CHAR(48+fldID)//")"
    PSMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
   IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
   CALL KGRIDBUILDER(LX3D,likx)
   CALL FFTW(f,kf)
   CALL Df(kf,likx,kfx,DORDER,fldID,CSPACE)
  ELSE
   IF(ALLOCATED(rfx).EQV..FALSE.)   ALLOCATE(rfx(fDIMS(1),fDIMS(2),fDIMS(3)))
   CALL Df(f,LX3D,rfx,DORDER,fldID,CSPACE)
   CALL FFTW(rfx,kfx)
  END IF

  RETURN
 END SUBROUTINE r4r4c8Df3D

 SUBROUTINE r4r4r4Df3DNONE(f,LX3D,rfx,DORDER)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX3D(:,:,:)
  REAL(4),    INTENT(IN)           :: f(:,:,:)
  REAL(4),    INTENT(OUT)          :: rfx(:,:,:)
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4)                       :: fDIM(3),DxDIR,ifDIM2,ifDIM3

  fDIM=SHAPE(f)

  DxDIR=1
  DO ifDIM2=1,fDIM(2)
   IF(LX3D(1,ifDIM2,1).NE.LX3D(1,1,1)) THEN
    DxDIR=2
    EXIT
   END IF
  END DO
  DO ifDIM3=1,fDIM(3)
   IF(LX3D(1,1,ifDIM3).NE.LX3D(1,1,1)) THEN
    DxDIR=3
    EXIT
   END IF
  END DO

  IF(DxDIR.EQ.1) THEN
   CALL Df(f,LX3D,rfx,DORDER,1,"x")
  ELSE IF(DxDIR.EQ.2) THEN
   CALL Df(f,LX3D,rfx,DORDER,1,"y")
  ELSE IF(DxDIR.EQ.3) THEN
   CALL Df(f,LX3D,rfx,DORDER,1,"z")
  END IF

  RETURN
 END SUBROUTINE r4r4r4Df3DNONE

 SUBROUTINE r4r4r4Df3D1INT(f,LX3D,rfx,DORDER,fldID)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX3D(:,:,:)
  REAL(4),    INTENT(IN)           :: f(:,:,:)
  REAL(4),    INTENT(OUT)          :: rfx(:,:,:)
  INTEGER(4), INTENT(IN)           :: fldID
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4)                       :: fDIM(3),DxDIR,ifDIM2,ifDIM3

  fDIM=SHAPE(f)

  DxDIR=1
  DO ifDIM2=1,fDIM(2)
   IF(LX3D(1,ifDIM2,1).NE.LX3D(1,1,1)) THEN
    DxDIR=2
    EXIT
   END IF
  END DO
  DO ifDIM3=1,fDIM(3)
   IF(LX3D(1,1,ifDIM3).NE.LX3D(1,1,1)) THEN
    DxDIR=3
    EXIT
   END IF
  END DO

  IF(DxDIR.EQ.1) THEN
   CALL Df(f,LX3D,rfx,DORDER,fldID,"x")
  ELSE IF(DxDIR.EQ.2) THEN
   CALL Df(f,LX3D,rfx,DORDER,fldID,"y")
  ELSE IF(DxDIR.EQ.3) THEN
   CALL Df(f,LX3D,rfx,DORDER,fldID,"z")
  END IF

  RETURN
 END SUBROUTINE r4r4r4Df3D1INT

 SUBROUTINE r4r4r4Df3D1CHR(f,LX3D,rfx,DORDER,CSPACE)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX3D(:,:,:)
  REAL(4),    INTENT(IN)           :: f(:,:,:)
  REAL(4),    INTENT(OUT)          :: rfx(:,:,:)
  INTEGER(4), INTENT(IN)           :: DORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE

  CALL Df(f,LX3D,rfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE r4r4r4Df3D1CHR

 SUBROUTINE r4r4r4Df3D(f,LX3D,rfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:)
  REAL(4), INTENT(IN)              :: f(:,:,:)
  REAL(4), INTENT(OUT)             :: rfx(:,:,:)
  REAL(8),    ALLOCATABLE          :: tf(:,:,:)
  COMPLEX(8), ALLOCATABLE          :: kf(:,:,:),kfx(:,:,:)
  COMPLEX(8), ALLOCATABLE          :: likx(:,:,:)
  INTEGER(4)                       :: fDIM(3),DxDIR,ifDIM1,ifDIM2,ifDIM3
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4)                       :: IORDER
  INTEGER(4), INTENT(IN)           :: fldID
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1
  LOGICAL,    SAVE                 :: FDMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: PSMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: CSMACCESSID=.TRUE.
  LOGICAL                          :: XDIR=.FALSE.
  LOGICAL                          :: YDIR=.FALSE.
  LOGICAL                          :: ZDIR=.FALSE.

  fDIM=SHAPE(f)

  DxDIR=1
  DO ifDIM2=1,fDIM(2)
   IF(LX3D(1,ifDIM2,1).NE.LX3D(1,1,1)) THEN
    DxDIR=2
    EXIT
   END IF
  END DO
  DO ifDIM3=1,fDIM(3)
   IF(LX3D(1,1,ifDIM3).NE.LX3D(1,1,1)) THEN
    DxDIR=3
    EXIT
   END IF
  END DO

  CSPACE1=CSPACE(1:1)
  IF(CSPACE1.EQ."x".OR.CSPACE1.EQ."X") THEN
   XDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."y".OR.CSPACE1.EQ."Y") THEN
   YDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."z".OR.CSPACE1.EQ."Z") THEN
   ZDIR=.TRUE.
  END IF

  IF(PSMDSCHEME(fldID).OR.((XDIR.AND.XPSMDSCHEME(fldID)).OR.(YDIR.AND.YPSMDSCHEME(fldID)).OR.(ZDIR.AND.ZPSMDSCHEME(fldID)))) THEN
   IF(PSMACCESSID) THEN
    IF( PSMDSCHEME(fldID)) PRINT*, " PSMDSCHEME("//CHAR(48+fldID)//")"
    IF(XPSMDSCHEME(fldID)) PRINT*, "XPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(YPSMDSCHEME(fldID)) PRINT*, "YPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(ZPSMDSCHEME(fldID)) PRINT*, "ZPSMDSCHEME("//CHAR(48+fldID)//")"
    PSMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(kfx).EQV..FALSE.)  ALLOCATE(kfx(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   CALL KGRIDBUILDER(LX3D,likx)
   CALL FFTW(f,kf)
   CALL Df(kf,likx,kfx,DORDER,fldID,CSPACE)
   CALL iFFTW(kfx,rfx)

  ELSE
   IF(DxDIR.EQ.1) THEN
    DO ifDIM2=1,fDIM(2)
     DO ifDIM3=1,fDIM(3)
      CALL Df(f(:,ifDIM2,ifDIM3),LX3D(:,ifDIM2,ifDIM3),rfx(:,ifDIM2,ifDIM3),DORDER,fldID,CSPACE1)
     END DO
    END DO
   ELSE IF(DxDIR.EQ.2) THEN
    DO ifDIM1=1,fDIM(1)
     DO ifDIM3=1,fDIM(3)
      CALL Df(f(ifDIM1,:,ifDIM3),LX3D(ifDIM1,:,ifDIM3),rfx(ifDIM1,:,ifDIM3),DORDER,fldID,CSPACE1)
     END DO
    END DO
   ELSE IF(DxDIR.EQ.3) THEN
    DO ifDIM1=1,fDIM(1)
     DO ifDIM2=1,fDIM(2)
      CALL Df(f(ifDIM1,ifDIM2,:),LX3D(ifDIM1,ifDIM2,:),rfx(ifDIM1,ifDIM2,:),DORDER,fldID,CSPACE1)
     END DO
    END DO
   END IF
  END IF

  RETURN
 END SUBROUTINE r4r4r4Df3D

 SUBROUTINE r8r4c8Df3DNONE(f,LX3D,kfx,DORDER)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX3D(:,:,:)
  REAL(8),    INTENT(IN)           :: f(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:,:,:)
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL Df(f,LX3D,kfx,DORDER,1,"x")

  RETURN
 END SUBROUTINE r8r4c8Df3DNONE

 SUBROUTINE r8r4c8Df3D1INT(f,LX3D,kfx,DORDER,fldID)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX3D(:,:,:)
  REAL(8),    INTENT(IN)           :: f(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:,:,:)
  INTEGER(4), INTENT(IN)           :: fldID
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL Df(f,LX3D,kfx,DORDER,fldID,"x")

  RETURN
 END SUBROUTINE r8r4c8Df3D1INT

 SUBROUTINE r8r4c8Df3D1CHR(f,LX3D,kfx,DORDER,CSPACE)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX3D(:,:,:)
  REAL(8),    INTENT(IN)           :: f(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:,:,:)
  INTEGER(4), INTENT(IN)           :: DORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE

  CALL Df(f,LX3D,kfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE r8r4c8Df3D1CHR

 SUBROUTINE r8r4c8Df3D(f,LX3D,kfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX3D(:,:,:)
  REAL(8),    INTENT(IN)           :: f(:,:,:)
  REAL(8),    ALLOCATABLE          :: rfx(:,:,:)
  COMPLEX(8), ALLOCATABLE          :: likx(:,:,:),kf(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:,:,:)
  INTEGER(4), INTENT(IN)           :: DORDER,fldID
  INTEGER(4)                       :: IORDER
  INTEGER(4)                       :: fDIMS(3)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1
  LOGICAL,    SAVE                 :: PSMACCESSID=.TRUE.
  LOGICAL                          :: XDIR=.FALSE.
  LOGICAL                          :: YDIR=.FALSE.
  LOGICAL                          :: ZDIR=.FALSE.
 
  fDIMS=SIZE(f)

  CSPACE1=CSPACE(1:1)
  IF(CSPACE1.EQ."x".OR.CSPACE1.EQ."X") THEN
   XDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."y".OR.CSPACE1.EQ."Y") THEN
   YDIR=.TRUE.                     
  ELSE IF(CSPACE1.EQ."z".OR.CSPACE1.EQ."Z") THEN
   ZDIR=.TRUE.
  ELSE
   XDIR=.TRUE.
  END IF

  IF(PSMDSCHEME(fldID).OR.((XDIR.AND.XPSMDSCHEME(fldID)).OR.(YDIR.AND.YPSMDSCHEME(fldID)).OR.(ZDIR.AND.ZPSMDSCHEME(fldID)))) THEN
   IF(PSMACCESSID) THEN
    IF( PSMDSCHEME(fldID)) PRINT*, " PSMDSCHEME("//CHAR(48+fldID)//")"
    IF(XPSMDSCHEME(fldID)) PRINT*, "XPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(YPSMDSCHEME(fldID)) PRINT*, "YPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(ZPSMDSCHEME(fldID)) PRINT*, "ZPSMDSCHEME("//CHAR(48+fldID)//")"
    PSMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(kf))   ALLOCATE(kf(fDIMs(1)/2+1,fDIMS(2),fDIMS(3)))
   IF(ALLOCATED(likx)) ALLOCATE(likx(fDIMs(1)/2+1,fDIMS(2),fDIMS(3)))
   CALL KGRIDBUILDER(LX3D,likx)
   CALL FFTW(f,kf)
   CALL Df(kf,likx,kfx,DORDER,fldID,CSPACE)
  ELSE
   IF(ALLOCATED(rfx))   ALLOCATE(rfx(fDIMs(1),fDIMS(2),fDIMS(3)))
   CALL Df(f,LX3D,rfx,DORDER,fldID,CSPACE)
   CALL FFTW(rfx,kfx)
  END IF

  RETURN
 END SUBROUTINE r8r4c8Df3D

 SUBROUTINE r8r8c8Df3DNONE(f,LX3D,kfx,DORDER)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)           :: LX3D(:,:,:)
  REAL(8),    INTENT(IN)           :: f(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:,:,:)
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL Df(f,LX3D,kfx,DORDER,1,"x")

  RETURN
 END SUBROUTINE r8r8c8Df3DNONE

 SUBROUTINE r8r8c8Df3D1INT(f,LX3D,kfx,DORDER,fldID)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)           :: LX3D(:,:,:)
  REAL(8),    INTENT(IN)           :: f(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:,:,:)
  INTEGER(4), INTENT(IN)           :: fldID
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL Df(f,LX3D,kfx,DORDER,fldID,"x")

  RETURN
 END SUBROUTINE r8r8c8Df3D1INT

 SUBROUTINE r8r8c8Df3D1CHR(f,LX3D,kfx,DORDER,CSPACE)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)           :: LX3D(:,:,:)
  REAL(8),    INTENT(IN)           :: f(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:,:,:)
  INTEGER(4), INTENT(IN)           :: DORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE

  CALL Df(f,LX3D,kfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE r8r8c8Df3D1CHR

 SUBROUTINE r8r8c8Df3D(f,LX3D,kfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)           :: LX3D(:,:,:)
  REAL(8),    INTENT(IN)           :: f(:,:,:)
  REAL(8),    ALLOCATABLE          :: rfx(:,:,:)
  COMPLEX(8), ALLOCATABLE          :: likx(:,:,:),kf(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:,:,:)
  INTEGER(4), INTENT(IN)           :: DORDER,fldID
  INTEGER(4)                       :: IORDER
  INTEGER(4)                       :: fDIMS(3)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1
  LOGICAL,    SAVE                 :: PSMACCESSID=.TRUE.
  LOGICAL                          :: XDIR=.FALSE.
  LOGICAL                          :: YDIR=.FALSE.
  LOGICAL                          :: ZDIR=.FALSE.
 
  fDIMS=SIZE(f)

  CSPACE1=CSPACE(1:1)
  IF(CSPACE1.EQ."x".OR.CSPACE1.EQ."X") THEN
   XDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."y".OR.CSPACE1.EQ."Y") THEN
   YDIR=.TRUE.                     
  ELSE IF(CSPACE1.EQ."z".OR.CSPACE1.EQ."Z") THEN
   ZDIR=.TRUE.
  ELSE
   XDIR=.TRUE.
  END IF

  IF(PSMDSCHEME(fldID).OR.((XDIR.AND.XPSMDSCHEME(fldID)).OR.(YDIR.AND.YPSMDSCHEME(fldID)).OR.(ZDIR.AND.ZPSMDSCHEME(fldID)))) THEN
   IF(PSMACCESSID) THEN
    IF( PSMDSCHEME(fldID)) PRINT*, " PSMDSCHEME("//CHAR(48+fldID)//")"
    IF(XPSMDSCHEME(fldID)) PRINT*, "XPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(YPSMDSCHEME(fldID)) PRINT*, "YPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(ZPSMDSCHEME(fldID)) PRINT*, "ZPSMDSCHEME("//CHAR(48+fldID)//")"
    PSMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(kf))   ALLOCATE(kf(fDIMs(1)/2+1,fDIMS(2),fDIMS(3)))
   IF(ALLOCATED(likx)) ALLOCATE(likx(fDIMs(1)/2+1,fDIMS(2),fDIMS(3)))
   CALL KGRIDBUILDER(LX3D,likx)
   CALL FFTW(f,kf)
   CALL Df(kf,likx,kfx,DORDER,fldID,CSPACE)
  ELSE
   IF(ALLOCATED(rfx))   ALLOCATE(rfx(fDIMs(1),fDIMS(2),fDIMS(3)))
   CALL Df(f,LX3D,rfx,DORDER,fldID,CSPACE)
   CALL FFTW(rfx,kfx)
  END IF

  RETURN
 END SUBROUTINE r8r8c8Df3D

 SUBROUTINE r8r4r8Df3DNONE(f,LX3D,rfx,DORDER)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX3D(:,:,:)
  REAL(8),    INTENT(IN)           :: f(:,:,:)
  REAL(8),    INTENT(OUT)          :: rfx(:,:,:)
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4)                       :: fDIM(3),DxDIR,ifDIM2,ifDIM3

  fDIM=SHAPE(f)

  DxDIR=1
  DO ifDIM2=1,fDIM(2)
   IF(LX3D(1,ifDIM2,1).NE.LX3D(1,1,1)) THEN
    DxDIR=2
    EXIT
   END IF
  END DO
  DO ifDIM3=1,fDIM(3)
   IF(LX3D(1,1,ifDIM3).NE.LX3D(1,1,1)) THEN
    DxDIR=3
    EXIT
   END IF
  END DO

  IF(DxDIR.EQ.1) THEN
   CALL Df(f,LX3D,rfx,DORDER,1,"x")
  ELSE IF(DxDIR.EQ.2) THEN
   CALL Df(f,LX3D,rfx,DORDER,1,"y")
  ELSE IF(DxDIR.EQ.3) THEN
   CALL Df(f,LX3D,rfx,DORDER,1,"z")
  END IF

  RETURN
 END SUBROUTINE r8r4r8Df3DNONE

 SUBROUTINE r8r4r8Df3D1INT(f,LX3D,rfx,DORDER,fldID)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX3D(:,:,:)
  REAL(8),    INTENT(IN)           :: f(:,:,:)
  REAL(8),    INTENT(OUT)          :: rfx(:,:,:)
  INTEGER(4), INTENT(IN)           :: fldID
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4)                       :: fDIM(3),DxDIR,ifDIM2,ifDIM3

  fDIM=SHAPE(f)

  DxDIR=1
  DO ifDIM2=1,fDIM(2)
   IF(LX3D(1,ifDIM2,1).NE.LX3D(1,1,1)) THEN
    DxDIR=2
    EXIT
   END IF
  END DO
  DO ifDIM3=1,fDIM(3)
   IF(LX3D(1,1,ifDIM3).NE.LX3D(1,1,1)) THEN
    DxDIR=3
    EXIT
   END IF
  END DO

  IF(DxDIR.EQ.1) THEN
   CALL Df(f,LX3D,rfx,DORDER,fldID,"x")
  ELSE IF(DxDIR.EQ.2) THEN
   CALL Df(f,LX3D,rfx,DORDER,fldID,"y")
  ELSE IF(DxDIR.EQ.3) THEN
   CALL Df(f,LX3D,rfx,DORDER,fldID,"z")
  END IF

  RETURN
 END SUBROUTINE r8r4r8Df3D1INT

 SUBROUTINE r8r4r8Df3D1CHR(f,LX3D,rfx,DORDER,CSPACE)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX3D(:,:,:)
  REAL(8),    INTENT(IN)           :: f(:,:,:)
  REAL(8),    INTENT(OUT)          :: rfx(:,:,:)
  INTEGER(4), INTENT(IN)           :: DORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE

  CALL Df(f,LX3D,rfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE r8r4r8Df3D1CHR

 SUBROUTINE r8r4r8Df3D(f,LX3D,rfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:)
  REAL(8), INTENT(OUT)             :: rfx(:,:,:)
  REAL(8),    ALLOCATABLE          :: tf(:,:,:)
  COMPLEX(8), ALLOCATABLE          :: kf(:,:,:),kfx(:,:,:)
  COMPLEX(8), ALLOCATABLE          :: likx(:,:,:)
  INTEGER(4)                       :: fDIM(3),DxDIR,ifDIM1,ifDIM2,ifDIM3
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4)                       :: IORDER
  INTEGER(4), INTENT(IN)           :: fldID
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1
  LOGICAL,    SAVE                 :: FDMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: PSMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: CSMACCESSID=.TRUE.
  LOGICAL                          :: XDIR=.FALSE.
  LOGICAL                          :: YDIR=.FALSE.
  LOGICAL                          :: ZDIR=.FALSE.

  fDIM=SHAPE(f)

  DxDIR=1
  DO ifDIM2=1,fDIM(2)
   IF(LX3D(1,ifDIM2,1).NE.LX3D(1,1,1)) THEN
    DxDIR=2
    EXIT
   END IF
  END DO
  DO ifDIM3=1,fDIM(3)
   IF(LX3D(1,1,ifDIM3).NE.LX3D(1,1,1)) THEN
    DxDIR=3
    EXIT
   END IF
  END DO

  CSPACE1=CSPACE(1:1)
  IF(CSPACE1.EQ."x".OR.CSPACE1.EQ."X") THEN
   XDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."y".OR.CSPACE1.EQ."Y") THEN
   YDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."z".OR.CSPACE1.EQ."Z") THEN
   ZDIR=.TRUE.
  END IF

  IF(PSMDSCHEME(fldID).OR.((XDIR.AND.XPSMDSCHEME(fldID)).OR.(YDIR.AND.YPSMDSCHEME(fldID)).OR.(ZDIR.AND.ZPSMDSCHEME(fldID)))) THEN
   IF(PSMACCESSID) THEN
    IF( PSMDSCHEME(fldID)) PRINT*, " PSMDSCHEME("//CHAR(48+fldID)//")"
    IF(XPSMDSCHEME(fldID)) PRINT*, "XPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(YPSMDSCHEME(fldID)) PRINT*, "YPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(ZPSMDSCHEME(fldID)) PRINT*, "ZPSMDSCHEME("//CHAR(48+fldID)//")"
    PSMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(kfx).EQV..FALSE.)  ALLOCATE(kfx(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   CALL KGRIDBUILDER(LX3D,likx)
   CALL FFTW(f,kfx)
   CALL Df(kf,likx,kfx,DORDER,fldID,CSPACE)
   CALL iFFTW(kfx,rfx)

  ELSE
   IF(DxDIR.EQ.1) THEN
    DO ifDIM2=1,fDIM(2)
     DO ifDIM3=1,fDIM(3)
      CALL Df(f(:,ifDIM2,ifDIM3),LX3D(:,ifDIM2,ifDIM3),rfx(:,ifDIM2,ifDIM3),DORDER,fldID,CSPACE1)
     END DO
    END DO
   ELSE IF(DxDIR.EQ.2) THEN
    DO ifDIM1=1,fDIM(1)
     DO ifDIM3=1,fDIM(3)
      CALL Df(f(ifDIM1,:,ifDIM3),LX3D(ifDIM1,:,ifDIM3),rfx(ifDIM1,:,ifDIM3),DORDER,fldID,CSPACE1)
     END DO
    END DO
   ELSE IF(DxDIR.EQ.3) THEN
    DO ifDIM1=1,fDIM(1)
     DO ifDIM2=1,fDIM(2)
      CALL Df(f(ifDIM1,ifDIM2,:),LX3D(ifDIM1,ifDIM2,:),rfx(ifDIM1,ifDIM2,:),DORDER,fldID,CSPACE1)
     END DO
    END DO
   END IF
  END IF

  RETURN
 END SUBROUTINE r8r4r8Df3D

 SUBROUTINE r8r8r8Df3DNONE(f,LX3D,rfx,DORDER)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)           :: LX3D(:,:,:)
  REAL(8),    INTENT(IN)           :: f(:,:,:)
  REAL(8),    INTENT(OUT)          :: rfx(:,:,:)
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4)                       :: fDIM(3),DxDIR,ifDIM2,ifDIM3

  fDIM=SHAPE(f)

  DxDIR=1
  DO ifDIM2=1,fDIM(2)
   IF(LX3D(1,ifDIM2,1).NE.LX3D(1,1,1)) THEN
    DxDIR=2
    EXIT
   END IF
  END DO
  DO ifDIM3=1,fDIM(3)
   IF(LX3D(1,1,ifDIM3).NE.LX3D(1,1,1)) THEN
    DxDIR=3
    EXIT
   END IF
  END DO

  IF(DxDIR.EQ.1) THEN
   CALL Df(f,LX3D,rfx,DORDER,1,"x")
  ELSE IF(DxDIR.EQ.2) THEN
   CALL Df(f,LX3D,rfx,DORDER,1,"y")
  ELSE IF(DxDIR.EQ.3) THEN
   CALL Df(f,LX3D,rfx,DORDER,1,"z")
  END IF

  RETURN
 END SUBROUTINE r8r8r8Df3DNONE

 SUBROUTINE r8r8r8Df3D1INT(f,LX3D,rfx,DORDER,fldID)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)           :: LX3D(:,:,:)
  REAL(8),    INTENT(IN)           :: f(:,:,:)
  REAL(8),    INTENT(OUT)          :: rfx(:,:,:)
  INTEGER(4), INTENT(IN)           :: fldID
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4)                       :: fDIM(3),DxDIR,ifDIM2,ifDIM3

  fDIM=SHAPE(f)

  DxDIR=1
  DO ifDIM2=1,fDIM(2)
   IF(LX3D(1,ifDIM2,1).NE.LX3D(1,1,1)) THEN
    DxDIR=2
    EXIT
   END IF
  END DO
  DO ifDIM3=1,fDIM(3)
   IF(LX3D(1,1,ifDIM3).NE.LX3D(1,1,1)) THEN
    DxDIR=3
    EXIT
   END IF
  END DO

  IF(DxDIR.EQ.1) THEN
   CALL Df(f,LX3D,rfx,DORDER,fldID,"x")
  ELSE IF(DxDIR.EQ.2) THEN
   CALL Df(f,LX3D,rfx,DORDER,fldID,"y")
  ELSE IF(DxDIR.EQ.3) THEN
   CALL Df(f,LX3D,rfx,DORDER,fldID,"z")
  END IF

  RETURN
 END SUBROUTINE r8r8r8Df3D1INT

 SUBROUTINE r8r8r8Df3D1CHR(f,LX3D,rfx,DORDER,CSPACE)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)           :: LX3D(:,:,:)
  REAL(8),    INTENT(IN)           :: f(:,:,:)
  REAL(8),    INTENT(OUT)          :: rfx(:,:,:)
  INTEGER(4), INTENT(IN)           :: DORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE

  CALL Df(f,LX3D,rfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE r8r8r8Df3D1CHR

 SUBROUTINE r8r8r8Df3D(f,LX3D,rfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:)
  REAL(8), INTENT(OUT)             :: rfx(:,:,:)
  REAL(8),    ALLOCATABLE          :: tf(:,:,:)
  COMPLEX(8), ALLOCATABLE          :: kf(:,:,:),kfx(:,:,:)
  COMPLEX(8), ALLOCATABLE          :: likx(:,:,:)
  INTEGER(4)                       :: fDIM(3),DxDIR,ifDIM1,ifDIM2,ifDIM3
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4)                       :: IORDER
  INTEGER(4), INTENT(IN)           :: fldID
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE        ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1
  LOGICAL,    SAVE                 :: FDMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: PSMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: CSMACCESSID=.TRUE.
  LOGICAL                          :: XDIR=.FALSE.
  LOGICAL                          :: YDIR=.FALSE.
  LOGICAL                          :: ZDIR=.FALSE.

  fDIM=SHAPE(f)

  DxDIR=1
  DO ifDIM2=1,fDIM(2)
   IF(LX3D(1,ifDIM2,1).NE.LX3D(1,1,1)) THEN
    DxDIR=2
    EXIT
   END IF
  END DO
  DO ifDIM3=1,fDIM(3)
   IF(LX3D(1,1,ifDIM3).NE.LX3D(1,1,1)) THEN
    DxDIR=3
    EXIT
   END IF
  END DO

  CSPACE1=CSPACE(1:1)
  IF(CSPACE1.EQ."x".OR.CSPACE1.EQ."X") THEN
   XDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."y".OR.CSPACE1.EQ."Y") THEN
   YDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."z".OR.CSPACE1.EQ."Z") THEN
   ZDIR=.TRUE.
  END IF

  IF(PSMDSCHEME(fldID).OR.((XDIR.AND.XPSMDSCHEME(fldID)).OR.(YDIR.AND.YPSMDSCHEME(fldID)).OR.(ZDIR.AND.ZPSMDSCHEME(fldID)))) THEN
   IF(PSMACCESSID) THEN
    IF( PSMDSCHEME(fldID)) PRINT*, " PSMDSCHEME("//CHAR(48+fldID)//")"
    IF(XPSMDSCHEME(fldID)) PRINT*, "XPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(YPSMDSCHEME(fldID)) PRINT*, "YPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(ZPSMDSCHEME(fldID)) PRINT*, "ZPSMDSCHEME("//CHAR(48+fldID)//")"
    PSMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(kfx).EQV..FALSE.)  ALLOCATE(kfx(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   CALL KGRIDBUILDER(LX3D,likx)
   CALL FFTW(f,kfx)
   CALL Df(kf,likx,kfx,DORDER,fldID,CSPACE)
   CALL iFFTW(kfx,rfx)

  ELSE
   IF(DxDIR.EQ.1) THEN
    DO ifDIM2=1,fDIM(2)
     DO ifDIM3=1,fDIM(3)
      CALL Df(f(:,ifDIM2,ifDIM3),LX3D(:,ifDIM2,ifDIM3),rfx(:,ifDIM2,ifDIM3),DORDER,fldID,CSPACE1)
     END DO
    END DO
   ELSE IF(DxDIR.EQ.2) THEN
    DO ifDIM1=1,fDIM(1)
     DO ifDIM3=1,fDIM(3)
      CALL Df(f(ifDIM1,:,ifDIM3),LX3D(ifDIM1,:,ifDIM3),rfx(ifDIM1,:,ifDIM3),DORDER,fldID,CSPACE1)
     END DO
    END DO
   ELSE IF(DxDIR.EQ.3) THEN
    DO ifDIM1=1,fDIM(1)
     DO ifDIM2=1,fDIM(2)
      CALL Df(f(ifDIM1,ifDIM2,:),LX3D(ifDIM1,ifDIM2,:),rfx(ifDIM1,ifDIM2,:),DORDER,fldID,CSPACE1)
     END DO
    END DO
   END IF
  END IF

  RETURN
 END SUBROUTINE r8r8r8Df3D


!************ MULTIPLICATION OF TWO DRIVATIVES (DfDg) *******************
 SUBROUTINE c8c8c8DfDg1DNONE(kf,kg,likx,liky,kfxgy)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:),liky(:)
  COMPLEX(8),       INTENT(IN)     :: kf(:),kg(:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:)

  CALL DfDg(kf,kg,likx,liky,kfxgy,1,"x")

  RETURN
 END SUBROUTINE c8c8c8DfDg1DNONE

 SUBROUTINE c8c8c8DfDg1D1INT(kf,kg,likx,liky,kfxgy,fldID)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:),liky(:)
  COMPLEX(8),       INTENT(IN)     :: kf(:),kg(:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL DfDg(kf,kg,likx,liky,kfxgy,fldID,"x")

  RETURN
 END SUBROUTINE c8c8c8DfDg1D1INT

 SUBROUTINE c8c8c8DfDg1D1CHR(kf,kg,likx,liky,kfxgy,CSPACE)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:),liky(:)
  COMPLEX(8),       INTENT(IN)     :: kf(:),kg(:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL DfDg(kf,kg,likx,liky,kfxgy,1,CSPACE)

  RETURN
 END SUBROUTINE c8c8c8DfDg1D1CHR

 SUBROUTINE c8c8c8DfDg1D(kf,kg,likx,liky,kfxgy,fldID,CSPACE)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)  :: likx(:),liky(:)
  COMPLEX(8),       INTENT(IN)  :: kf(:),kg(:)
  COMPLEX(8),       INTENT(OUT) :: kfxgy(:)
  COMPLEX(8),       ALLOCATABLE :: kfx(:),kgy(:)
  COMPLEX(8),       ALLOCATABLE :: exkfx1d(:),exkgy1d(:)
  COMPLEX(8),       ALLOCATABLE :: exkfxgy1d(:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: D1MAT13,fDIM
  INTEGER(4)                    :: DxDIR
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE    ! CURRENT SPACE
  CHARACTER(LEN=1)              :: CSPACE1
  REAL(8),          ALLOCATABLE :: rfxgy(:)
  REAL(8),          ALLOCATABLE :: exrfxgy1d(:)
  REAL(8),          ALLOCATABLE :: rfx(:),rgy(:)
  REAL(8),          ALLOCATABLE :: exrfx1d(:),exrgy1d(:)

  fDIM=SIZE(kf)
  D1MAT13=(fDIM-1)/3

  CSPACE1=CSPACE(1:1)

   IF(ALLOCATED(kfx).EQV..FALSE.)       ALLOCATE(kfx(fDIM))
   IF(ALLOCATED(kgy).EQV..FALSE.)       ALLOCATE(kgy(fDIM))
   IF(ALLOCATED(exkfxgy1d).EQV..FALSE.) ALLOCATE(exkfxgy1d(fDIM+D1MAT13))
   IF(ALLOCATED(exkfx1d).EQV..FALSE.)   ALLOCATE(exkfx1d(  fDIM+D1MAT13))
   IF(ALLOCATED(exkgy1d).EQV..FALSE.)   ALLOCATE(exkgy1d(  fDIM+D1MAT13))
   IF(ALLOCATED(exrfxgy1d).EQV..FALSE.) ALLOCATE(exrfxgy1d(2*(fDIM+D1MAT13-1)))
   IF(ALLOCATED(exrfx1d).EQV..FALSE.)   ALLOCATE(exrfx1d(  2*(fDIM+D1MAT13-1)))
   IF(ALLOCATED(exrgy1d).EQV..FALSE.)   ALLOCATE(exrgy1d(  2*(fDIM+D1MAT13-1)))

   kfx=0.0d0;kgy=0.0d0
   exkfx1d=0.0d0;exkgy1d=0.0d0
   exrfxgy1d=0.0d0
   exrfx1d=0.0d0;exrgy1d=0.0d0

   CALL Df(kf,likx,kfx,1,fldID,CSPACE)
   CALL addFFTalias(kfx,exkfx1d)
   CALL iFFTW(exkfx1d,exrfx1d)

   CALL Df(kg,liky,kgy,1,fldID,CSPACE)
   CALL addFFTalias(kgy,exkgy1d)
   CALL iFFTW(exkgy1d,exrgy1d)

   exrfxgy1d=exrfxgy1d+exrfx1d*exrgy1d
   CALL FFTW(exrfxgy1d,exkfxgy1d)
   CALL rmvFFTalias(exkfxgy1d,kfxgy)

  RETURN
 END SUBROUTINE c8c8c8DfDg1D

 SUBROUTINE r4r4c8DfDg1DNONE(f,g,LX1D,LY1D,kfxgy)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX1D(:),LY1D(:)
  REAL(4),    INTENT(IN)           :: f(:),g(:)
  COMPLEX(8), INTENT(OUT)          :: kfxgy(:)

  CALL DfDg(f,g,LX1D,LY1D,kfxgy,1,"xy")

  RETURN
 END SUBROUTINE r4r4c8DfDg1DNONE

 SUBROUTINE r4r4c8DfDg1D1INT(f,g,LX1D,LY1D,kfxgy,fldID)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX1D(:),LY1D(:)
  REAL(4),    INTENT(IN)           :: f(:),g(:)
  COMPLEX(8), INTENT(OUT)          :: kfxgy(:)
  INTEGER(4), INTENT(IN)           :: fldID

  CALL DfDg(f,g,LX1D,LY1D,kfxgy,fldID,"xy")

  RETURN
 END SUBROUTINE r4r4c8DfDg1D1INT

 SUBROUTINE r4r4c8DfDg1D1CHR(f,g,LX1D,LY1D,kfxgy,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX1D(:),LY1D(:)
  REAL(4),          INTENT(IN)     :: f(:),g(:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL DfDg(f,g,LX1D,LY1D,kfxgy,1,CSPACE)

  RETURN
 END SUBROUTINE r4r4c8DfDg1D1CHR

 SUBROUTINE r4r4c8DfDg1D(f,g,LX1D,LY1D,kfxgy,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX1D(:),LY1D(:)
  REAL(4),          INTENT(IN)     :: f(:),g(:)
  REAL(4),          ALLOCATABLE    :: rfxgy(:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:)
  COMPLEX(8),       ALLOCATABLE    :: kf(:),kg(:)
  COMPLEX(8),       ALLOCATABLE    :: likx(:),liky(:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
  INTEGER(4),       INTENT(IN)     :: fldID
  INTEGER(4)                       :: MATDIM

  MATDIM=SIZE(f)

  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(MATDIM/2+1))
  IF(ALLOCATED(kg).EQV..FALSE.)   ALLOCATE(kg(MATDIM/2+1))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(MATDIM/2+1))
  IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(MATDIM/2+1))

  CALL KGRIDBUILDER(LX1D,likx)
  CALL KGRIDBUILDER(LY1D,liky)
  CALL FFTW(f,kf)
  CALL FFTW(g,kg)
  CALL DfDg(kf,kg,likx,liky,kfxgy,fldID,CSPACE)

  RETURN
 END SUBROUTINE r4r4c8DfDg1D

 SUBROUTINE r4r4r4DfDg1DNONE(f,g,LX1D,LY1D,rfxgy)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX1D(:),LY1D(:)
  REAL(4), INTENT(IN)              :: f(:),g(:)
  REAL(4), INTENT(OUT)             :: rfxgy(:)

  CALL DfDg(f,g,LX1D,LY1D,rfxgy,1,"xy")

  RETURN
 END SUBROUTINE r4r4r4DfDg1DNONE

 SUBROUTINE r4r4r4DfDg1D1INT(f,g,LX1D,LY1D,rfxgy,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX1D(:),LY1D(:)
  REAL(4), INTENT(IN)              :: f(:),g(:)
  REAL(4), INTENT(OUT)             :: rfxgy(:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL DfDg(f,g,LX1D,LY1D,rfxgy,fldID,"xy")

  RETURN
 END SUBROUTINE r4r4r4DfDg1D1INT

 SUBROUTINE r4r4r4DfDg1D1CHR(f,g,LX1D,LY1D,rfxgy,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX1D(:),LY1D(:)
  REAL(4), INTENT(IN)              :: f(:),g(:)
  REAL(4), INTENT(OUT)             :: rfxgy(:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL DfDg(f,g,LX1D,LY1D,rfxgy,1,CSPACE)

  RETURN
 END SUBROUTINE r4r4r4DfDg1D1CHR

 SUBROUTINE r4r4r4DfDg1D(f,g,LX1D,LY1D,rfxgy,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX1D(:),LY1D(:)
  REAL(4), INTENT(IN)              :: f(:),g(:)
  REAL(4), INTENT(OUT)             :: rfxgy(:)
  REAL(4),    ALLOCATABLE          :: rfx(:),rgy(:)
  COMPLEX(8), ALLOCATABLE          :: kf(:),kg(:),likx(:),liky(:)
  COMPLEX(8), ALLOCATABLE          :: kfxgy(:)
  INTEGER(4)                       :: fDIM
  INTEGER(4)                       :: DxDIR,DyDIR
  INTEGER(4)      , INTENT(IN)     :: fldID
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE            ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1,CSPACE2

  fDIM=SIZE(f)

  IF(LEN(CSPACE).LT.2) THEN
   CSPACE1=CSPACE(1:1)
   IF(CSPACE1.EQ."x".OR.CSPACE1.EQ."X") THEN
    CSPACE2="x"
   ELSE IF(CSPACE1.EQ."y".OR.CSPACE1.EQ."Y") THEN
    CSPACE2="y"
   ELSE IF(CSPACE1.EQ."z".OR.CSPACE1.EQ."Z") THEN
    CSPACE2="z"
   END IF
  ELSE IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, DfDg: NUMBER OF CURRENT SPACE ARE TOO MANY!"
   STOP
  END IF

  IF(PSMDSCHEME(fldID).OR.XPSMDSCHEME(fldID).OR.YPSMDSCHEME(fldID).OR.ZPSMDSCHEME(fldID)) THEN
   ALLOCATE(kf(fDIM/2+1))
   ALLOCATE(kg(fDIM/2+1))
   ALLOCATE(likx(fDIM/2+1))
   ALLOCATE(liky(fDIM/2+1))
   ALLOCATE(kfxgy(fDIM/2+1))
   CALL KGRIDBUILDER(LX1D,likx)
   CALL KGRIDBUILDER(LY1D,liky)
   CALL FFTW(f,kf)
   CALL FFTW(g,kg)
   CALL DfDg(kf,kg,likx,liky,kfxgy,fldID,CSPACE)
   CALL iFFTW(kfxgy,rfxgy)
  ELSE
   IF(ALLOCATED(rfx)) DEALLOCATE(rfx)
   IF(ALLOCATED(rgy)) DEALLOCATE(rgy)
   ALLOCATE(rfx(fDIM))
   ALLOCATE(rgy(fDIM))
   CALL Df(f,LX1D,rfx,1,fldID,CSPACE1)
   CALL Df(f,LY1D,rgy,1,fldID,CSPACE2)
   rfxgy=rfx*rgy
  END IF

  RETURN
 END SUBROUTINE r4r4r4DfDg1D

 SUBROUTINE r8r4c8DfDg1DNONE(f,g,LX1D,LY1D,kfxgy)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX1D(:),LY1D(:)
  REAL(8),    INTENT(IN)           :: f(:),g(:)
  COMPLEX(8), INTENT(OUT)          :: kfxgy(:)

  CALL DfDg(f,g,LX1D,LY1D,kfxgy,1,"xy")

  RETURN
 END SUBROUTINE r8r4c8DfDg1DNONE

 SUBROUTINE r8r4c8DfDg1D1INT(f,g,LX1D,LY1D,kfxgy,fldID)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX1D(:),LY1D(:)
  REAL(8),    INTENT(IN)           :: f(:),g(:)
  COMPLEX(8), INTENT(OUT)          :: kfxgy(:)
  INTEGER(4), INTENT(IN)           :: fldID

  CALL DfDg(f,g,LX1D,LY1D,kfxgy,fldID,"xy")

  RETURN
 END SUBROUTINE r8r4c8DfDg1D1INT

 SUBROUTINE r8r4c8DfDg1D1CHR(f,g,LX1D,LY1D,kfxgy,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX1D(:),LY1D(:)
  REAL(8),          INTENT(IN)     :: f(:),g(:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL DfDg(f,g,LX1D,LY1D,kfxgy,1,CSPACE)

  RETURN
 END SUBROUTINE r8r4c8DfDg1D1CHR

 SUBROUTINE r8r4c8DfDg1D(f,g,LX1D,LY1D,kfxgy,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX1D(:),LY1D(:)
  REAL(8),          INTENT(IN)     :: f(:),g(:)
  REAL(8),          ALLOCATABLE    :: rfxgy(:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:)
  COMPLEX(8),       ALLOCATABLE    :: kf(:),kg(:)
  COMPLEX(8),       ALLOCATABLE    :: likx(:),liky(:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
  INTEGER(4),       INTENT(IN)     :: fldID
  INTEGER(4)                       :: MATDIM

  MATDIM=SIZE(f)

  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(MATDIM/2+1))
  IF(ALLOCATED(kg).EQV..FALSE.)   ALLOCATE(kg(MATDIM/2+1))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(MATDIM/2+1))
  IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(MATDIM/2+1))

  CALL KGRIDBUILDER(LX1D,likx)
  CALL KGRIDBUILDER(LY1D,liky)
  CALL FFTW(f,kf)
  CALL FFTW(g,kg)
  CALL DfDg(kf,kg,likx,liky,kfxgy,fldID,CSPACE)

  RETURN
 END SUBROUTINE r8r4c8DfDg1D

 SUBROUTINE r8r8c8DfDg1DNONE(f,g,LX1D,LY1D,kfxgy)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)           :: LX1D(:),LY1D(:)
  REAL(8),    INTENT(IN)           :: f(:),g(:)
  COMPLEX(8), INTENT(OUT)          :: kfxgy(:)

  CALL DfDg(f,g,LX1D,LY1D,kfxgy,1,"xy")

  RETURN
 END SUBROUTINE r8r8c8DfDg1DNONE

 SUBROUTINE r8r8c8DfDg1D1INT(f,g,LX1D,LY1D,kfxgy,fldID)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)           :: LX1D(:),LY1D(:)
  REAL(8),    INTENT(IN)           :: f(:),g(:)
  COMPLEX(8), INTENT(OUT)          :: kfxgy(:)
  INTEGER(4), INTENT(IN)           :: fldID

  CALL DfDg(f,g,LX1D,LY1D,kfxgy,fldID,"xy")

  RETURN
 END SUBROUTINE r8r8c8DfDg1D1INT

 SUBROUTINE r8r8c8DfDg1D1CHR(f,g,LX1D,LY1D,kfxgy,CSPACE)
  IMPLICIT NONE
  REAL(8),          INTENT(IN)     :: LX1D(:),LY1D(:)
  REAL(8),          INTENT(IN)     :: f(:),g(:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL DfDg(f,g,LX1D,LY1D,kfxgy,1,CSPACE)

  RETURN
 END SUBROUTINE r8r8c8DfDg1D1CHR

 SUBROUTINE r8r8c8DfDg1D(f,g,LX1D,LY1D,kfxgy,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8),          INTENT(IN)     :: LX1D(:),LY1D(:)
  REAL(8),          INTENT(IN)     :: f(:),g(:)
  REAL(8),          ALLOCATABLE    :: rfxgy(:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:)
  COMPLEX(8),       ALLOCATABLE    :: kf(:),kg(:)
  COMPLEX(8),       ALLOCATABLE    :: likx(:),liky(:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
  INTEGER(4),       INTENT(IN)     :: fldID
  INTEGER(4)                       :: MATDIM

  MATDIM=SIZE(f)

  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(MATDIM/2+1))
  IF(ALLOCATED(kg).EQV..FALSE.)   ALLOCATE(kg(MATDIM/2+1))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(MATDIM/2+1))
  IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(MATDIM/2+1))

  CALL KGRIDBUILDER(LX1D,likx)
  CALL KGRIDBUILDER(LY1D,liky)
  CALL FFTW(f,kf)
  CALL FFTW(g,kg)
  CALL DfDg(kf,kg,likx,liky,kfxgy,fldID,CSPACE)

  RETURN
 END SUBROUTINE r8r8c8DfDg1D

 SUBROUTINE r8r4r8DfDg1DNONE(f,g,LX1D,LY1D,rfxgy)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX1D(:),LY1D(:)
  REAL(8), INTENT(IN)              :: f(:),g(:)
  REAL(8), INTENT(OUT)             :: rfxgy(:)

  CALL DfDg(f,g,LX1D,LY1D,rfxgy,1,"xy")

  RETURN
 END SUBROUTINE r8r4r8DfDg1DNONE

 SUBROUTINE r8r4r8DfDg1D1INT(f,g,LX1D,LY1D,rfxgy,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX1D(:),LY1D(:)
  REAL(8), INTENT(IN)              :: f(:),g(:)
  REAL(8), INTENT(OUT)             :: rfxgy(:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL DfDg(f,g,LX1D,LY1D,rfxgy,fldID,"xy")

  RETURN
 END SUBROUTINE r8r4r8DfDg1D1INT

 SUBROUTINE r8r4r8DfDg1D1CHR(f,g,LX1D,LY1D,rfxgy,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX1D(:),LY1D(:)
  REAL(8), INTENT(IN)              :: f(:),g(:)
  REAL(8), INTENT(OUT)             :: rfxgy(:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL DfDg(f,g,LX1D,LY1D,rfxgy,1,CSPACE)

  RETURN
 END SUBROUTINE r8r4r8DfDg1D1CHR

 SUBROUTINE r8r4r8DfDg1D(f,g,LX1D,LY1D,rfxgy,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX1D(:),LY1D(:)
  REAL(8), INTENT(IN)              :: f(:),g(:)
  REAL(8), INTENT(OUT)             :: rfxgy(:)
  REAL(8),    ALLOCATABLE          :: rfx(:),rgy(:)
  COMPLEX(8), ALLOCATABLE          :: kf(:),kg(:),likx(:),liky(:)
  COMPLEX(8), ALLOCATABLE          :: kfxgy(:)
  INTEGER(4)                       :: fDIM
  INTEGER(4)                       :: DxDIR,DyDIR
  INTEGER(4)      , INTENT(IN)     :: fldID
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE            ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1,CSPACE2

  fDIM=SIZE(f)

  IF(LEN(CSPACE).LT.2) THEN
   CSPACE1=CSPACE(1:1)
   IF(CSPACE1.EQ."x".OR.CSPACE1.EQ."X") THEN
    CSPACE2="x"
   ELSE IF(CSPACE1.EQ."y".OR.CSPACE1.EQ."Y") THEN
    CSPACE2="y"
   ELSE IF(CSPACE1.EQ."z".OR.CSPACE1.EQ."Z") THEN
    CSPACE2="z"
   END IF
  ELSE IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, DfDg: NUMBER OF CURRENT SPACE ARE TOO MANY!"
   STOP
  END IF

  IF(PSMDSCHEME(fldID).OR.XPSMDSCHEME(fldID).OR.YPSMDSCHEME(fldID).OR.ZPSMDSCHEME(fldID)) THEN
   ALLOCATE(kf(fDIM/2+1))
   ALLOCATE(kg(fDIM/2+1))
   ALLOCATE(likx(fDIM/2+1))
   ALLOCATE(liky(fDIM/2+1))
   ALLOCATE(kfxgy(fDIM/2+1))
   CALL KGRIDBUILDER(LX1D,likx)
   CALL KGRIDBUILDER(LY1D,liky)
   CALL FFTW(f,kf)
   CALL FFTW(g,kg)
   CALL DfDg(kf,kg,likx,liky,kfxgy,fldID,CSPACE)
   CALL iFFTW(kfxgy,rfxgy)
  ELSE
   IF(ALLOCATED(rfx)) DEALLOCATE(rfx)
   IF(ALLOCATED(rgy)) DEALLOCATE(rgy)
   ALLOCATE(rfx(fDIM))
   ALLOCATE(rgy(fDIM))
   CALL Df(f,LX1D,rfx,1,fldID,CSPACE1)
   CALL Df(f,LY1D,rgy,1,fldID,CSPACE2)
   rfxgy=rfx*rgy
  END IF

  RETURN
 END SUBROUTINE r8r4r8DfDg1D

 SUBROUTINE r8r8r8DfDg1DNONE(f,g,LX1D,LY1D,rfxgy)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX1D(:),LY1D(:)
  REAL(8), INTENT(IN)              :: f(:),g(:)
  REAL(8), INTENT(OUT)             :: rfxgy(:)

  CALL DfDg(f,g,LX1D,LY1D,rfxgy,1,"xy")

  RETURN
 END SUBROUTINE r8r8r8DfDg1DNONE

 SUBROUTINE r8r8r8DfDg1D1INT(f,g,LX1D,LY1D,rfxgy,fldID)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX1D(:),LY1D(:)
  REAL(8), INTENT(IN)              :: f(:),g(:)
  REAL(8), INTENT(OUT)             :: rfxgy(:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL DfDg(f,g,LX1D,LY1D,rfxgy,fldID,"xy")

  RETURN
 END SUBROUTINE r8r8r8DfDg1D1INT

 SUBROUTINE r8r8r8DfDg1D1CHR(f,g,LX1D,LY1D,rfxgy,CSPACE)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX1D(:),LY1D(:)
  REAL(8), INTENT(IN)              :: f(:),g(:)
  REAL(8), INTENT(OUT)             :: rfxgy(:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL DfDg(f,g,LX1D,LY1D,rfxgy,1,CSPACE)

  RETURN
 END SUBROUTINE r8r8r8DfDg1D1CHR

 SUBROUTINE r8r8r8DfDg1D(f,g,LX1D,LY1D,rfxgy,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX1D(:),LY1D(:)
  REAL(8), INTENT(IN)              :: f(:),g(:)
  REAL(8), INTENT(OUT)             :: rfxgy(:)
  REAL(8),    ALLOCATABLE          :: rfx(:),rgy(:)
  COMPLEX(8), ALLOCATABLE          :: kf(:),kg(:),likx(:),liky(:)
  COMPLEX(8), ALLOCATABLE          :: kfxgy(:)
  INTEGER(4)                       :: fDIM
  INTEGER(4)                       :: DxDIR,DyDIR
  INTEGER(4)      , INTENT(IN)     :: fldID
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE            ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1,CSPACE2

  fDIM=SIZE(f)

  IF(LEN(CSPACE).LT.2) THEN
   CSPACE1=CSPACE(1:1)
   IF(CSPACE1.EQ."x".OR.CSPACE1.EQ."X") THEN
    CSPACE2="x"
   ELSE IF(CSPACE1.EQ."y".OR.CSPACE1.EQ."Y") THEN
    CSPACE2="y"
   ELSE IF(CSPACE1.EQ."z".OR.CSPACE1.EQ."Z") THEN
    CSPACE2="z"
   END IF
  ELSE IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, DfDg: NUMBER OF CURRENT SPACE ARE TOO MANY!"
   STOP
  END IF

  IF(PSMDSCHEME(fldID).OR.XPSMDSCHEME(fldID).OR.YPSMDSCHEME(fldID).OR.ZPSMDSCHEME(fldID)) THEN
   ALLOCATE(kf(fDIM/2+1))
   ALLOCATE(kg(fDIM/2+1))
   ALLOCATE(likx(fDIM/2+1))
   ALLOCATE(liky(fDIM/2+1))
   ALLOCATE(kfxgy(fDIM/2+1))
   CALL KGRIDBUILDER(LX1D,likx)
   CALL KGRIDBUILDER(LY1D,liky)
   CALL FFTW(f,kf)
   CALL FFTW(g,kg)
   CALL DfDg(kf,kg,likx,liky,kfxgy,fldID,CSPACE)
   CALL iFFTW(kfxgy,rfxgy)
  ELSE
   IF(ALLOCATED(rfx)) DEALLOCATE(rfx)
   IF(ALLOCATED(rgy)) DEALLOCATE(rgy)
   ALLOCATE(rfx(fDIM))
   ALLOCATE(rgy(fDIM))
   CALL Df(f,LX1D,rfx,1,fldID,CSPACE1)
   CALL Df(f,LY1D,rgy,1,fldID,CSPACE2)
   rfxgy=rfx*rgy
  END IF

  RETURN
 END SUBROUTINE r8r8r8DfDg1D

 SUBROUTINE c8c8c8DfDg2DNONE(kf,kg,likx,liky,kfxgy)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:,:),liky(:,:)
  COMPLEX(8),       INTENT(IN)     :: kf(:,:),kg(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:,:)

  CALL DfDg(kf,kg,likx,liky,kfxgy,1,"xy")

  RETURN
 END SUBROUTINE c8c8c8DfDg2DNONE

 SUBROUTINE c8c8c8DfDg2D1INT(kf,kg,likx,liky,kfxgy,fldID)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:,:),liky(:,:)
  COMPLEX(8),       INTENT(IN)     :: kf(:,:),kg(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL DfDg(kf,kg,likx,liky,kfxgy,fldID,"xy")

  RETURN
 END SUBROUTINE c8c8c8DfDg2D1INT

 SUBROUTINE c8c8c8DfDg2D1CHR(kf,kg,likx,liky,kfxgy,CSPACE)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:,:),liky(:,:)
  COMPLEX(8),       INTENT(IN)     :: kf(:,:),kg(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL DfDg(kf,kg,likx,liky,kfxgy,1,CSPACE)

  RETURN
 END SUBROUTINE c8c8c8DfDg2D1CHR

 SUBROUTINE c8c8c8DfDg2D(kf,kg,likx,liky,kfxgy,fldID,CSPACE)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)  :: likx(:,:),liky(:,:)
  COMPLEX(8),       INTENT(IN)  :: kf(:,:),kg(:,:)
  COMPLEX(8),       INTENT(OUT) :: kfxgy(:,:)
  COMPLEX(8),       ALLOCATABLE :: kfx(:,:),kgy(:,:)
  COMPLEX(8),       ALLOCATABLE :: exkfx2d(:,:),exkgy2d(:,:)
  COMPLEX(8),       ALLOCATABLE :: exkfxgy2d(:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: rD1MAT13,rD2MAT13,rfDIMS(2)
  INTEGER(4)                    :: kD1MAT13,kD2MAT13,kfDIMS(2)
  INTEGER(4)                    :: DxDIR
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE    ! CURRENT SPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2
  REAL(8),          ALLOCATABLE :: rfxgy(:,:)
  REAL(8),          ALLOCATABLE :: exrfxgy2d(:,:)
  REAL(8),          ALLOCATABLE :: rfx(:,:),rgy(:,:)
  REAL(8),          ALLOCATABLE :: exrfx2d(:,:),exrgy2d(:,:)
  LOGICAL                       :: exSTATUS=.TRUE.

  kfDIMS=SHAPE(kf)
  kD1MAT13=(kfDIMS(1)-1)/3
  kD2MAT13=(kfDIMS(2)-1)/3

  rfDIMS(1)=2*(kfDIMS(1)-1)
  rfDIMS(2)=kfDIMS(2)
  rD1MAT13=(rfDIMS(1)-1)/3
  rD2MAT13=(rfDIMS(2)-1)/3

  IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, DfDg: NUMBER OF CURRENT SPACES ARE NOT ENOUGH!"
   STOP
  ELSE IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, DfDg: NUMBER OF CURRENT SPACES ARE TOO MANY!"
   STOP
  END IF

   IF(ALLOCATED(kfx).EQV..FALSE.)       ALLOCATE(kfx(kfDIMS(1),kfDIMS(2)))
   IF(ALLOCATED(kgy).EQV..FALSE.)       ALLOCATE(kgy(kfDIMS(1),kfDIMS(2)))
   IF(ALLOCATED(exkfxgy2d).EQV..FALSE.) ALLOCATE(exkfxgy2d(kfDIMS(1)+kD1MAT13,kfDIMS(2)+kD2MAT13))
   IF(ALLOCATED(exkfx2d).EQV..FALSE.)   ALLOCATE(exkfx2d(  kfDIMS(1)+kD1MAT13,kfDIMS(2)+kD2MAT13))
   IF(ALLOCATED(exkgy2d).EQV..FALSE.)   ALLOCATE(exkgy2d(  kfDIMS(1)+kD1MAT13,kfDIMS(2)+kD2MAT13))
   IF(ALLOCATED(exrfxgy2d).EQV..FALSE.) ALLOCATE(exrfxgy2d(rfDIMS(1)+rD1MAT13,rfDIMS(2)+rD2MAT13))
   IF(ALLOCATED(exrfx2d).EQV..FALSE.)   ALLOCATE(exrfx2d(  rfDIMS(1)+rD1MAT13,rfDIMS(2)+rD2MAT13))
   IF(ALLOCATED(exrgy2d).EQV..FALSE.)   ALLOCATE(exrgy2d(  rfDIMS(1)+rD1MAT13,rfDIMS(2)+rD2MAT13))

   kfx=0.0d0;kgy=0.0d0
   exkfx2d=0.0d0;exkgy2d=0.0d0
   exrfxgy2d=0.0d0
   exrfx2d=0.0d0;exrgy2d=0.0d0

   CALL Df(kf,likx,kfx,1,fldID,CSPACE)
   CALL addFFTalias(kfx,exkfx2d)
   CALL iFFTW(exkfx2d,exrfx2d)

   CALL Df(kg,liky,kgy,1,fldID,CSPACE)
   CALL addFFTalias(kgy,exkgy2d)
   CALL iFFTW(exkgy2d,exrgy2d)

   exrfxgy2d=exrfxgy2d+exrfx2d*exrgy2d
   CALL FFTW(exrfxgy2d,exkfxgy2d)
   CALL rmvFFTalias(exkfxgy2d,kfxgy)

  RETURN
 END SUBROUTINE c8c8c8DfDg2D

 SUBROUTINE r4r4c8DfDg2DNONE(f,g,LX2D,LY2D,kfxgy)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX2D(:,:),LY2D(:,:)
  REAL(4),    INTENT(IN)           :: f(:,:),g(:,:)
  COMPLEX(8), INTENT(OUT)          :: kfxgy(:,:)

  CALL DfDg(f,g,LX2D,LY2D,kfxgy,1,"xy")

  RETURN
 END SUBROUTINE r4r4c8DfDg2DNONE

 SUBROUTINE r4r4c8DfDg2D1INT(f,g,LX2D,LY2D,kfxgy,fldID)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX2D(:,:),LY2D(:,:)
  REAL(4),    INTENT(IN)           :: f(:,:),g(:,:)
  COMPLEX(8), INTENT(OUT)          :: kfxgy(:,:)
  INTEGER(4), INTENT(IN)           :: fldID

  CALL DfDg(f,g,LX2D,LY2D,kfxgy,fldID,"xy")

  RETURN
 END SUBROUTINE r4r4c8DfDg2D1INT

 SUBROUTINE r4r4c8DfDg2D1CHR(f,g,LX2D,LY2D,kfxgy,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX2D(:,:),LY2D(:,:)
  REAL(4),          INTENT(IN)     :: f(:,:),g(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL DfDg(f,g,LX2D,LY2D,kfxgy,1,CSPACE)

  RETURN
 END SUBROUTINE r4r4c8DfDg2D1CHR

 SUBROUTINE r4r4c8DfDg2D(f,g,LX2D,LY2D,kfxgy,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX2D(:,:),LY2D(:,:)
  REAL(4),          INTENT(IN)     :: f(:,:),g(:,:)
  REAL(4),          ALLOCATABLE    :: rfxgy(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:,:)
  COMPLEX(8),       ALLOCATABLE    :: kf(:,:),kg(:,:)
  COMPLEX(8),       ALLOCATABLE    :: likx(:,:),liky(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
  INTEGER(4),       INTENT(IN)     :: fldID
  INTEGER(4)                       :: MATDIMS(2)

  MATDIMS=SHAPE(f)

  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(MATDIMS(1)/2+1,MATDIMS(2)))
  IF(ALLOCATED(kg).EQV..FALSE.)   ALLOCATE(kg(MATDIMS(1)/2+1,MATDIMS(2)))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(MATDIMS(1)/2+1,MATDIMS(2)))
  IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(MATDIMS(1)/2+1,MATDIMS(2)))

  CALL KGRIDBUILDER(LX2D,likx)
  CALL KGRIDBUILDER(LY2D,liky)
  CALL FFTW(f,kf)
  CALL FFTW(g,kg)
  CALL DfDg(kf,kg,likx,liky,kfxgy,fldID,CSPACE)

  RETURN
 END SUBROUTINE r4r4c8DfDg2D

 SUBROUTINE r4r4r4DfDg2DNONE(f,g,LX2D,LY2D,rfxgy)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(4), INTENT(IN)              :: f(:,:),g(:,:)
  REAL(4), INTENT(OUT)             :: rfxgy(:,:)

  CALL DfDg(f,g,LX2D,LY2D,rfxgy,1,"xy")

  RETURN
 END SUBROUTINE r4r4r4DfDg2DNONE

 SUBROUTINE r4r4r4DfDg2D1INT(f,g,LX2D,LY2D,rfxgy,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(4), INTENT(IN)              :: f(:,:),g(:,:)
  REAL(4), INTENT(OUT)             :: rfxgy(:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL DfDg(f,g,LX2D,LY2D,rfxgy,fldID,"xy")

  RETURN
 END SUBROUTINE r4r4r4DfDg2D1INT

 SUBROUTINE r4r4r4DfDg2D1CHR(f,g,LX2D,LY2D,rfxgy,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(4), INTENT(IN)              :: f(:,:),g(:,:)
  REAL(4), INTENT(OUT)             :: rfxgy(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL DfDg(f,g,LX2D,LY2D,rfxgy,1,CSPACE)

  RETURN
 END SUBROUTINE r4r4r4DfDg2D1CHR

 SUBROUTINE r4r4r4DfDg2D(f,g,LX2D,LY2D,rfxgy,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: f(:,:),g(:,:)
  REAL(4), INTENT(OUT)             :: rfxgy(:,:)
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(4),    ALLOCATABLE          :: rfx(:,:),rgy(:,:)
  COMPLEX(8), ALLOCATABLE          :: kf(:,:),kg(:,:),likx(:,:),liky(:,:)
  COMPLEX(8), ALLOCATABLE          :: kfxgy(:,:)
  INTEGER(4)                       :: fDIM(2)
  INTEGER(4)                       :: DxDIR,DyDIR
  INTEGER(4)      , INTENT(IN)     :: fldID
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE            ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1,CSPACE2

  fDIM=SHAPE(f)

  IF(LEN(CSPACE).LT.2) THEN
   CSPACE1=CSPACE(1:1)
   IF(CSPACE1.EQ."x".OR.CSPACE1.EQ."X") THEN
    CSPACE2="x"
   ELSE IF(CSPACE1.EQ."y".OR.CSPACE1.EQ."Y") THEN
    CSPACE2="y"
   ELSE IF(CSPACE1.EQ."z".OR.CSPACE1.EQ."Z") THEN
    CSPACE2="z"
   END IF
  ELSE IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, DfDg: NUMBER OF CURRENT SPACE ARE TOO MANY!"
   STOP
  END IF

  IF(PSMDSCHEME(fldID).OR.XPSMDSCHEME(fldID).OR.YPSMDSCHEME(fldID).OR.ZPSMDSCHEME(fldID)) THEN
   ALLOCATE(kf(fDIM(1)/2+1,fDIM(2)))
   ALLOCATE(kg(fDIM(1)/2+1,fDIM(2)))
   ALLOCATE(likx(fDIM(1)/2+1,fDIM(2)))
   ALLOCATE(liky(fDIM(1)/2+1,fDIM(2)))
   ALLOCATE(kfxgy(fDIM(1)/2+1,fDIM(2)))
   CALL KGRIDBUILDER(LX2D,likx)
   CALL KGRIDBUILDER(LY2D,liky)
   CALL FFTW(f,kf)
   CALL FFTW(g,kg)
   CALL DfDg(kf,kg,likx,liky,kfxgy,fldID,CSPACE)
   CALL iFFTW(kfxgy,rfxgy)
  ELSE
   IF(ALLOCATED(rfx)) DEALLOCATE(rfx)
   IF(ALLOCATED(rgy)) DEALLOCATE(rgy)
   ALLOCATE(rfx(fDIM(1),fDIM(2)))
   ALLOCATE(rgy(fDIM(1),fDIM(2)))
   CALL Df(f,LX2D,rfx,1,fldID,CSPACE1)
   CALL Df(g,LY2D,rgy,1,fldID,CSPACE2)
   rfxgy=rfx*rgy
  END IF

  RETURN
 END SUBROUTINE r4r4r4DfDg2D

 SUBROUTINE r8r4c8DfDg2DNONE(f,g,LX2D,LY2D,kfxgy)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX2D(:,:),LY2D(:,:)
  REAL(8),    INTENT(IN)           :: f(:,:),g(:,:)
  COMPLEX(8), INTENT(OUT)          :: kfxgy(:,:)

  CALL DfDg(f,g,LX2D,LY2D,kfxgy,1,"xy")

  RETURN
 END SUBROUTINE r8r4c8DfDg2DNONE

 SUBROUTINE r8r4c8DfDg2D1INT(f,g,LX2D,LY2D,kfxgy,fldID)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX2D(:,:),LY2D(:,:)
  REAL(8),    INTENT(IN)           :: f(:,:),g(:,:)
  COMPLEX(8), INTENT(OUT)          :: kfxgy(:,:)
  INTEGER(4), INTENT(IN)           :: fldID

  CALL DfDg(f,g,LX2D,LY2D,kfxgy,fldID,"xy")
   
  RETURN
 END SUBROUTINE r8r4c8DfDg2D1INT
    
 SUBROUTINE r8r4c8DfDg2D1CHR(f,g,LX2D,LY2D,kfxgy,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX2D(:,:),LY2D(:,:)
  REAL(8),          INTENT(IN)     :: f(:,:),g(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
   
  CALL DfDg(f,g,LX2D,LY2D,kfxgy,1,CSPACE)
  
  RETURN
 END SUBROUTINE r8r4c8DfDg2D1CHR
  
 SUBROUTINE r8r4c8DfDg2D(f,g,LX2D,LY2D,kfxgy,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX2D(:,:),LY2D(:,:)
  REAL(8),          INTENT(IN)     :: f(:,:),g(:,:)
  REAL(8),          ALLOCATABLE    :: rfxgy(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:,:)
  COMPLEX(8),       ALLOCATABLE    :: kf(:,:),kg(:,:)
  COMPLEX(8),       ALLOCATABLE    :: likx(:,:),liky(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
  INTEGER(4),       INTENT(IN)     :: fldID
  INTEGER(4)                       :: MATDIMS(2)

  MATDIMS=SHAPE(f)

  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(MATDIMS(1)/2+1,MATDIMS(2)))
  IF(ALLOCATED(kg).EQV..FALSE.)   ALLOCATE(kg(MATDIMS(1)/2+1,MATDIMS(2)))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(MATDIMS(1)/2+1,MATDIMS(2)))
  IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(MATDIMS(1)/2+1,MATDIMS(2)))

  CALL KGRIDBUILDER(LX2D,likx)
  CALL KGRIDBUILDER(LY2D,liky)
  CALL FFTW(f,kf)
  CALL FFTW(g,kg)
  CALL DfDg(kf,kg,likx,liky,kfxgy,fldID,CSPACE)

  RETURN
 END SUBROUTINE r8r4c8DfDg2D

 SUBROUTINE r8r8c8DfDg2DNONE(f,g,LX2D,LY2D,kfxgy)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)           :: LX2D(:,:),LY2D(:,:)
  REAL(8),    INTENT(IN)           :: f(:,:),g(:,:)
  COMPLEX(8), INTENT(OUT)          :: kfxgy(:,:)

  CALL DfDg(f,g,LX2D,LY2D,kfxgy,1,"xy")

  RETURN
 END SUBROUTINE r8r8c8DfDg2DNONE

 SUBROUTINE r8r8c8DfDg2D1INT(f,g,LX2D,LY2D,kfxgy,fldID)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)           :: LX2D(:,:),LY2D(:,:)
  REAL(8),    INTENT(IN)           :: f(:,:),g(:,:)
  COMPLEX(8), INTENT(OUT)          :: kfxgy(:,:)
  INTEGER(4), INTENT(IN)           :: fldID

  CALL DfDg(f,g,LX2D,LY2D,kfxgy,fldID,"xy")
   
  RETURN
 END SUBROUTINE r8r8c8DfDg2D1INT
    
 SUBROUTINE r8r8c8DfDg2D1CHR(f,g,LX2D,LY2D,kfxgy,CSPACE)
  IMPLICIT NONE
  REAL(8),          INTENT(IN)     :: LX2D(:,:),LY2D(:,:)
  REAL(8),          INTENT(IN)     :: f(:,:),g(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
   
  CALL DfDg(f,g,LX2D,LY2D,kfxgy,1,CSPACE)
  
  RETURN
 END SUBROUTINE r8r8c8DfDg2D1CHR
  
 SUBROUTINE r8r8c8DfDg2D(f,g,LX2D,LY2D,kfxgy,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8),          INTENT(IN)     :: LX2D(:,:),LY2D(:,:)
  REAL(8),          INTENT(IN)     :: f(:,:),g(:,:)
  REAL(8),          ALLOCATABLE    :: rfxgy(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:,:)
  COMPLEX(8),       ALLOCATABLE    :: kf(:,:),kg(:,:)
  COMPLEX(8),       ALLOCATABLE    :: likx(:,:),liky(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
  INTEGER(4),       INTENT(IN)     :: fldID
  INTEGER(4)                       :: MATDIMS(2)

  MATDIMS=SHAPE(f)

  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(MATDIMS(1)/2+1,MATDIMS(2)))
  IF(ALLOCATED(kg).EQV..FALSE.)   ALLOCATE(kg(MATDIMS(1)/2+1,MATDIMS(2)))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(MATDIMS(1)/2+1,MATDIMS(2)))
  IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(MATDIMS(1)/2+1,MATDIMS(2)))

  CALL KGRIDBUILDER(LX2D,likx)
  CALL KGRIDBUILDER(LY2D,liky)
  CALL FFTW(f,kf)
  CALL FFTW(g,kg)
  CALL DfDg(kf,kg,likx,liky,kfxgy,fldID,CSPACE)

  RETURN
 END SUBROUTINE r8r8c8DfDg2D

 SUBROUTINE r8r4r8DfDg2DNONE(f,g,LX2D,LY2D,rfxgy)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:),g(:,:)
  REAL(8), INTENT(OUT)             :: rfxgy(:,:)

  CALL DfDg(f,g,LX2D,LY2D,rfxgy,1,"xy")

  RETURN
 END SUBROUTINE r8r4r8DfDg2DNONE

 SUBROUTINE r8r4r8DfDg2D1INT(f,g,LX2D,LY2D,rfxgy,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:),g(:,:)
  REAL(8), INTENT(OUT)             :: rfxgy(:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL DfDg(f,g,LX2D,LY2D,rfxgy,fldID,"xy")

  RETURN
 END SUBROUTINE r8r4r8DfDg2D1INT

 SUBROUTINE r8r4r8DfDg2D1CHR(f,g,LX2D,LY2D,rfxgy,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:),g(:,:)
  REAL(8), INTENT(OUT)             :: rfxgy(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL DfDg(f,g,LX2D,LY2D,rfxgy,1,CSPACE)

  RETURN
 END SUBROUTINE r8r4r8DfDg2D1CHR

 SUBROUTINE r8r4r8DfDg2D(f,g,LX2D,LY2D,rfxgy,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: f(:,:),g(:,:)
  REAL(8), INTENT(OUT)             :: rfxgy(:,:)
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8),    ALLOCATABLE          :: rfx(:,:),rgy(:,:)
  COMPLEX(8), ALLOCATABLE          :: kf(:,:),kg(:,:),likx(:,:),liky(:,:)
  COMPLEX(8), ALLOCATABLE          :: Kfxgy(:,:)
  INTEGER(4)                       :: fDIM(2)
  INTEGER(4)                       :: DxDIR,DyDIR
  INTEGER(4)      , INTENT(IN)     :: fldID
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE            ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1,CSPACE2

  fDIM=SHAPE(f)

  IF(LEN(CSPACE).LT.2) THEN
   CSPACE1=CSPACE(1:1)
   IF(CSPACE1.EQ."x".OR.CSPACE1.EQ."X") THEN
    CSPACE2="x"
   ELSE IF(CSPACE1.EQ."y".OR.CSPACE1.EQ."Y") THEN
    CSPACE2="y"
   ELSE IF(CSPACE1.EQ."z".OR.CSPACE1.EQ."Z") THEN
    CSPACE2="z"
   END IF
  ELSE IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, DfDg: NUMBER OF CURRENT SPACE ARE TOO MANY!"
   STOP
  END IF

  IF(PSMDSCHEME(fldID).OR.XPSMDSCHEME(fldID).OR.YPSMDSCHEME(fldID).OR.ZPSMDSCHEME(fldID)) THEN
   ALLOCATE(kf(fDIM(1)/2+1,fDIM(2)))
   ALLOCATE(kg(fDIM(1)/2+1,fDIM(2)))
   ALLOCATE(likx(fDIM(1)/2+1,fDIM(2)))
   ALLOCATE(liky(fDIM(1)/2+1,fDIM(2)))
   ALLOCATE(kfxgy(fDIM(1)/2+1,fDIM(2)))
   CALL KGRIDBUILDER(LX2D,likx)
   CALL KGRIDBUILDER(LY2D,liky)
   CALL FFTW(f,kf)
   CALL FFTW(g,kg)
   CALL DfDg(kf,kg,likx,liky,kfxgy,fldID,CSPACE)
   CALL iFFTW(kfxgy,rfxgy)
  ELSE
   IF(ALLOCATED(rfx)) DEALLOCATE(rfx)
   IF(ALLOCATED(rgy)) DEALLOCATE(rgy)
   ALLOCATE(rfx(fDIM(1),fDIM(2)))
   ALLOCATE(rgy(fDIM(1),fDIM(2)))
   CALL Df(f,LX2D,rfx,1,fldID,CSPACE1)
   CALL Df(g,LY2D,rgy,1,fldID,CSPACE2)
   rfxgy=rfx*rgy
  END IF

  RETURN
 END SUBROUTINE r8r4r8DfDg2D

 SUBROUTINE r8r8r8DfDg2DNONE(f,g,LX2D,LY2D,rfxgy)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:),g(:,:)
  REAL(8), INTENT(OUT)             :: rfxgy(:,:)

  CALL DfDg(f,g,LX2D,LY2D,rfxgy,1,"xy")

  RETURN
 END SUBROUTINE r8r8r8DfDg2DNONE

 SUBROUTINE r8r8r8DfDg2D1INT(f,g,LX2D,LY2D,rfxgy,fldID)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:),g(:,:)
  REAL(8), INTENT(OUT)             :: rfxgy(:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL DfDg(f,g,LX2D,LY2D,rfxgy,fldID,"xy")

  RETURN
 END SUBROUTINE r8r8r8DfDg2D1INT

 SUBROUTINE r8r8r8DfDg2D1CHR(f,g,LX2D,LY2D,rfxgy,CSPACE)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:),g(:,:)
  REAL(8), INTENT(OUT)             :: rfxgy(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL DfDg(f,g,LX2D,LY2D,rfxgy,1,CSPACE)

  RETURN
 END SUBROUTINE r8r8r8DfDg2D1CHR

 SUBROUTINE r8r8r8DfDg2D(f,g,LX2D,LY2D,rfxgy,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:),g(:,:)
  REAL(8), INTENT(OUT)             :: rfxgy(:,:)
  REAL(8),    ALLOCATABLE          :: rfx(:,:),rgy(:,:)
  COMPLEX(8), ALLOCATABLE          :: kf(:,:),kg(:,:),likx(:,:),liky(:,:)
  COMPLEX(8), ALLOCATABLE          :: Kfxgy(:,:)
  INTEGER(4)                       :: fDIM(2)
  INTEGER(4)                       :: DxDIR,DyDIR
  INTEGER(4)      , INTENT(IN)     :: fldID
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE            ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1,CSPACE2

  fDIM=SHAPE(f)

  IF(LEN(CSPACE).LT.2) THEN
   CSPACE1=CSPACE(1:1)
   IF(CSPACE1.EQ."x".OR.CSPACE1.EQ."X") THEN
    CSPACE2="x"
   ELSE IF(CSPACE1.EQ."y".OR.CSPACE1.EQ."Y") THEN
    CSPACE2="y"
   ELSE IF(CSPACE1.EQ."z".OR.CSPACE1.EQ."Z") THEN
    CSPACE2="z"
   END IF
  ELSE IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, DfDg: NUMBER OF CURRENT SPACE ARE TOO MANY!"
   STOP
  END IF

  IF(PSMDSCHEME(fldID).OR.XPSMDSCHEME(fldID).OR.YPSMDSCHEME(fldID).OR.ZPSMDSCHEME(fldID)) THEN
   ALLOCATE(kf(fDIM(1)/2+1,fDIM(2)))
   ALLOCATE(kg(fDIM(1)/2+1,fDIM(2)))
   ALLOCATE(likx(fDIM(1)/2+1,fDIM(2)))
   ALLOCATE(liky(fDIM(1)/2+1,fDIM(2)))
   ALLOCATE(kfxgy(fDIM(1)/2+1,fDIM(2)))
   CALL KGRIDBUILDER(LX2D,likx)
   CALL KGRIDBUILDER(LY2D,liky)
   CALL FFTW(f,kf)
   CALL FFTW(g,kg)
   CALL DfDg(kf,kg,likx,liky,kfxgy,fldID,CSPACE)
   CALL iFFTW(kfxgy,rfxgy)
  ELSE
   IF(ALLOCATED(rfx)) DEALLOCATE(rfx)
   IF(ALLOCATED(rgy)) DEALLOCATE(rgy)
   ALLOCATE(rfx(fDIM(1),fDIM(2)))
   ALLOCATE(rgy(fDIM(1),fDIM(2)))
   CALL Df(f,LX2D,rfx,1,fldID,CSPACE1)
   CALL Df(g,LY2D,rgy,1,fldID,CSPACE2)
   rfxgy=rfx*rgy
  END IF

  RETURN
 END SUBROUTINE r8r8r8DfDg2D

 SUBROUTINE c8c8c8DfDg3DNONE(kf,kg,likx,liky,kfxgy)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:,:,:),liky(:,:,:)
  COMPLEX(8),       INTENT(IN)     :: kf(:,:,:),kg(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:,:,:)

  CALL DfDg(kf,kg,likx,liky,kfxgy,1,"xyz")

  RETURN
 END SUBROUTINE c8c8c8DfDg3DNONE

 SUBROUTINE c8c8c8DfDg3D1INT(kf,kg,likx,liky,kfxgy,fldID)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:,:,:),liky(:,:,:)
  COMPLEX(8),       INTENT(IN)     :: kf(:,:,:),kg(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:,:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL DfDg(kf,kg,likx,liky,kfxgy,fldID,"xyz")

  RETURN
 END SUBROUTINE c8c8c8DfDg3D1INT

 SUBROUTINE c8c8c8DfDg3D1CHR(kf,kg,likx,liky,kfxgy,CSPACE)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:,:,:),liky(:,:,:)
  COMPLEX(8),       INTENT(IN)     :: kf(:,:,:),kg(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL DfDg(kf,kg,likx,liky,kfxgy,1,CSPACE)

  RETURN
 END SUBROUTINE c8c8c8DfDg3D1CHR

 SUBROUTINE c8c8c8DfDg3D(kf,kg,likx,liky,kfxgy,fldID,CSPACE)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)  :: likx(:,:,:),liky(:,:,:)
  COMPLEX(8),       INTENT(IN)  :: kf(:,:,:),kg(:,:,:)
  COMPLEX(8),       INTENT(OUT) :: kfxgy(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: kfx(:,:,:),kgy(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: exkfx3d(:,:,:),exkgy3d(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: exkfxgy3d(:,:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: D1MAT13,D2MAT13,D3MAT13,fDIMS(3)
  INTEGER(4)                    :: DxDIR
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE    ! CURRENT SPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2,CSPACE3
  REAL(8),          ALLOCATABLE :: rfxgy(:,:,:)
  REAL(8),          ALLOCATABLE :: exrfxgy3d(:,:,:)
  REAL(8),          ALLOCATABLE :: rfx(:,:,:),rgy(:,:,:)
  REAL(8),          ALLOCATABLE :: exrfx3d(:,:,:),exrgy3d(:,:,:)

  fDIMS=SHAPE(kf)
  D1MAT13=(fDIMS(1)-1)/3
  D2MAT13=(fDIMS(2)-1)/3
  D3MAT13=(fDIMS(3)-1)/3

  IF(LEN(CSPACE).LT.3) THEN
   PRINT*, "ERROR, DfDg: NUMBER OF CURRENT SPACES ARE NOT ENOUGH!"
   STOP
  ELSE IF(LEN(CSPACE).EQ.3) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   CSPACE3=CSPACE(3:3)
  ELSE IF(LEN(CSPACE).GT.3) THEN
   PRINT*, "ERROR, DfDg: NUMBER OF CURRENT SPACES ARE TOO MANY!"
   STOP
  END IF

   IF(ALLOCATED(kfx).EQV..FALSE.)       ALLOCATE(kfx(fDIMS(1),fDIMS(2),fDIMS(3)))
   IF(ALLOCATED(kgy).EQV..FALSE.)       ALLOCATE(kgy(fDIMS(1),fDIMS(2),fDIMS(3)))
   IF(ALLOCATED(exkfxgy3d).EQV..FALSE.) ALLOCATE(exkfxgy3d(fDIMS(1)+D1MAT13,fDIMS(2)+D2MAT13,fDIMS(3)+D3MAT13))
   IF(ALLOCATED(exkfx3d).EQV..FALSE.)   ALLOCATE(exkfx3d(  fDIMS(1)+D1MAT13,fDIMS(2)+D2MAT13,fDIMS(3)+D3MAT13))    
   IF(ALLOCATED(exkgy3d).EQV..FALSE.)   ALLOCATE(exkgy3d(  fDIMS(1)+D1MAT13,fDIMS(2)+D2MAT13,fDIMS(3)+D3MAT13))
   IF(ALLOCATED(exrfxgy3d).EQV..FALSE.) ALLOCATE(exrfxgy3d(2*(fDIMS(1)+D1MAT13-1),fDIMS(2)+D2MAT13,fDIMS(3)+D3MAT13))
   IF(ALLOCATED(exrfx3d).EQV..FALSE.)   ALLOCATE(exrfx3d(  2*(fDIMS(1)+D1MAT13-1),fDIMS(2)+D2MAT13,fDIMS(3)+D3MAT13))
   IF(ALLOCATED(exrgy3d).EQV..FALSE.)   ALLOCATE(exrgy3d(  2*(fDIMS(1)+D1MAT13-1),fDIMS(2)+D2MAT13,fDIMS(3)+D3MAT13))

   kfx=0.0d0;kgy=0.0d0
   exkfx3d=0.0d0;exkgy3d=0.0d0
   exrfxgy3d=0.0d0
   exrfx3d=0.0d0;exrgy3d=0.0d0

   CALL Df(kf,likx,kfx,1,fldID,CSPACE)
   CALL addFFTalias(kfx,exkfx3d)
   CALL iFFTW(exkfx3d,exrfx3d)

   CALL Df(kg,liky,kgy,1,fldID,CSPACE)
   CALL addFFTalias(kgy,exkgy3d)
   CALL iFFTW(exkgy3d,exrgy3d)

   exrfxgy3d=exrfxgy3d+exrfx3d*exrgy3d
   CALL FFTW(exrfxgy3d,exkfxgy3d)
   CALL rmvFFTalias(exkfxgy3d,kfxgy)

  RETURN
 END SUBROUTINE c8c8c8DfDg3D

 SUBROUTINE r4r4c8DfDg3DNONE(f,g,LX3D,LY3D,kfxgy)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(4),    INTENT(IN)           :: f(:,:,:),g(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: kfxgy(:,:,:)

  CALL DfDg(f,g,LX3D,LY3D,kfxgy,1,"xy")

  RETURN
 END SUBROUTINE r4r4c8DfDg3DNONE

 SUBROUTINE r4r4c8DfDg3D1INT(f,g,LX3D,LY3D,kfxgy,fldID)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(4),    INTENT(IN)           :: f(:,:,:),g(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: kfxgy(:,:,:)
  INTEGER(4), INTENT(IN)           :: fldID

  CALL DfDg(f,g,LX3D,LY3D,kfxgy,fldID,"xy")
   
  RETURN
 END SUBROUTINE r4r4c8DfDg3D1INT
    
 SUBROUTINE r4r4c8DfDg3D1CHR(f,g,LX3D,LY3D,kfxgy,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(4),          INTENT(IN)     :: f(:,:,:),g(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
   
  CALL DfDg(f,g,LX3D,LY3D,kfxgy,1,CSPACE)
  
  RETURN
 END SUBROUTINE r4r4c8DfDg3D1CHR
  
 SUBROUTINE r4r4c8DfDg3D(f,g,LX3D,LY3D,kfxgy,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(4),          INTENT(IN)     :: f(:,:,:),g(:,:,:)
  REAL(4),          ALLOCATABLE    :: rfxgy(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:,:,:)
  COMPLEX(8),       ALLOCATABLE    :: kf(:,:,:),kg(:,:,:)
  COMPLEX(8),       ALLOCATABLE    :: likx(:,:,:),liky(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
  INTEGER(4),       INTENT(IN)     :: fldID
  INTEGER(4)                       :: MATDIMS(3)

  MATDIMS=SHAPE(f)

  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(MATDIMS(1)/2+1,MATDIMS(2),MATDIMS(3)))
  IF(ALLOCATED(kg).EQV..FALSE.)   ALLOCATE(kg(MATDIMS(1)/2+1,MATDIMS(2),MATDIMS(3)))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(MATDIMS(1)/2+1,MATDIMS(2),MATDIMS(3)))
  IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(MATDIMS(1)/2+1,MATDIMS(2),MATDIMS(3)))

  CALL KGRIDBUILDER(LX3D,likx)
  CALL KGRIDBUILDER(LY3D,liky)
  CALL FFTW(f,kf)
  CALL FFTW(g,kg)
  CALL DfDg(kf,kg,likx,liky,kfxgy,fldID,CSPACE)

  RETURN
 END SUBROUTINE r4r4c8DfDg3D

 SUBROUTINE r4r4r4DfDg3DNONE(f,g,LX3D,LY3D,rfxgy)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(4), INTENT(IN)              :: f(:,:,:),g(:,:,:)
  REAL(4), INTENT(OUT)             :: rfxgy(:,:,:)

  CALL DfDg(f,g,LX3D,LY3D,rfxgy,1,"xy")

  RETURN
 END SUBROUTINE r4r4r4DfDg3DNONE

 SUBROUTINE r4r4r4DfDg3D1INT(f,g,LX3D,LY3D,rfxgy,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(4), INTENT(IN)              :: f(:,:,:),g(:,:,:)
  REAL(4), INTENT(OUT)             :: rfxgy(:,:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL DfDg(f,g,LX3D,LY3D,rfxgy,fldID,"xy")
  
  RETURN
 END SUBROUTINE r4r4r4DfDg3D1INT   
  
 SUBROUTINE r4r4r4DfDg3D1CHR(f,g,LX3D,LY3D,rfxgy,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(4), INTENT(IN)              :: f(:,:,:),g(:,:,:)
  REAL(4), INTENT(OUT)             :: rfxgy(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL DfDg(f,g,LX3D,LY3D,rfxgy,1,CSPACE)

  RETURN
 END SUBROUTINE r4r4r4DfDg3D1CHR

 SUBROUTINE r4r4r4DfDg3D(f,g,LX3D,LY3D,rfxgy,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: f(:,:,:),g(:,:,:)
  REAL(4), INTENT(OUT)             :: rfxgy(:,:,:)
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(4),    ALLOCATABLE          :: rfx(:,:,:),rgy(:,:,:)
  COMPLEX(8), ALLOCATABLE          :: kf(:,:,:),kg(:,:,:),likx(:,:,:),liky(:,:,:)
  COMPLEX(8), ALLOCATABLE          :: kfxgy(:,:,:)
  INTEGER(4)                       :: fDIM(3)
  INTEGER(4)                       :: DxDIR,DyDIR
  INTEGER(4)      , INTENT(IN)     :: fldID
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE            ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1,CSPACE2

  fDIM=SHAPE(f)

  IF(LEN(CSPACE).LT.2) THEN
   CSPACE1=CSPACE(1:1)
   IF(CSPACE1.EQ."x".OR.CSPACE1.EQ."X") THEN
    CSPACE2="x"
   ELSE IF(CSPACE1.EQ."y".OR.CSPACE1.EQ."Y") THEN
    CSPACE2="y"
   ELSE IF(CSPACE1.EQ."z".OR.CSPACE1.EQ."Z") THEN
    CSPACE2="z"
   END IF
  ELSE IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, DfDg: NUMBER OF CURRENT SPACE ARE TOO MANY!"
   STOP
  END IF

  IF(PSMDSCHEME(fldID).OR.XPSMDSCHEME(fldID).OR.YPSMDSCHEME(fldID).OR.ZPSMDSCHEME(fldID)) THEN
   ALLOCATE(kf(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   ALLOCATE(kg(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   ALLOCATE(likx(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   ALLOCATE(liky(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   ALLOCATE(kfxgy(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   CALL KGRIDBUILDER(LX3D,likx)
   CALL KGRIDBUILDER(LY3D,liky)
   CALL FFTW(f,kf)
   CALL FFTW(g,kg)
   CALL DfDg(kf,kg,likx,liky,kfxgy,fldID,CSPACE)
   CALL iFFTW(kfxgy,rfxgy)
  ELSE
   IF(ALLOCATED(rfx)) DEALLOCATE(rfx)
   IF(ALLOCATED(rgy)) DEALLOCATE(rgy)
   ALLOCATE(rfx(fDIM(1),fDIM(2),fDIM(3)))
   ALLOCATE(rgy(fDIM(1),fDIM(2),fDIM(3)))
   CALL Df(f,LX3D,rfx,1,fldID,CSPACE1)
   CALL Df(g,LY3D,rgy,1,fldID,CSPACE2)
   rfxgy=rfx*rgy
  END IF

  RETURN
 END SUBROUTINE r4r4r4DfDg3D

 SUBROUTINE r8r4c8DfDg3DNONE(f,g,LX3D,LY3D,kfxgy)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8),    INTENT(IN)           :: f(:,:,:),g(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: kfxgy(:,:,:)

  CALL DfDg(f,g,LX3D,LY3D,kfxgy,1,"xy")

  RETURN
 END SUBROUTINE r8r4c8DfDg3DNONE

 SUBROUTINE r8r4c8DfDg3D1INT(f,g,LX3D,LY3D,kfxgy,fldID)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8),    INTENT(IN)           :: f(:,:,:),g(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: kfxgy(:,:,:)
  INTEGER(4), INTENT(IN)           :: fldID

  CALL DfDg(f,g,LX3D,LY3D,kfxgy,fldID,"xy")
   
  RETURN
 END SUBROUTINE r8r4c8DfDg3D1INT
    
 SUBROUTINE r8r4c8DfDg3D1CHR(f,g,LX3D,LY3D,kfxgy,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8),          INTENT(IN)     :: f(:,:,:),g(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
   
  CALL DfDg(f,g,LX3D,LY3D,kfxgy,1,CSPACE)
  
  RETURN
 END SUBROUTINE r8r4c8DfDg3D1CHR
  
 SUBROUTINE r8r4c8DfDg3D(f,g,LX3D,LY3D,kfxgy,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8),          INTENT(IN)     :: f(:,:,:),g(:,:,:)
  REAL(8),          ALLOCATABLE    :: rfxgy(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:,:,:)
  COMPLEX(8),       ALLOCATABLE    :: kf(:,:,:),kg(:,:,:)
  COMPLEX(8),       ALLOCATABLE    :: likx(:,:,:),liky(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
  INTEGER(4),       INTENT(IN)     :: fldID
  INTEGER(4)                       :: MATDIMS(3)

  MATDIMS=SHAPE(f)

  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(MATDIMS(1)/2+1,MATDIMS(2),MATDIMS(3)))
  IF(ALLOCATED(kg).EQV..FALSE.)   ALLOCATE(kg(MATDIMS(1)/2+1,MATDIMS(2),MATDIMS(3)))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(MATDIMS(1)/2+1,MATDIMS(2),MATDIMS(3)))
  IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(MATDIMS(1)/2+1,MATDIMS(2),MATDIMS(3)))

  CALL KGRIDBUILDER(LX3D,likx)
  CALL KGRIDBUILDER(LY3D,liky)
  CALL FFTW(f,kf)
  CALL FFTW(g,kg)
  CALL DfDg(kf,kg,likx,liky,kfxgy,fldID,CSPACE)

  RETURN
 END SUBROUTINE r8r4c8DfDg3D

 SUBROUTINE r8r8c8DfDg3DNONE(f,g,LX3D,LY3D,kfxgy)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)           :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8),    INTENT(IN)           :: f(:,:,:),g(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: kfxgy(:,:,:)

  CALL DfDg(f,g,LX3D,LY3D,kfxgy,1,"xy")

  RETURN
 END SUBROUTINE r8r8c8DfDg3DNONE

 SUBROUTINE r8r8c8DfDg3D1INT(f,g,LX3D,LY3D,kfxgy,fldID)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)           :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8),    INTENT(IN)           :: f(:,:,:),g(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: kfxgy(:,:,:)
  INTEGER(4), INTENT(IN)           :: fldID

  CALL DfDg(f,g,LX3D,LY3D,kfxgy,fldID,"xy")
   
  RETURN
 END SUBROUTINE r8r8c8DfDg3D1INT
    
 SUBROUTINE r8r8c8DfDg3D1CHR(f,g,LX3D,LY3D,kfxgy,CSPACE)
  IMPLICIT NONE
  REAL(8),          INTENT(IN)     :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8),          INTENT(IN)     :: f(:,:,:),g(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
   
  CALL DfDg(f,g,LX3D,LY3D,kfxgy,1,CSPACE)
  
  RETURN
 END SUBROUTINE r8r8c8DfDg3D1CHR
  
 SUBROUTINE r8r8c8DfDg3D(f,g,LX3D,LY3D,kfxgy,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8),          INTENT(IN)     :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8),          INTENT(IN)     :: f(:,:,:),g(:,:,:)
  REAL(8),          ALLOCATABLE    :: rfxgy(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:,:,:)
  COMPLEX(8),       ALLOCATABLE    :: kf(:,:,:),kg(:,:,:)
  COMPLEX(8),       ALLOCATABLE    :: likx(:,:,:),liky(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
  INTEGER(4),       INTENT(IN)     :: fldID
  INTEGER(4)                       :: MATDIMS(3)

  MATDIMS=SHAPE(f)

  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(MATDIMS(1)/2+1,MATDIMS(2),MATDIMS(3)))
  IF(ALLOCATED(kg).EQV..FALSE.)   ALLOCATE(kg(MATDIMS(1)/2+1,MATDIMS(2),MATDIMS(3)))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(MATDIMS(1)/2+1,MATDIMS(2),MATDIMS(3)))
  IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(MATDIMS(1)/2+1,MATDIMS(2),MATDIMS(3)))

  CALL KGRIDBUILDER(LX3D,likx)
  CALL KGRIDBUILDER(LY3D,liky)
  CALL FFTW(f,kf)
  CALL FFTW(g,kg)
  CALL DfDg(kf,kg,likx,liky,kfxgy,fldID,CSPACE)

  RETURN
 END SUBROUTINE r8r8c8DfDg3D

 SUBROUTINE r8r4r8DfDg3DNONE(f,g,LX3D,LY3D,rfxgy)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:),g(:,:,:)
  REAL(8), INTENT(OUT)             :: rfxgy(:,:,:)

  CALL DfDg(f,g,LX3D,LY3D,rfxgy,1,"xy")

  RETURN
 END SUBROUTINE r8r4r8DfDg3DNONE

 SUBROUTINE r8r4r8DfDg3D1INT(f,g,LX3D,LY3D,rfxgy,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:),g(:,:,:)
  REAL(8), INTENT(OUT)             :: rfxgy(:,:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL DfDg(f,g,LX3D,LY3D,rfxgy,fldID,"xy")

  RETURN
 END SUBROUTINE r8r4r8DfDg3D1INT

 SUBROUTINE r8r4r8DfDg3D1CHR(f,g,LX3D,LY3D,rfxgy,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:),g(:,:,:)
  REAL(8), INTENT(OUT)             :: rfxgy(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL DfDg(f,g,LX3D,LY3D,rfxgy,1,CSPACE)

  RETURN
 END SUBROUTINE r8r4r8DfDg3D1CHR

 SUBROUTINE r8r4r8DfDg3D(f,g,LX3D,LY3D,rfxgy,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: f(:,:,:),g(:,:,:)
  REAL(8), INTENT(OUT)             :: rfxgy(:,:,:)
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8),    ALLOCATABLE          :: rfx(:,:,:),rgy(:,:,:)
  COMPLEX(8), ALLOCATABLE          :: kf(:,:,:),kg(:,:,:),likx(:,:,:),liky(:,:,:)
  COMPLEX(8), ALLOCATABLE          :: kfxgy(:,:,:)
  INTEGER(4)                       :: fDIM(3)
  INTEGER(4)                       :: DxDIR,DyDIR
  INTEGER(4)      , INTENT(IN)     :: fldID
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE            ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1,CSPACE2

  fDIM=SHAPE(f)

  IF(LEN(CSPACE).LT.2) THEN
   CSPACE1=CSPACE(1:1)
   IF(CSPACE1.EQ."x".OR.CSPACE1.EQ."X") THEN
    CSPACE2="x"
   ELSE IF(CSPACE1.EQ."y".OR.CSPACE1.EQ."Y") THEN
    CSPACE2="y"
   ELSE IF(CSPACE1.EQ."z".OR.CSPACE1.EQ."Z") THEN
    CSPACE2="z"
   END IF
  ELSE IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, DfDg: NUMBER OF CURRENT SPACE ARE TOO MANY!"
   STOP
  END IF

  IF(PSMDSCHEME(fldID).OR.XPSMDSCHEME(fldID).OR.YPSMDSCHEME(fldID).OR.ZPSMDSCHEME(fldID)) THEN
   ALLOCATE(kf(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   ALLOCATE(kg(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   ALLOCATE(likx(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   ALLOCATE(liky(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   ALLOCATE(kfxgy(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   CALL KGRIDBUILDER(LX3D,likx)
   CALL KGRIDBUILDER(LY3D,liky)
   CALL FFTW(f,kf)
   CALL FFTW(g,kg)
   CALL DfDg(kf,kg,likx,liky,kfxgy,fldID,CSPACE)
   CALL iFFTW(kfxgy,rfxgy)
  ELSE
   IF(ALLOCATED(rfx)) DEALLOCATE(rfx)
   IF(ALLOCATED(rgy)) DEALLOCATE(rgy)
   ALLOCATE(rfx(fDIM(1),fDIM(2),fDIM(3)))
   ALLOCATE(rgy(fDIM(1),fDIM(2),fDIM(3)))
   CALL Df(f,LX3D,rfx,1,fldID,CSPACE1)
   CALL Df(g,LY3D,rgy,1,fldID,CSPACE2)
   rfxgy=rfx*rgy
  END IF

  RETURN
 END SUBROUTINE r8r4r8DfDg3D

 SUBROUTINE r8r8r8DfDg3DNONE(f,g,LX3D,LY3D,rfxgy)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:),g(:,:,:)
  REAL(8), INTENT(OUT)             :: rfxgy(:,:,:)

  CALL DfDg(f,g,LX3D,LY3D,rfxgy,1,"xy")

  RETURN
 END SUBROUTINE r8r8r8DfDg3DNONE

 SUBROUTINE r8r8r8DfDg3D1INT(f,g,LX3D,LY3D,rfxgy,fldID)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:),g(:,:,:)
  REAL(8), INTENT(OUT)             :: rfxgy(:,:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL DfDg(f,g,LX3D,LY3D,rfxgy,fldID,"xy")

  RETURN
 END SUBROUTINE r8r8r8DfDg3D1INT

 SUBROUTINE r8r8r8DfDg3D1CHR(f,g,LX3D,LY3D,rfxgy,CSPACE)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:),g(:,:,:)
  REAL(8), INTENT(OUT)             :: rfxgy(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL DfDg(f,g,LX3D,LY3D,rfxgy,1,CSPACE)

  RETURN
 END SUBROUTINE r8r8r8DfDg3D1CHR

 SUBROUTINE r8r8r8DfDg3D(f,g,LX3D,LY3D,rfxgy,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:),g(:,:,:)
  REAL(8), INTENT(OUT)             :: rfxgy(:,:,:)
  REAL(8),    ALLOCATABLE          :: rfx(:,:,:),rgy(:,:,:)
  COMPLEX(8), ALLOCATABLE          :: kf(:,:,:),kg(:,:,:),likx(:,:,:),liky(:,:,:)
  COMPLEX(8), ALLOCATABLE          :: kfxgy(:,:,:)
  INTEGER(4)                       :: fDIM(3)
  INTEGER(4)                       :: DxDIR,DyDIR
  INTEGER(4)      , INTENT(IN)     :: fldID
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE            ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1,CSPACE2

  fDIM=SHAPE(f)

  IF(LEN(CSPACE).LT.2) THEN
   CSPACE1=CSPACE(1:1)
   IF(CSPACE1.EQ."x".OR.CSPACE1.EQ."X") THEN
    CSPACE2="x"
   ELSE IF(CSPACE1.EQ."y".OR.CSPACE1.EQ."Y") THEN
    CSPACE2="y"
   ELSE IF(CSPACE1.EQ."z".OR.CSPACE1.EQ."Z") THEN
    CSPACE2="z"
   END IF
  ELSE IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, DfDg: NUMBER OF CURRENT SPACE ARE TOO MANY!"
   STOP
  END IF

  IF(PSMDSCHEME(fldID).OR.XPSMDSCHEME(fldID).OR.YPSMDSCHEME(fldID).OR.ZPSMDSCHEME(fldID)) THEN
   ALLOCATE(kf(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   ALLOCATE(kg(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   ALLOCATE(likx(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   ALLOCATE(liky(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   ALLOCATE(kfxgy(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   CALL KGRIDBUILDER(LX3D,likx)
   CALL KGRIDBUILDER(LY3D,liky)
   CALL FFTW(f,kf)
   CALL FFTW(g,kg)
   CALL DfDg(kf,kg,likx,liky,kfxgy,fldID,CSPACE)
   CALL iFFTW(kfxgy,rfxgy)
  ELSE
   IF(ALLOCATED(rfx)) DEALLOCATE(rfx)
   IF(ALLOCATED(rgy)) DEALLOCATE(rgy)
   ALLOCATE(rfx(fDIM(1),fDIM(2),fDIM(3)))
   ALLOCATE(rgy(fDIM(1),fDIM(2),fDIM(3)))
   CALL Df(f,LX3D,rfx,1,fldID,CSPACE1)
   CALL Df(g,LY3D,rgy,1,fldID,CSPACE2)
   rfxgy=rfx*rgy
  END IF

  RETURN
 END SUBROUTINE r8r8r8DfDg3D


!************ MULTIPLICATION OF THE GRADIENTS OF TWO FIELDS (GRADfGRADg) *******************
 SUBROUTINE c8c8c8GRADfGRADg1DNONE(kf,kg,likx,kfxgx)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:)
  COMPLEX(8),       INTENT(IN)     :: kf(:),kg(:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:)

  CALL GRADfGRADg(kf,kg,likx,kfxgx,1,"x")

  RETURN
 END SUBROUTINE c8c8c8GRADfGRADg1DNONE

 SUBROUTINE c8c8c8GRADfGRADg1D1INT(kf,kg,likx,kfxgx,fldID)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:)
  COMPLEX(8),       INTENT(IN)     :: kf(:),kg(:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL GRADfGRADg(kf,kg,likx,kfxgx,fldID,"x")

  RETURN
 END SUBROUTINE c8c8c8GRADfGRADg1D1INT

 SUBROUTINE c8c8c8GRADfGRADg1D1CHR(kf,kg,likx,kfxgx,CSPACE)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:)
  COMPLEX(8),       INTENT(IN)     :: kf(:),kg(:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL GRADfGRADg(kf,kg,likx,kfxgx,1,CSPACE)

  RETURN
 END SUBROUTINE c8c8c8GRADfGRADg1D1CHR

 SUBROUTINE c8c8c8GRADfGRADg1D(kf,kg,likx,kfxgx,fldID,CSPACE)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)  :: likx(:)
  COMPLEX(8),       INTENT(IN)  :: kf(:),kg(:)
  COMPLEX(8),       INTENT(OUT) :: kfxgx(:)
  COMPLEX(8),       ALLOCATABLE :: kfx(:),kgx(:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: fDIM
  INTEGER(4)                    :: DxDIR
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE    ! CURRENT SPACE
  CHARACTER(LEN=1)              :: CSPACE1
  REAL(4),          ALLOCATABLE :: rfxgx(:)
  REAL(4),          ALLOCATABLE :: rfx(:),rgx(:)

  fDIM=SIZE(kf)

  CSPACE1=CSPACE(1:1)

  CALL DfDg(kf,kg,likx,likx,kfxgx,fldID,CSPACE)

  RETURN
 END SUBROUTINE c8c8c8GRADfGRADg1D

 SUBROUTINE r4r4c8GRADfGRADg1DNONE(f,g,LX1D,kfxgx)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX1D(:)
  REAL(4),          INTENT(IN)     :: f(:),g(:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:)

  CALL GRADfGRADg(f,g,LX1D,kfxgx,1,"x")

  RETURN
 END SUBROUTINE r4r4c8GRADfGRADg1DNONE

 SUBROUTINE r4r4c8GRADfGRADg1D1INT(f,g,LX1D,kfxgx,fldID)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX1D(:)
  REAL(4),          INTENT(IN)     :: f(:),g(:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL GRADfGRADg(f,g,LX1D,kfxgx,fldID,"x")

  RETURN
 END SUBROUTINE r4r4c8GRADfGRADg1D1INT

 SUBROUTINE r4r4c8GRADfGRADg1D1CHR(f,g,LX1D,kfxgx,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX1D(:)
  REAL(4),          INTENT(IN)     :: f(:),g(:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL GRADfGRADg(f,g,LX1D,kfxgx,1,CSPACE)

  RETURN
 END SUBROUTINE r4r4c8GRADfGRADg1D1CHR

 SUBROUTINE r4r4c8GRADfGRADg1D(f,g,LX1D,kfxgx,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)  :: LX1D(:)
  REAL(4),          INTENT(IN)  :: f(:),g(:)
  COMPLEX(8),       INTENT(OUT) :: kfxgx(:)
  COMPLEX(8),       ALLOCATABLE :: kf(:),kg(:)
  COMPLEX(8),       ALLOCATABLE :: likx(:)
  INTEGER(4)                    :: fDIM
  INTEGER(4)                    :: DxDIR
  INTEGER(4),       INTENT(IN)  :: fldID
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE    ! CURRENT SPACE
  CHARACTER(LEN=1)              :: CSPACE1

  fDIM=SIZE(f)

  CSPACE1=CSPACE(1:1)

  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIM/2+1))
  IF(ALLOCATED(kg).EQV..FALSE.)   ALLOCATE(kg(fDIM/2+1))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIM/2+1))

  CALL KGRIDBUILDER(LX1D,likx)
  CALL FFTW(f,kf)
  CALL FFTW(g,kg)
  CALL GRADfGRADg(kf,kg,likx,kfxgx,fldID,CSPACE)

  RETURN
 END SUBROUTINE r4r4c8GRADfGRADg1D

 SUBROUTINE r4r4r4GRADfGRADg1DNONE(f,g,LX1D,rfxgx)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX1D(:)
  REAL(4), INTENT(IN)              :: f(:),g(:)
  REAL(4), INTENT(OUT)             :: rfxgx(:)

  CALL GRADfGRADg(f,g,LX1D,rfxgx,1,"x")

  RETURN
 END SUBROUTINE r4r4r4GRADfGRADg1DNONE

 SUBROUTINE r4r4r4GRADfGRADg1D1INT(f,g,LX1D,rfxgx,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX1D(:)
  REAL(4), INTENT(IN)              :: f(:),g(:)
  REAL(4), INTENT(OUT)             :: rfxgx(:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL GRADfGRADg(f,g,LX1D,rfxgx,fldID,"x")

  RETURN
 END SUBROUTINE r4r4r4GRADfGRADg1D1INT

 SUBROUTINE r4r4r4GRADfGRADg1D1CHR(f,g,LX1D,rfxgx,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX1D(:)
  REAL(4), INTENT(IN)              :: f(:),g(:)
  REAL(4), INTENT(OUT)             :: rfxgx(:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL GRADfGRADg(f,g,LX1D,rfxgx,1,CSPACE)

  RETURN
 END SUBROUTINE r4r4r4GRADfGRADg1D1CHR

 SUBROUTINE r4r4r4GRADfGRADg1D(f,g,LX1D,rfxgx,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)  :: LX1D(:)
  REAL(4),          INTENT(IN)  :: f(:),g(:)
  REAL(4),          INTENT(OUT) :: rfxgx(:)
  REAL(4),          ALLOCATABLE :: rfx(:),rgx(:)
  COMPLEX(8),       ALLOCATABLE :: kf(:),kg(:)
  COMPLEX(8),       ALLOCATABLE :: likx(:)
  COMPLEX(8),       ALLOCATABLE :: kfxgx(:)
  INTEGER(4)                    :: fDIM
  INTEGER(4)                    :: DxDIR
  INTEGER(4),       INTENT(IN)  :: fldID
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE    ! CURRENT SPACE
  CHARACTER(LEN=1)              :: CSPACE1

  fDIM=SIZE(f)

  CSPACE1=CSPACE(1:1)

  IF(PSMDSCHEME(fldID).OR.XPSMDSCHEME(fldID).OR.YPSMDSCHEME(fldID).OR.ZPSMDSCHEME(fldID)) THEN
   IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIM/2+1))
   IF(ALLOCATED(kg).EQV..FALSE.)   ALLOCATE(kg(fDIM/2+1))
   IF(ALLOCATED(likx).EQV..FALSE.)  ALLOCATE(likx(fDIM/2+1))
   IF(ALLOCATED(kfxgx).EQV..FALSE.) ALLOCATE(kfxgx(fDIM/2+1))
   CALL KGRIDBUILDER(LX1D,likx)
   CALL FFTW(f,kf)
   CALL FFTW(g,kg)
   CALL FFTW(rfxgx,kfxgx)
   CALL GRADfGRADg(kf,kg,likx,kfxgx,fldID,CSPACE)
   CALL iFFTW(kfxgx,rfxgx)
  ELSE
   ALLOCATE(rfx(fDIM))
   ALLOCATE(rgx(fDIM))
   CALL Df(f,LX1D,rfx,1,fldID,CSPACE1)
   CALL Df(g,LX1D,rgx,1,fldID,CSPACE1)
   rfxgx=rfx*rgx
  END IF

  RETURN
 END SUBROUTINE r4r4r4GRADfGRADg1D

 SUBROUTINE r8r4c8GRADfGRADg1DNONE(f,g,LX1D,kfxgx)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX1D(:)
  REAL(8),          INTENT(IN)     :: f(:),g(:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:)

  CALL GRADfGRADg(f,g,LX1D,kfxgx,1,"x")

  RETURN
 END SUBROUTINE r8r4c8GRADfGRADg1DNONE

 SUBROUTINE r8r4c8GRADfGRADg1D1INT(f,g,LX1D,kfxgx,fldID)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX1D(:)
  REAL(8),          INTENT(IN)     :: f(:),g(:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL GRADfGRADg(f,g,LX1D,kfxgx,fldID,"x")

  RETURN
 END SUBROUTINE r8r4c8GRADfGRADg1D1INT

 SUBROUTINE r8r4c8GRADfGRADg1D1CHR(f,g,LX1D,kfxgx,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX1D(:)
  REAL(8),          INTENT(IN)     :: f(:),g(:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL GRADfGRADg(f,g,LX1D,kfxgx,1,CSPACE)

  RETURN
 END SUBROUTINE r8r4c8GRADfGRADg1D1CHR

 SUBROUTINE r8r4c8GRADfGRADg1D(f,g,LX1D,kfxgx,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)  :: LX1D(:)
  REAL(8),          INTENT(IN)  :: f(:),g(:)
  COMPLEX(8),       INTENT(OUT) :: kfxgx(:)
  COMPLEX(8),       ALLOCATABLE :: kf(:),kg(:)
  COMPLEX(8),       ALLOCATABLE :: likx(:)
  INTEGER(4)                    :: fDIM
  INTEGER(4)                    :: DxDIR
  INTEGER(4),       INTENT(IN)  :: fldID
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE    ! CURRENT SPACE
  CHARACTER(LEN=1)              :: CSPACE1

  fDIM=SIZE(f)
  CSPACE1=CSPACE(1:1)

  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIM/2+1))
  IF(ALLOCATED(kg).EQV..FALSE.)   ALLOCATE(kg(fDIM/2+1))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIM/2+1))

  CALL KGRIDBUILDER(LX1D,likx)
  CALL FFTW(f,kf)
  CALL FFTW(g,kg)
  CALL GRADfGRADg(kf,kg,likx,kfxgx,fldID,CSPACE)

  RETURN
 END SUBROUTINE r8r4c8GRADfGRADg1D

 SUBROUTINE r8r8c8GRADfGRADg1DNONE(f,g,LX1D,kfxgx)
  IMPLICIT NONE
  REAL(8),          INTENT(IN)     :: LX1D(:)
  REAL(8),          INTENT(IN)     :: f(:),g(:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:)

  CALL GRADfGRADg(f,g,LX1D,kfxgx,1,"x")

  RETURN
 END SUBROUTINE r8r8c8GRADfGRADg1DNONE

 SUBROUTINE r8r8c8GRADfGRADg1D1INT(f,g,LX1D,kfxgx,fldID)
  IMPLICIT NONE
  REAL(8),          INTENT(IN)     :: LX1D(:)
  REAL(8),          INTENT(IN)     :: f(:),g(:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL GRADfGRADg(f,g,LX1D,kfxgx,fldID,"x")

  RETURN
 END SUBROUTINE r8r8c8GRADfGRADg1D1INT

 SUBROUTINE r8r8c8GRADfGRADg1D1CHR(f,g,LX1D,kfxgx,CSPACE)
  IMPLICIT NONE
  REAL(8),          INTENT(IN)     :: LX1D(:)
  REAL(8),          INTENT(IN)     :: f(:),g(:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL GRADfGRADg(f,g,LX1D,kfxgx,1,CSPACE)

  RETURN
 END SUBROUTINE r8r8c8GRADfGRADg1D1CHR

 SUBROUTINE r8r8c8GRADfGRADg1D(f,g,LX1D,kfxgx,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8),          INTENT(IN)  :: LX1D(:)
  REAL(8),          INTENT(IN)  :: f(:),g(:)
  COMPLEX(8),       INTENT(OUT) :: kfxgx(:)
  COMPLEX(8),       ALLOCATABLE :: kf(:),kg(:)
  COMPLEX(8),       ALLOCATABLE :: likx(:)
  INTEGER(4)                    :: fDIM
  INTEGER(4)                    :: DxDIR
  INTEGER(4),       INTENT(IN)  :: fldID
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE    ! CURRENT SPACE
  CHARACTER(LEN=1)              :: CSPACE1

  fDIM=SIZE(f)
  CSPACE1=CSPACE(1:1)

  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIM/2+1))
  IF(ALLOCATED(kg).EQV..FALSE.)   ALLOCATE(kg(fDIM/2+1))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIM/2+1))

  CALL KGRIDBUILDER(LX1D,likx)
  CALL FFTW(f,kf)
  CALL FFTW(g,kg)
  CALL GRADfGRADg(kf,kg,likx,kfxgx,fldID,CSPACE)

  RETURN
 END SUBROUTINE r8r8c8GRADfGRADg1D

 SUBROUTINE r8r4r8GRADfGRADg1DNONE(f,g,LX1D,rfxgx)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX1D(:)
  REAL(8), INTENT(IN)              :: f(:),g(:)
  REAL(8), INTENT(OUT)             :: rfxgx(:)

  CALL GRADfGRADg(f,g,LX1D,rfxgx,1,"x")

  RETURN
 END SUBROUTINE r8r4r8GRADfGRADg1DNONE

 SUBROUTINE r8r4r8GRADfGRADg1D1INT(f,g,LX1D,rfxgx,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX1D(:)
  REAL(8), INTENT(IN)              :: f(:),g(:)
  REAL(8), INTENT(OUT)             :: rfxgx(:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL GRADfGRADg(f,g,LX1D,rfxgx,fldID,"x")

  RETURN
 END SUBROUTINE r8r4r8GRADfGRADg1D1INT

 SUBROUTINE r8r4r8GRADfGRADg1D1CHR(f,g,LX1D,rfxgx,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX1D(:)
  REAL(8), INTENT(IN)              :: f(:),g(:)
  REAL(8), INTENT(OUT)             :: rfxgx(:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL GRADfGRADg(f,g,LX1D,rfxgx,1,CSPACE)

  RETURN
 END SUBROUTINE r8r4r8GRADfGRADg1D1CHR

 SUBROUTINE r8r4r8GRADfGRADg1D(f,g,LX1D,rfxgx,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)  :: LX1D(:)
  REAL(8),          INTENT(IN)  :: f(:),g(:)
  REAL(8),          INTENT(OUT) :: rfxgx(:)
  REAL(8),          ALLOCATABLE :: rfx(:),rgx(:)
  COMPLEX(8),       ALLOCATABLE :: kf(:),kg(:)
  COMPLEX(8),       ALLOCATABLE :: likx(:)
  COMPLEX(8),       ALLOCATABLE :: kfxgx(:)
  INTEGER(4)                    :: fDIM
  INTEGER(4)                    :: DxDIR
  INTEGER(4),       INTENT(IN)  :: fldID
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE    ! CURRENT SPACE
  CHARACTER(LEN=1)              :: CSPACE1

  fDIM=SIZE(f)
  CSPACE1=CSPACE(1:1)

  IF(PSMDSCHEME(fldID).OR.XPSMDSCHEME(fldID).OR.YPSMDSCHEME(fldID).OR.ZPSMDSCHEME(fldID)) THEN
   IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIM/2+1))
   IF(ALLOCATED(kg).EQV..FALSE.)   ALLOCATE(kg(fDIM/2+1))
   IF(ALLOCATED(likx).EQV..FALSE.)  ALLOCATE(likx(fDIM/2+1))
   IF(ALLOCATED(kfxgx).EQV..FALSE.) ALLOCATE(kfxgx(fDIM/2+1))
   CALL KGRIDBUILDER(LX1D,likx)
   CALL FFTW(f,kf)
   CALL FFTW(g,kg)
   CALL FFTW(rfxgx,kfxgx)
   CALL GRADfGRADg(kf,kg,likx,kfxgx,fldID,CSPACE)
   CALL iFFTW(kfxgx,rfxgx)
  ELSE
   ALLOCATE(rfx(fDIM))
   ALLOCATE(rgx(fDIM))
   CALL Df(f,LX1D,rfx,1,fldID,CSPACE1)
   CALL Df(g,LX1D,rgx,1,fldID,CSPACE1)
   rfxgx=rfx*rgx
  END IF

  RETURN
 END SUBROUTINE r8r4r8GRADfGRADg1D

 SUBROUTINE r8r8r8GRADfGRADg1DNONE(f,g,LX1D,rfxgx)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX1D(:)
  REAL(8), INTENT(IN)              :: f(:),g(:)
  REAL(8), INTENT(OUT)             :: rfxgx(:)

  CALL GRADfGRADg(f,g,LX1D,rfxgx,1,"x")

  RETURN
 END SUBROUTINE r8r8r8GRADfGRADg1DNONE

 SUBROUTINE r8r8r8GRADfGRADg1D1INT(f,g,LX1D,rfxgx,fldID)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX1D(:)
  REAL(8), INTENT(IN)              :: f(:),g(:)
  REAL(8), INTENT(OUT)             :: rfxgx(:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL GRADfGRADg(f,g,LX1D,rfxgx,fldID,"x")

  RETURN
 END SUBROUTINE r8r8r8GRADfGRADg1D1INT

 SUBROUTINE r8r8r8GRADfGRADg1D1CHR(f,g,LX1D,rfxgx,CSPACE)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX1D(:)
  REAL(8), INTENT(IN)              :: f(:),g(:)
  REAL(8), INTENT(OUT)             :: rfxgx(:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL GRADfGRADg(f,g,LX1D,rfxgx,1,CSPACE)

  RETURN
 END SUBROUTINE r8r8r8GRADfGRADg1D1CHR

 SUBROUTINE r8r8r8GRADfGRADg1D(f,g,LX1D,rfxgx,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8),          INTENT(IN)  :: LX1D(:)
  REAL(8),          INTENT(IN)  :: f(:),g(:)
  REAL(8),          INTENT(OUT) :: rfxgx(:)
  REAL(8),          ALLOCATABLE :: rfx(:),rgx(:)
  COMPLEX(8),       ALLOCATABLE :: kf(:),kg(:)
  COMPLEX(8),       ALLOCATABLE :: likx(:)
  COMPLEX(8),       ALLOCATABLE :: kfxgx(:)
  INTEGER(4)                    :: fDIM
  INTEGER(4)                    :: DxDIR
  INTEGER(4),       INTENT(IN)  :: fldID
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE    ! CURRENT SPACE
  CHARACTER(LEN=1)              :: CSPACE1

  fDIM=SIZE(f)
  CSPACE1=CSPACE(1:1)

  IF(PSMDSCHEME(fldID).OR.XPSMDSCHEME(fldID).OR.YPSMDSCHEME(fldID).OR.ZPSMDSCHEME(fldID)) THEN
   IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIM/2+1))
   IF(ALLOCATED(kg).EQV..FALSE.)   ALLOCATE(kg(fDIM/2+1))
   IF(ALLOCATED(likx).EQV..FALSE.)  ALLOCATE(likx(fDIM/2+1))
   IF(ALLOCATED(kfxgx).EQV..FALSE.) ALLOCATE(kfxgx(fDIM/2+1))
   CALL KGRIDBUILDER(LX1D,likx)
   CALL FFTW(f,kf)
   CALL FFTW(g,kg)
   CALL FFTW(rfxgx,kfxgx)
   CALL GRADfGRADg(kf,kg,likx,kfxgx,fldID,CSPACE)
   CALL iFFTW(kfxgx,rfxgx)
  ELSE
   ALLOCATE(rfx(fDIM))
   ALLOCATE(rgx(fDIM))
   CALL Df(f,LX1D,rfx,1,fldID,CSPACE1)
   CALL Df(g,LX1D,rgx,1,fldID,CSPACE1)
   rfxgx=rfx*rgx
  END IF

  RETURN
 END SUBROUTINE r8r8r8GRADfGRADg1D

 SUBROUTINE c8c8c8GRADfGRADg2DNONE(kf,kg,likx,liky,kfxgx)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:,:),liky(:,:)
  COMPLEX(8),       INTENT(IN)     :: kf(:,:),kg(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:,:)

  CALL GRADfGRADg(kf,kg,likx,liky,kfxgx,1,"xy")

  RETURN
 END SUBROUTINE c8c8c8GRADfGRADg2DNONE

 SUBROUTINE c8c8c8GRADfGRADg2D1INT(kf,kg,likx,liky,kfxgx,fldID)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:,:),liky(:,:)
  COMPLEX(8),       INTENT(IN)     :: kf(:,:),kg(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL GRADfGRADg(kf,kg,likx,liky,kfxgx,fldID,"xy")

  RETURN
 END SUBROUTINE c8c8c8GRADfGRADg2D1INT

 SUBROUTINE c8c8c8GRADfGRADg2D1CHR(kf,kg,likx,liky,kfxgx,CSPACE)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:,:),liky(:,:)
  COMPLEX(8),       INTENT(IN)     :: kf(:,:),kg(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL GRADfGRADg(kf,kg,likx,liky,kfxgx,1,CSPACE)

  RETURN
 END SUBROUTINE c8c8c8GRADfGRADg2D1CHR

 SUBROUTINE c8c8c8GRADfGRADg2D(kf,kg,likx,liky,kfxgx,fldID,CSPACE)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)  :: likx(:,:),liky(:,:)
  COMPLEX(8),       INTENT(IN)  :: kf(:,:),kg(:,:)
  COMPLEX(8),       INTENT(OUT) :: kfxgx(:,:)
  COMPLEX(8),       ALLOCATABLE :: kfx(:,:),kgx(:,:)
  COMPLEX(8),       ALLOCATABLE :: kfxgy(:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: fDIMS(2)
  INTEGER(4)                    :: DxDIR
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE    ! CURRENT SPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2
  REAL(4),          ALLOCATABLE :: rfxgx(:,:)
  REAL(4),          ALLOCATABLE :: rfx(:,:),rgx(:,:)

  fDIMS=SHAPE(kf)

  IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, GRADfGRADg: NUMBER OF CURRENT SPACES ARE NOT ENOUGH!"
   STOP
  ELSE IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, GRADfGRADg: NUMBER OF CURRENT SPACES ARE TOO MANY!"
   STOP
  END IF

  ALLOCATE(kfxgy(fDIMS(1),fDIMS(2)))

  kfxgx=CMPLX(0.0d0,0.0d0)
  CALL DfDg(kf,kg,likx,likx,kfxgy,fldID,CSPACE)
  kfxgx=kfxgx+kfxgy
  CALL DfDg(kf,kg,liky,liky,kfxgy,fldID,CSPACE)
  kfxgx=kfxgx+kfxgy

  RETURN
 END SUBROUTINE c8c8c8GRADfGRADg2D

 SUBROUTINE r4r4c8GRADfGRADg2DNONE(f,g,LX2D,LY2D,kfxgx)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX2D(:,:),LY2D(:,:)
  REAL(4),          INTENT(IN)     :: f(:,:),g(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:,:)

  CALL GRADfGRADg(f,g,LX2D,LY2D,kfxgx,1,"xy")

  RETURN
 END SUBROUTINE r4r4c8GRADfGRADg2DNONE

 SUBROUTINE r4r4c8GRADfGRADg2D1INT(f,g,LX2D,LY2D,kfxgx,fldID)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX2D(:,:),LY2D(:,:)
  REAL(4),          INTENT(IN)     :: f(:,:),g(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL GRADfGRADg(f,g,LX2D,LY2D,kfxgx,fldID,"xy")

  RETURN
 END SUBROUTINE r4r4c8GRADfGRADg2D1INT

 SUBROUTINE r4r4c8GRADfGRADg2D1CHR(f,g,LX2D,LY2D,kfxgx,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX2D(:,:),LY2D(:,:)
  REAL(4),          INTENT(IN)     :: f(:,:),g(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL GRADfGRADg(f,g,LX2D,LY2D,kfxgx,1,CSPACE)

  RETURN
 END SUBROUTINE r4r4c8GRADfGRADg2D1CHR

 SUBROUTINE r4r4c8GRADfGRADg2D(f,g,LX2D,LY2D,kfxgx,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)  :: LX2D(:,:),LY2D(:,:)
  REAL(4),          INTENT(IN)  :: f(:,:),g(:,:)
  REAL(4),          ALLOCATABLE :: rfxgx(:,:)
  REAL(4),          ALLOCATABLE :: rfx(:,:),rgx(:,:)
  COMPLEX(8),       INTENT(OUT) :: kfxgx(:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:),kg(:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:),liky(:,:)
  INTEGER(4)                    :: fDIMS(2)
  INTEGER(4)                    :: DxDIR,DyDIR
  INTEGER(4),       INTENT(IN)  :: fldID
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE    ! CURRENT SPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2

  fDIMS=SHAPE(f)

  IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, GRADfGRADg: NUMBER OF CURRENT SPACES ARE NOT ENOUGH!"
   STOP
  ELSE IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, GRADfGRADg: NUMBER OF CURRENT SPACES ARE TOO MANY!"
   STOP
  END IF

  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2)))
  IF(ALLOCATED(kg).EQV..FALSE.)   ALLOCATE(kg(fDIMS(1)/2+1,fDIMS(2)))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2)))
  IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(fDIMS(1)/2+1,fDIMS(2)))

  CALL KGRIDBUILDER(LX2D,likx)
  CALL KGRIDBUILDER(LY2D,liky)
  CALL FFTW(f,kf)
  CALL FFTW(g,kg)
  CALL GRADfGRADg(kf,kg,likx,liky,kfxgx,fldID,CSPACE)

  RETURN
 END SUBROUTINE r4r4c8GRADfGRADg2D

 SUBROUTINE r4r4r4GRADfGRADg2DNONE(f,g,LX2D,LY2D,rfxgx)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(4), INTENT(IN)              :: f(:,:),g(:,:)
  REAL(4), INTENT(INOUT)             :: rfxgx(:,:)

  CALL GRADfGRADg(f,g,LX2D,LY2D,rfxgx,1,"xy")

  RETURN
 END SUBROUTINE r4r4r4GRADfGRADg2DNONE

 SUBROUTINE r4r4r4GRADfGRADg2D1INT(f,g,LX2D,LY2D,rfxgx,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(4), INTENT(IN)              :: f(:,:),g(:,:)
  REAL(4), INTENT(OUT)             :: rfxgx(:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL GRADfGRADg(f,g,LX2D,LY2D,rfxgx,fldID,"xy")

  RETURN
 END SUBROUTINE r4r4r4GRADfGRADg2D1INT

 SUBROUTINE r4r4r4GRADfGRADg2D1CHR(f,g,LX2D,LY2D,rfxgx,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(4), INTENT(IN)              :: f(:,:),g(:,:)
  REAL(4), INTENT(OUT)             :: rfxgx(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL GRADfGRADg(f,g,LX2D,LY2D,rfxgx,1,CSPACE)

  RETURN
 END SUBROUTINE r4r4r4GRADfGRADg2D1CHR

 SUBROUTINE r4r4r4GRADfGRADg2D(f,g,LX2D,LY2D,rfxgx,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)  :: LX2D(:,:),LY2D(:,:)
  REAL(4),          INTENT(IN)  :: f(:,:),g(:,:)
  REAL(4),          INTENT(OUT) :: rfxgx(:,:)
  REAL(4),          ALLOCATABLE :: rfx(:,:),rgx(:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:),kg(:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:),liky(:,:)
  COMPLEX(8),       ALLOCATABLE :: kfxgx(:,:)
  INTEGER(4)                    :: fDIMS(2)
  INTEGER(4)                    :: DxDIR,DyDIR
  INTEGER(4),       INTENT(IN)  :: fldID
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE    ! CURRENT SPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2

  fDIMS=SHAPE(f)

  IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, GRADfGRADg: NUMBER OF CURRENT SPACES ARE NOT ENOUGH!"
   STOP
  ELSE IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, GRADfGRADg: NUMBER OF CURRENT SPACES ARE TOO MANY!"
   STOP
  END IF

  IF(PSMDSCHEME(fldID).OR.XPSMDSCHEME(fldID).OR.YPSMDSCHEME(fldID).OR.ZPSMDSCHEME(fldID)) THEN
   IF(ALLOCATED(kf).EQV..FALSE.)    ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2)))
   IF(ALLOCATED(kg).EQV..FALSE.)    ALLOCATE(kg(fDIMS(1)/2+1,fDIMS(2)))
   IF(ALLOCATED(likx).EQV..FALSE.)  ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2)))
   IF(ALLOCATED(liky).EQV..FALSE.)  ALLOCATE(liky(fDIMS(1)/2+1,fDIMS(2)))
   IF(ALLOCATED(kfxgx).EQV..FALSE.) ALLOCATE(kfxgx(fDIMS(1)/2+1,fDIMS(2)))
   CALL KGRIDBUILDER(LX2D,likx)
   CALL KGRIDBUILDER(LY2D,liky)
   CALL FFTW(f,kf)
   CALL FFTW(g,kg)
   CALL GRADfGRADg(kf,kg,likx,liky,kfxgx,fldID,CSPACE)
   CALL iFFTW(kfxgx,rfxgx)
  ELSE
   IF(ALLOCATED(rfx).EQV..FALSE.) ALLOCATE(rfx(fDIMS(1),fDIMS(2)))
   IF(ALLOCATED(rgx).EQV..FALSE.) ALLOCATE(rgx(fDIMS(1),fDIMS(2)))
   CALL Df(f,LX2D,rfx,1,fldID,CSPACE1)
   CALL Df(g,LX2D,rgx,1,fldID,CSPACE1)
   rfxgx=rfx*rgx
   CALL Df(f,LY2D,rfx,1,fldID,CSPACE2)
   CALL Df(g,LY2D,rgx,1,fldID,CSPACE2)
   rfxgx=rfxgx+rfx*rgx
  END IF

  RETURN
 END SUBROUTINE r4r4r4GRADfGRADg2D

 SUBROUTINE r8r4c8GRADfGRADg2DNONE(f,g,LX2D,LY2D,kfxgx)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX2D(:,:),LY2D(:,:)
  REAL(8),          INTENT(IN)     :: f(:,:),g(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:,:)
  
  CALL GRADfGRADg(f,g,LX2D,LY2D,kfxgx,1,"x")
 
  RETURN
 END SUBROUTINE r8r4c8GRADfGRADg2DNONE

 SUBROUTINE r8r4c8GRADfGRADg2D1INT(f,g,LX2D,LY2D,kfxgx,fldID)
  IMPLICIT NONE     
  REAL(4),          INTENT(IN)     :: LX2D(:,:),LY2D(:,:)
  REAL(8),          INTENT(IN)     :: f(:,:),g(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:,:)
  INTEGER(4),       INTENT(IN)     :: fldID
  
  CALL GRADfGRADg(f,g,LX2D,LY2D,kfxgx,fldID,"x")
 
  RETURN
 END SUBROUTINE r8r4c8GRADfGRADg2D1INT

 SUBROUTINE r8r4c8GRADfGRADg2D1CHR(f,g,LX2D,LY2D,kfxgx,CSPACE)
  IMPLICIT NONE     
  REAL(4),          INTENT(IN)     :: LX2D(:,:),LY2D(:,:)
  REAL(8),          INTENT(IN)     :: f(:,:),g(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
  
  CALL GRADfGRADg(f,g,LX2D,LY2D,kfxgx,1,CSPACE)
 
  RETURN
 END SUBROUTINE r8r4c8GRADfGRADg2D1CHR

 SUBROUTINE r8r4c8GRADfGRADg2D(f,g,LX2D,LY2D,kfxgx,fldID,CSPACE)
  IMPLICIT NONE     
  REAL(4),          INTENT(IN)  :: LX2D(:,:),LY2D(:,:)
  REAL(8),          INTENT(IN)  :: f(:,:),g(:,:)
  REAL(8),          ALLOCATABLE :: rfxgx(:,:)
  REAL(8),          ALLOCATABLE :: rfx(:,:),rgx(:,:)
  COMPLEX(8),       INTENT(OUT) :: kfxgx(:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:),kg(:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:),liky(:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: fDIMS(2)
  INTEGER(4)                    :: DxDIR,DyDIR
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE             ! CURRENT SPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2

  fDIMS=SHAPE(f)

  IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, GRADfGRADg: NUMBER OF CURRENT SPACES ARE NOT ENOUGH!"
   STOP
  ELSE IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, GRADfGRADg: NUMBER OF CURRENT SPACES ARE TOO MANY!"
   STOP
  END IF

  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2)))
  IF(ALLOCATED(kg).EQV..FALSE.)   ALLOCATE(kg(fDIMS(1)/2+1,fDIMS(2)))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2)))
  IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(fDIMS(1)/2+1,fDIMS(2)))

  CALL KGRIDBUILDER(LX2D,likx)
  CALL KGRIDBUILDER(LY2D,liky)
  CALL FFTW(f,kf)
  CALL FFTW(g,kg)
  CALL GRADfGRADg(kf,kg,likx,liky,kfxgx,fldID,CSPACE)

  RETURN
 END SUBROUTINE r8r4c8GRADfGRADg2D

 SUBROUTINE r8r8c8GRADfGRADg2DNONE(f,g,LX2D,LY2D,kfxgx)
  IMPLICIT NONE
  REAL(8),          INTENT(IN)     :: LX2D(:,:),LY2D(:,:)
  REAL(8),          INTENT(IN)     :: f(:,:),g(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:,:)
  
  CALL GRADfGRADg(f,g,LX2D,LY2D,kfxgx,1,"x")
 
  RETURN
 END SUBROUTINE r8r8c8GRADfGRADg2DNONE

 SUBROUTINE r8r8c8GRADfGRADg2D1INT(f,g,LX2D,LY2D,kfxgx,fldID)
  IMPLICIT NONE     
  REAL(8),          INTENT(IN)     :: LX2D(:,:),LY2D(:,:)
  REAL(8),          INTENT(IN)     :: f(:,:),g(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:,:)
  INTEGER(4),       INTENT(IN)     :: fldID
  
  CALL GRADfGRADg(f,g,LX2D,LY2D,kfxgx,fldID,"x")
 
  RETURN
 END SUBROUTINE r8r8c8GRADfGRADg2D1INT

 SUBROUTINE r8r8c8GRADfGRADg2D1CHR(f,g,LX2D,LY2D,kfxgx,CSPACE)
  IMPLICIT NONE     
  REAL(8),          INTENT(IN)     :: LX2D(:,:),LY2D(:,:)
  REAL(8),          INTENT(IN)     :: f(:,:),g(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
  
  CALL GRADfGRADg(f,g,LX2D,LY2D,kfxgx,1,CSPACE)
 
  RETURN
 END SUBROUTINE r8r8c8GRADfGRADg2D1CHR

 SUBROUTINE r8r8c8GRADfGRADg2D(f,g,LX2D,LY2D,kfxgx,fldID,CSPACE)
  IMPLICIT NONE     
  REAL(8),          INTENT(IN)  :: LX2D(:,:),LY2D(:,:)
  REAL(8),          INTENT(IN)  :: f(:,:),g(:,:)
  REAL(8),          ALLOCATABLE :: rfxgx(:,:)
  REAL(8),          ALLOCATABLE :: rfx(:,:),rgx(:,:)
  COMPLEX(8),       INTENT(OUT) :: kfxgx(:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:),kg(:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:),liky(:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: fDIMS(2)
  INTEGER(4)                    :: DxDIR,DyDIR
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE             ! CURRENT SPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2

  fDIMS=SHAPE(f)

  IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, GRADfGRADg: NUMBER OF CURRENT SPACES ARE NOT ENOUGH!"
   STOP
  ELSE IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, GRADfGRADg: NUMBER OF CURRENT SPACES ARE TOO MANY!"
   STOP
  END IF

  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2)))
  IF(ALLOCATED(kg).EQV..FALSE.)   ALLOCATE(kg(fDIMS(1)/2+1,fDIMS(2)))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2)))
  IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(fDIMS(1)/2+1,fDIMS(2)))

  CALL KGRIDBUILDER(LX2D,likx)
  CALL KGRIDBUILDER(LY2D,liky)
  CALL FFTW(f,kf)
  CALL FFTW(g,kg)
  CALL GRADfGRADg(kf,kg,likx,liky,kfxgx,fldID,CSPACE)

  RETURN
 END SUBROUTINE r8r8c8GRADfGRADg2D

 SUBROUTINE r8r4r8GRADfGRADg2DNONE(f,g,LX2D,LY2D,rfxgx)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:),g(:,:)
  REAL(8), INTENT(OUT)             :: rfxgx(:,:)

  CALL GRADfGRADg(f,g,LX2D,LY2D,rfxgx,1,"xy")

  RETURN
 END SUBROUTINE r8r4r8GRADfGRADg2DNONE

 SUBROUTINE r8r4r8GRADfGRADg2D1INT(f,g,LX2D,LY2D,rfxgx,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:),g(:,:)
  REAL(8), INTENT(OUT)             :: rfxgx(:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL GRADfGRADg(f,g,LX2D,LY2D,rfxgx,fldID,"xy")

  RETURN
 END SUBROUTINE r8r4r8GRADfGRADg2D1INT

 SUBROUTINE r8r4r8GRADfGRADg2D1CHR(f,g,LX2D,LY2D,rfxgx,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:),g(:,:)
  REAL(8), INTENT(OUT)             :: rfxgx(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL GRADfGRADg(f,g,LX2D,LY2D,rfxgx,1,CSPACE)

  RETURN
 END SUBROUTINE r8r4r8GRADfGRADg2D1CHR

 SUBROUTINE r8r4r8GRADfGRADg2D(f,g,LX2D,LY2D,rfxgx,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)  :: LX2D(:,:),LY2D(:,:)
  REAL(8),          INTENT(IN)  :: f(:,:),g(:,:)
  REAL(8),          INTENT(OUT) :: rfxgx(:,:)
  REAL(8),          ALLOCATABLE :: rfx(:,:),rgx(:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:),kg(:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:),liky(:,:)
  COMPLEX(8),       ALLOCATABLE :: kfxgx(:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: fDIMS(2)
  INTEGER(4)                    :: DxDIR,DyDIR
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE             ! CURRENT SPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2

  fDIMS=SHAPE(f)
  
  IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, GRADfGRADg: NUMBER OF CURRENT SPACES ARE NOT ENOUGH!"
   STOP
  ELSE IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, GRADfGRADg: NUMBER OF CURRENT SPACES ARE TOO MANY!"
   STOP
  END IF

  IF(PSMDSCHEME(fldID).OR.XPSMDSCHEME(fldID).OR.YPSMDSCHEME(fldID).OR.ZPSMDSCHEME(fldID)) THEN
   IF(ALLOCATED(kf).EQV..FALSE.)    ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2)))
   IF(ALLOCATED(kg).EQV..FALSE.)    ALLOCATE(kg(fDIMS(1)/2+1,fDIMS(2)))
   IF(ALLOCATED(likx).EQV..FALSE.)  ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2)))
   IF(ALLOCATED(liky).EQV..FALSE.)  ALLOCATE(liky(fDIMS(1)/2+1,fDIMS(2)))
   IF(ALLOCATED(kfxgx).EQV..FALSE.) ALLOCATE(kfxgx(fDIMS(1)/2+1,fDIMS(2)))
   CALL KGRIDBUILDER(LX2D,likx)
   CALL KGRIDBUILDER(LY2D,liky)
   CALL FFTW(f,kf)
   CALL FFTW(g,kg)
   CALL GRADfGRADg(kf,kg,likx,liky,kfxgx,fldID,CSPACE)
   CALL iFFTW(kfxgx,rfxgx)
  ELSE
   IF(ALLOCATED(rfx)) DEALLOCATE(rfx)
   IF(ALLOCATED(rgx)) DEALLOCATE(rgx)
   ALLOCATE(rfx(fDIMS(1),fDIMS(2)))
   ALLOCATE(rgx(fDIMS(1),fDIMS(2)))
   CALL Df(f,LX2D,rfx,1,fldID,CSPACE1)
   CALL Df(g,LX2D,rgx,1,fldID,CSPACE1)
   rfxgx=rfx*rgx
   CALL Df(f,LY2D,rfx,1,fldID,CSPACE2)
   CALL Df(g,LY2D,rgx,1,fldID,CSPACE2)
   rfxgx=rfxgx+rfx*rgx
  END IF

  RETURN
 END SUBROUTINE r8r4r8GRADfGRADg2D

 SUBROUTINE r8r8r8GRADfGRADg2DNONE(f,g,LX2D,LY2D,rfxgx)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:),g(:,:)
  REAL(8), INTENT(OUT)             :: rfxgx(:,:)

  CALL GRADfGRADg(f,g,LX2D,LY2D,rfxgx,1,"xy")

  RETURN
 END SUBROUTINE r8r8r8GRADfGRADg2DNONE

 SUBROUTINE r8r8r8GRADfGRADg2D1INT(f,g,LX2D,LY2D,rfxgx,fldID)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:),g(:,:)
  REAL(8), INTENT(OUT)             :: rfxgx(:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL GRADfGRADg(f,g,LX2D,LY2D,rfxgx,fldID,"xy")

  RETURN
 END SUBROUTINE r8r8r8GRADfGRADg2D1INT

 SUBROUTINE r8r8r8GRADfGRADg2D1CHR(f,g,LX2D,LY2D,rfxgx,CSPACE)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:),g(:,:)
  REAL(8), INTENT(OUT)             :: rfxgx(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL GRADfGRADg(f,g,LX2D,LY2D,rfxgx,1,CSPACE)

  RETURN
 END SUBROUTINE r8r8r8GRADfGRADg2D1CHR

 SUBROUTINE r8r8r8GRADfGRADg2D(f,g,LX2D,LY2D,rfxgx,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8),          INTENT(IN)  :: LX2D(:,:),LY2D(:,:)
  REAL(8),          INTENT(IN)  :: f(:,:),g(:,:)
  REAL(8),          INTENT(OUT) :: rfxgx(:,:)
  REAL(8),          ALLOCATABLE :: rfx(:,:),rgx(:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:),kg(:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:),liky(:,:)
  COMPLEX(8),       ALLOCATABLE :: kfxgx(:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: fDIMS(2)
  INTEGER(4)                    :: DxDIR,DyDIR
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE             ! CURRENT SPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2

  fDIMS=SHAPE(f)
  
  IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, GRADfGRADg: NUMBER OF CURRENT SPACES ARE NOT ENOUGH!"
   STOP
  ELSE IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, GRADfGRADg: NUMBER OF CURRENT SPACES ARE TOO MANY!"
   STOP
  END IF

  IF(PSMDSCHEME(fldID).OR.XPSMDSCHEME(fldID).OR.YPSMDSCHEME(fldID).OR.ZPSMDSCHEME(fldID)) THEN
   IF(ALLOCATED(kf).EQV..FALSE.)    ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2)))
   IF(ALLOCATED(kg).EQV..FALSE.)    ALLOCATE(kg(fDIMS(1)/2+1,fDIMS(2)))
   IF(ALLOCATED(likx).EQV..FALSE.)  ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2)))
   IF(ALLOCATED(liky).EQV..FALSE.)  ALLOCATE(liky(fDIMS(1)/2+1,fDIMS(2)))
   IF(ALLOCATED(kfxgx).EQV..FALSE.) ALLOCATE(kfxgx(fDIMS(1)/2+1,fDIMS(2)))
   CALL KGRIDBUILDER(LX2D,likx)
   CALL KGRIDBUILDER(LY2D,liky)
   CALL FFTW(f,kf)
   CALL FFTW(g,kg)
   CALL GRADfGRADg(kf,kg,likx,liky,kfxgx,fldID,CSPACE)
   CALL iFFTW(kfxgx,rfxgx)
  ELSE
   IF(ALLOCATED(rfx)) DEALLOCATE(rfx)
   IF(ALLOCATED(rgx)) DEALLOCATE(rgx)
   ALLOCATE(rfx(fDIMS(1),fDIMS(2)))
   ALLOCATE(rgx(fDIMS(1),fDIMS(2)))
   CALL Df(f,LX2D,rfx,1,fldID,CSPACE1)
   CALL Df(g,LX2D,rgx,1,fldID,CSPACE1)
   rfxgx=rfx*rgx
   CALL Df(f,LY2D,rfx,1,fldID,CSPACE2)
   CALL Df(g,LY2D,rgx,1,fldID,CSPACE2)
   rfxgx=rfxgx+rfx*rgx
  END IF

  RETURN
 END SUBROUTINE r8r8r8GRADfGRADg2D

 SUBROUTINE c8c8c8GRADfGRADg3DNONE(kf,kg,likx,liky,likz,kfxgx)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:,:,:),liky(:,:,:),likz(:,:,:)
  COMPLEX(8),       INTENT(IN)     :: kf(:,:,:),kg(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:,:,:)

  CALL GRADfGRADg(kf,kg,likx,liky,likz,kfxgx,1,"xyz")

  RETURN
 END SUBROUTINE c8c8c8GRADfGRADg3DNONE

 SUBROUTINE c8c8c8GRADfGRADg3D1INT(kf,kg,likx,liky,likz,kfxgx,fldID)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:,:,:),liky(:,:,:),likz(:,:,:)
  COMPLEX(8),       INTENT(IN)     :: kf(:,:,:),kg(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:,:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL GRADfGRADg(kf,kg,likx,liky,likz,kfxgx,fldID,"xyz")

  RETURN
 END SUBROUTINE c8c8c8GRADfGRADg3D1INT

 SUBROUTINE c8c8c8GRADfGRADg3D1CHR(kf,kg,likx,liky,likz,kfxgx,CSPACE)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:,:,:),liky(:,:,:),likz(:,:,:)
  COMPLEX(8),       INTENT(IN)     :: kf(:,:,:),kg(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL GRADfGRADg(kf,kg,likx,liky,likz,kfxgx,1,CSPACE)

  RETURN
 END SUBROUTINE c8c8c8GRADfGRADg3D1CHR

 SUBROUTINE c8c8c8GRADfGRADg3D(kf,kg,likx,liky,likz,kfxgx,fldID,CSPACE)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)  :: likx(:,:,:),liky(:,:,:),likz(:,:,:)
  COMPLEX(8),       INTENT(IN)  :: kf(:,:,:),kg(:,:,:)
  COMPLEX(8),       INTENT(OUT) :: kfxgx(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: kfx(:,:,:),kgx(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: kfxgy(:,:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: fDIMS(3)
  INTEGER(4)                    :: DxDIR
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE    ! CURRENT SPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2,CSPACE3
  REAL(4),          ALLOCATABLE :: rfxgx(:,:,:)
  REAL(4),          ALLOCATABLE :: rfx(:,:,:),rgx(:,:,:)

  fDIMS=SHAPE(kf)

  IF(LEN(CSPACE).EQ.3) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   CSPACE3=CSPACE(3:3)
  ELSE IF(LEN(CSPACE).LT.3) THEN
   CSPACE1="x"
   CSPACE2="y"
   CSPACE3="z"
  ELSE IF(LEN(CSPACE).GT.3) THEN
   PRINT*, "ERROR, GRADfGRADg: NUMBER OF CURRENT SPACES ARE TOO MANY!"
   STOP
  END IF

  IF(ALLOCATED(kfxgy).EQV..FALSE.) ALLOCATE(kfxgy(fDIMS(1),fDIMS(2),fDIMS(3)))

  kfxgx=CMPLX(0.0d0,0.0d0)
  CALL DfDg(kf,kg,likx,likx,kfxgy,fldID,CSPACE)
  kfxgx=kfxgx+kfxgy
  CALL DfDg(kf,kg,liky,liky,kfxgy,fldID,CSPACE)
  kfxgx=kfxgx+kfxgy
  CALL DfDg(kf,kg,likz,likz,kfxgy,fldID,CSPACE)
  kfxgx=kfxgx+kfxgy

  RETURN
 END SUBROUTINE c8c8c8GRADfGRADg3D

 SUBROUTINE r4r4c8GRADfGRADg3DNONE(f,g,LX3D,LY3D,LZ3D,kfxgx)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX3D(:,:,:),LY3D(:,:,:),LZ3D(:,:,:)
  REAL(4),          INTENT(IN)     :: f(:,:,:),g(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:,:,:)
  
  CALL GRADfGRADg(f,g,LX3D,LY3D,LZ3D,kfxgx,1,"xyz")
 
  RETURN
 END SUBROUTINE r4r4c8GRADfGRADg3DNONE

 SUBROUTINE r4r4c8GRADfGRADg3D1INT(f,g,LX3D,LY3D,LZ3D,kfxgx,fldID)
  IMPLICIT NONE     
  REAL(4),          INTENT(IN)     :: LX3D(:,:,:),LY3D(:,:,:),LZ3D(:,:,:)
  REAL(4),          INTENT(IN)     :: f(:,:,:),g(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:,:,:)
  INTEGER(4),       INTENT(IN)     :: fldID
  
  CALL GRADfGRADg(f,g,LX3D,LY3D,LZ3D,kfxgx,fldID,"xyz")
 
  RETURN
 END SUBROUTINE r4r4c8GRADfGRADg3D1INT

 SUBROUTINE r4r4c8GRADfGRADg3D1CHR(f,g,LX3D,LY3D,LZ3D,kfxgx,CSPACE)
  IMPLICIT NONE     
  REAL(4),          INTENT(IN)     :: LX3D(:,:,:),LY3D(:,:,:),LZ3D(:,:,:)
  REAL(4),          INTENT(IN)     :: f(:,:,:),g(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
  
  CALL GRADfGRADg(f,g,LX3D,LY3D,LZ3D,kfxgx,1,CSPACE)
 
  RETURN
 END SUBROUTINE r4r4c8GRADfGRADg3D1CHR

 SUBROUTINE r4r4c8GRADfGRADg3D(f,g,LX3D,LY3D,LZ3D,kfxgx,fldID,CSPACE)
  IMPLICIT NONE     
  REAL(4),          INTENT(IN)  :: LX3D(:,:,:),LY3D(:,:,:),LZ3D(:,:,:)
  REAL(4),          INTENT(IN)  :: f(:,:,:),g(:,:,:)
  REAL(4),          ALLOCATABLE :: rfxgx(:,:,:)
  REAL(4),          ALLOCATABLE :: rfx(:,:,:),rgx(:,:,:)
  COMPLEX(8),       INTENT(OUT) :: kfxgx(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:,:),kg(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:,:),liky(:,:,:),likz(:,:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: fDIMS(3)
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE    ! CURRENT SPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2,CSPACE3

  fDIMS=SHAPE(f)

  IF(LEN(CSPACE).EQ.3) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   CSPACE3=CSPACE(3:3)
  ELSE IF(LEN(CSPACE).LT.3) THEN
   CSPACE1="x"
   CSPACE2="y"
   CSPACE3="z"
  ELSE IF(LEN(CSPACE).GT.3) THEN
   PRINT*, "ERROR, GRADfGRADg: NUMBER OF CURRENT SPACES ARE TOO MANY!"
   STOP
  END IF

  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(kg).EQV..FALSE.)   ALLOCATE(kg(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(likz).EQV..FALSE.) ALLOCATE(likz(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))

  CALL KGRIDBUILDER(LX3D,likx)
  CALL KGRIDBUILDER(LY3D,liky)
  CALL KGRIDBUILDER(LZ3D,likz)
  CALL FFTW(f,kf)
  CALL FFTW(g,kg)
  CALL GRADfGRADg(kf,kg,likx,liky,likz,kfxgx,fldID,CSPACE)

  RETURN
 END SUBROUTINE r4r4c8GRADfGRADg3D

 SUBROUTINE r4r4r4GRADfGRADg3DNONE(f,g,LX3D,LY3D,LZ3D,rfxgx)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:),LZ3D(:,:,:)
  REAL(4), INTENT(IN)              :: f(:,:,:),g(:,:,:)
  REAL(4), INTENT(OUT)             :: rfxgx(:,:,:)

  CALL GRADfGRADg(f,g,LX3D,LY3D,LZ3D,rfxgx,1,"xyz")

  RETURN
 END SUBROUTINE r4r4r4GRADfGRADg3DNONE

 SUBROUTINE r4r4r4GRADfGRADg3D1INT(f,g,LX3D,LY3D,LZ3D,rfxgx,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:),LZ3D(:,:,:)
  REAL(4), INTENT(IN)              :: f(:,:,:),g(:,:,:)
  REAL(4), INTENT(OUT)             :: rfxgx(:,:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL GRADfGRADg(f,g,LX3D,LY3D,LZ3D,rfxgx,fldID,"xyz")

  RETURN
 END SUBROUTINE r4r4r4GRADfGRADg3D1INT

 SUBROUTINE r4r4r4GRADfGRADg3D1CHR(f,g,LX3D,LY3D,LZ3D,rfxgx,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:),LZ3D(:,:,:)
  REAL(4), INTENT(IN)              :: f(:,:,:),g(:,:,:)
  REAL(4), INTENT(OUT)             :: rfxgx(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL GRADfGRADg(f,g,LX3D,LY3D,LZ3D,rfxgx,1,CSPACE)

  RETURN
 END SUBROUTINE r4r4r4GRADfGRADg3D1CHR

 SUBROUTINE r4r4r4GRADfGRADg3D(f,g,LX3D,LY3D,LZ3D,rfxgx,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)  :: LX3D(:,:,:),LY3D(:,:,:),LZ3D(:,:,:)
  REAL(4),          INTENT(IN)  :: f(:,:,:),g(:,:,:)
  REAL(4),          INTENT(OUT) :: rfxgx(:,:,:)
  REAL(4),          ALLOCATABLE :: rfx(:,:,:),rgx(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:,:),kg(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:,:),liky(:,:,:),likz(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: kfxgx(:,:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: fDIMS(3)
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE    ! CURRENT SPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2,CSPACE3

  fDIMS=SHAPE(f)

  IF(LEN(CSPACE).EQ.3) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   CSPACE3=CSPACE(3:3)
  ELSE IF(LEN(CSPACE).LT.3) THEN
   CSPACE1="x"
   CSPACE2="y"
   CSPACE3="z"
  ELSE IF(LEN(CSPACE).GT.3) THEN
   PRINT*, "ERROR, GRADfGRADg: NUMBER OF CURRENT SPACES ARE TOO MANY!"
   STOP
  END IF

  IF(PSMDSCHEME(fldID).OR.XPSMDSCHEME(fldID).OR.YPSMDSCHEME(fldID).OR.ZPSMDSCHEME(fldID)) THEN
   IF(ALLOCATED(kf).EQV..FALSE.)    ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
   IF(ALLOCATED(kg).EQV..FALSE.)    ALLOCATE(kg(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
   IF(ALLOCATED(likx).EQV..FALSE.)  ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
   IF(ALLOCATED(liky).EQV..FALSE.)  ALLOCATE(liky(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
   IF(ALLOCATED(likz).EQV..FALSE.)  ALLOCATE(likz(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
   IF(ALLOCATED(kfxgx).EQV..FALSE.) ALLOCATE(kfxgx(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
   CALL KGRIDBUILDER(LX3D,likx)
   CALL KGRIDBUILDER(LY3D,liky)
   CALL KGRIDBUILDER(LZ3D,liky)
   CALL FFTW(f,kf)
   CALL FFTW(g,kg)
   CALL GRADfGRADg(kf,kg,likx,liky,likz,kfxgx,fldID,CSPACE)
   CALL iFFTW(kfxgx,rfxgx)
  ELSE
   IF(ALLOCATED(rfx)) DEALLOCATE(rfx)
   IF(ALLOCATED(rgx)) DEALLOCATE(rgx)
   ALLOCATE(rfx(fDIMS(1),fDIMS(2),fDIMS(3)))
   ALLOCATE(rgx(fDIMS(1),fDIMS(2),fDIMS(3)))
   CALL Df(f,LX3D,rfx,1,fldID,CSPACE1)
   CALL Df(g,LX3D,rgx,1,fldID,CSPACE1)
   rfxgx=rfx*rgx
   CALL Df(f,LY3D,rfx,1,fldID,CSPACE2)
   CALL Df(g,LY3D,rgx,1,fldID,CSPACE2)
   rfxgx=rfxgx+rfx*rgx
   CALL Df(f,LZ3D,rfx,1,fldID,CSPACE3)
   CALL Df(g,LZ3D,rgx,1,fldID,CSPACE3)
   rfxgx=rfxgx+rfx*rgx
  END IF

  RETURN
 END SUBROUTINE r4r4r4GRADfGRADg3D

 SUBROUTINE r8r4c8GRADfGRADg3DNONE(f,g,LX3D,LY3D,LZ3D,kfxgx)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX3D(:,:,:),LY3D(:,:,:),LZ3D(:,:,:)
  REAL(8),          INTENT(IN)     :: f(:,:,:),g(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:,:,:)

  CALL GRADfGRADg(f,g,LX3D,LY3D,LZ3D,kfxgx,1,"x")

  RETURN
 END SUBROUTINE r8r4c8GRADfGRADg3DNONE

 SUBROUTINE r8r4c8GRADfGRADg3D1INT(f,g,LX3D,LY3D,LZ3D,kfxgx,fldID)
  IMPLICIT NONE     
  REAL(4),          INTENT(IN)     :: LX3D(:,:,:),LY3D(:,:,:),LZ3D(:,:,:)
  REAL(8),          INTENT(IN)     :: f(:,:,:),g(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:,:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL GRADfGRADg(f,g,LX3D,LY3D,LZ3D,kfxgx,fldID,"x")
   
  RETURN
 END SUBROUTINE r8r4c8GRADfGRADg3D1INT
   
 SUBROUTINE r8r4c8GRADfGRADg3D1CHR(f,g,LX3D,LY3D,LZ3D,kfxgx,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX3D(:,:,:),LY3D(:,:,:),LZ3D(:,:,:)
  REAL(8),          INTENT(IN)     :: f(:,:,:),g(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
  
  CALL GRADfGRADg(f,g,LX3D,LY3D,LZ3D,kfxgx,1,CSPACE)
  
  RETURN
 END SUBROUTINE r8r4c8GRADfGRADg3D1CHR
 
 SUBROUTINE r8r4c8GRADfGRADg3D(f,g,LX3D,LY3D,LZ3D,kfxgx,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)  :: LX3D(:,:,:),LY3D(:,:,:),LZ3D(:,:,:)
  REAL(8),          INTENT(IN)  :: f(:,:,:),g(:,:,:)
  REAL(8),          ALLOCATABLE :: rfxgx(:,:,:)
  REAL(8),          ALLOCATABLE :: rfx(:,:,:),rgx(:,:,:)
  COMPLEX(8),       INTENT(OUT) :: kfxgx(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:,:),kg(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:,:),liky(:,:,:),likz(:,:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: fDIMS(3)
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE    ! CURRENT SPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2,CSPACE3

  fDIMS=SHAPE(f)

  IF(LEN(CSPACE).EQ.3) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   CSPACE3=CSPACE(3:3)
  ELSE IF(LEN(CSPACE).LT.3) THEN
   CSPACE1="x"
   CSPACE2="y"
   CSPACE3="z"
  ELSE IF(LEN(CSPACE).GT.3) THEN
   PRINT*, "ERROR, GRADfGRADg: NUMBER OF CURRENT SPACE ARE TOO MANY!"
   STOP
  END IF

  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(kg).EQV..FALSE.)   ALLOCATE(kg(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(likz).EQV..FALSE.) ALLOCATE(likz(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))

  CALL KGRIDBUILDER(LX3D,likx)
  CALL KGRIDBUILDER(LY3D,liky)
  CALL KGRIDBUILDER(LZ3D,likz)
  CALL FFTW(f,kf)
  CALL FFTW(g,kg)
  CALL GRADfGRADg(kf,kg,likx,liky,likz,kfxgx,fldID,CSPACE)

  RETURN
 END SUBROUTINE r8r4c8GRADfGRADg3D

 SUBROUTINE r8r8c8GRADfGRADg3DNONE(f,g,LX3D,LY3D,LZ3D,kfxgx)
  IMPLICIT NONE
  REAL(8),          INTENT(IN)     :: LX3D(:,:,:),LY3D(:,:,:),LZ3D(:,:,:)
  REAL(8),          INTENT(IN)     :: f(:,:,:),g(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:,:,:)

  CALL GRADfGRADg(f,g,LX3D,LY3D,LZ3D,kfxgx,1,"x")

  RETURN
 END SUBROUTINE r8r8c8GRADfGRADg3DNONE

 SUBROUTINE r8r8c8GRADfGRADg3D1INT(f,g,LX3D,LY3D,LZ3D,kfxgx,fldID)
  IMPLICIT NONE     
  REAL(8),          INTENT(IN)     :: LX3D(:,:,:),LY3D(:,:,:),LZ3D(:,:,:)
  REAL(8),          INTENT(IN)     :: f(:,:,:),g(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:,:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL GRADfGRADg(f,g,LX3D,LY3D,LZ3D,kfxgx,fldID,"x")
   
  RETURN
 END SUBROUTINE r8r8c8GRADfGRADg3D1INT
   
 SUBROUTINE r8r8c8GRADfGRADg3D1CHR(f,g,LX3D,LY3D,LZ3D,kfxgx,CSPACE)
  IMPLICIT NONE
  REAL(8),          INTENT(IN)     :: LX3D(:,:,:),LY3D(:,:,:),LZ3D(:,:,:)
  REAL(8),          INTENT(IN)     :: f(:,:,:),g(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgx(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
  
  CALL GRADfGRADg(f,g,LX3D,LY3D,LZ3D,kfxgx,1,CSPACE)
  
  RETURN
 END SUBROUTINE r8r8c8GRADfGRADg3D1CHR
 
 SUBROUTINE r8r8c8GRADfGRADg3D(f,g,LX3D,LY3D,LZ3D,kfxgx,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8),          INTENT(IN)  :: LX3D(:,:,:),LY3D(:,:,:),LZ3D(:,:,:)
  REAL(8),          INTENT(IN)  :: f(:,:,:),g(:,:,:)
  REAL(8),          ALLOCATABLE :: rfxgx(:,:,:)
  REAL(8),          ALLOCATABLE :: rfx(:,:,:),rgx(:,:,:)
  COMPLEX(8),       INTENT(OUT) :: kfxgx(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:,:),kg(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:,:),liky(:,:,:),likz(:,:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: fDIMS(3)
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE    ! CURRENT SPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2,CSPACE3

  fDIMS=SHAPE(f)

  IF(LEN(CSPACE).EQ.3) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   CSPACE3=CSPACE(3:3)
  ELSE IF(LEN(CSPACE).LT.3) THEN
   CSPACE1="x"
   CSPACE2="y"
   CSPACE3="z"
  ELSE IF(LEN(CSPACE).GT.3) THEN
   PRINT*, "ERROR, GRADfGRADg: NUMBER OF CURRENT SPACE ARE TOO MANY!"
   STOP
  END IF

  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(kg).EQV..FALSE.)   ALLOCATE(kg(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(likz).EQV..FALSE.) ALLOCATE(likz(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))

  CALL KGRIDBUILDER(LX3D,likx)
  CALL KGRIDBUILDER(LY3D,liky)
  CALL KGRIDBUILDER(LZ3D,likz)
  CALL FFTW(f,kf)
  CALL FFTW(g,kg)
  CALL GRADfGRADg(kf,kg,likx,liky,likz,kfxgx,fldID,CSPACE)

  RETURN
 END SUBROUTINE r8r8c8GRADfGRADg3D

 SUBROUTINE r8r4r8GRADfGRADg3DNONE(f,g,LX3D,LY3D,LZ3D,rfxgx)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:),LZ3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:),g(:,:,:)
  REAL(8), INTENT(OUT)             :: rfxgx(:,:,:)

  CALL GRADfGRADg(f,g,LX3D,LY3D,LZ3D,rfxgx,1,"xyz")

  RETURN
 END SUBROUTINE r8r4r8GRADfGRADg3DNONE

 SUBROUTINE r8r4r8GRADfGRADg3D1INT(f,g,LX3D,LY3D,LZ3D,rfxgx,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:),LZ3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:),g(:,:,:)
  REAL(8), INTENT(OUT)             :: rfxgx(:,:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL GRADfGRADg(f,g,LX3D,LY3D,LZ3D,rfxgx,fldID,"xyz")

  RETURN
 END SUBROUTINE r8r4r8GRADfGRADg3D1INT

 SUBROUTINE r8r4r8GRADfGRADg3D1CHR(f,g,LX3D,LY3D,LZ3D,rfxgx,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:),LZ3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:),g(:,:,:)
  REAL(8), INTENT(OUT)             :: rfxgx(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL GRADfGRADg(f,g,LX3D,LY3D,LZ3D,rfxgx,1,CSPACE)

  RETURN
 END SUBROUTINE r8r4r8GRADfGRADg3D1CHR

 SUBROUTINE r8r4r8GRADfGRADg3D(f,g,LX3D,LY3D,LZ3D,rfxgx,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)  :: LX3D(:,:,:),LY3D(:,:,:),LZ3D(:,:,:)
  REAL(8),          INTENT(IN)  :: f(:,:,:),g(:,:,:)
  REAL(8),          INTENT(OUT) :: rfxgx(:,:,:)
  REAL(8),          ALLOCATABLE :: rfx(:,:,:),rgx(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:,:),kg(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:,:),liky(:,:,:),likz(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: kfxgx(:,:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: fDIMS(3)
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE    ! CURRENT SPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2,CSPACE3

  fDIMS=SHAPE(f)

  IF(LEN(CSPACE).EQ.3) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   CSPACE3=CSPACE(3:3)
  ELSE IF(LEN(CSPACE).LT.3) THEN
   CSPACE1="x"
   CSPACE2="y"
   CSPACE3="z"
  ELSE IF(LEN(CSPACE).GT.3) THEN
   PRINT*, "ERROR, GRADfGRADg: NUMBER OF CURRENT SPACE ARE TOO MANY!"
   STOP
  END IF

  IF(PSMDSCHEME(fldID).OR.XPSMDSCHEME(fldID).OR.YPSMDSCHEME(fldID).OR.ZPSMDSCHEME(fldID)) THEN
   IF(ALLOCATED(kf).EQV..FALSE.)    ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
   IF(ALLOCATED(kg).EQV..FALSE.)    ALLOCATE(kg(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
   IF(ALLOCATED(likx).EQV..FALSE.)  ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
   IF(ALLOCATED(liky).EQV..FALSE.)  ALLOCATE(liky(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
   IF(ALLOCATED(likz).EQV..FALSE.)  ALLOCATE(likz(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
   IF(ALLOCATED(kfxgx).EQV..FALSE.) ALLOCATE(kfxgx(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
   CALL KGRIDBUILDER(LX3D,likx)
   CALL KGRIDBUILDER(LY3D,liky)
   CALL KGRIDBUILDER(LZ3D,liky)
   CALL FFTW(f,kf)
   CALL FFTW(g,kg)
   CALL GRADfGRADg(kf,kg,likx,liky,likz,kfxgx,fldID,CSPACE)
   CALL iFFTW(kfxgx,rfxgx)
  ELSE
   IF(ALLOCATED(rfx)) DEALLOCATE(rfx)
   IF(ALLOCATED(rgx)) DEALLOCATE(rgx)
   ALLOCATE(rfx(fDIMS(1),fDIMS(2),fDIMS(3)))
   ALLOCATE(rgx(fDIMS(1),fDIMS(2),fDIMS(3)))
   CALL Df(f,LX3D,rfx,1,fldID,CSPACE1)
   CALL Df(g,LX3D,rgx,1,fldID,CSPACE1)
   rfxgx=rfx*rgx
   CALL Df(f,LY3D,rfx,1,fldID,CSPACE2)
   CALL Df(g,LY3D,rgx,1,fldID,CSPACE2)
   rfxgx=rfxgx+rfx*rgx
   CALL Df(f,LZ3D,rfx,1,fldID,CSPACE3)
   CALL Df(g,LZ3D,rgx,1,fldID,CSPACE3)
   rfxgx=rfxgx+rfx*rgx
  END IF

  RETURN
 END SUBROUTINE r8r4r8GRADfGRADg3D

 SUBROUTINE r8r8r8GRADfGRADg3DNONE(f,g,LX3D,LY3D,LZ3D,rfxgx)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:),LZ3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:),g(:,:,:)
  REAL(8), INTENT(OUT)             :: rfxgx(:,:,:)

  CALL GRADfGRADg(f,g,LX3D,LY3D,LZ3D,rfxgx,1,"xyz")

  RETURN
 END SUBROUTINE r8r8r8GRADfGRADg3DNONE

 SUBROUTINE r8r8r8GRADfGRADg3D1INT(f,g,LX3D,LY3D,LZ3D,rfxgx,fldID)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:),LZ3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:),g(:,:,:)
  REAL(8), INTENT(OUT)             :: rfxgx(:,:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL GRADfGRADg(f,g,LX3D,LY3D,LZ3D,rfxgx,fldID,"xyz")

  RETURN
 END SUBROUTINE r8r8r8GRADfGRADg3D1INT

 SUBROUTINE r8r8r8GRADfGRADg3D1CHR(f,g,LX3D,LY3D,LZ3D,rfxgx,CSPACE)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:),LZ3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:),g(:,:,:)
  REAL(8), INTENT(OUT)             :: rfxgx(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL GRADfGRADg(f,g,LX3D,LY3D,LZ3D,rfxgx,1,CSPACE)

  RETURN
 END SUBROUTINE r8r8r8GRADfGRADg3D1CHR

 SUBROUTINE r8r8r8GRADfGRADg3D(f,g,LX3D,LY3D,LZ3D,rfxgx,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8),          INTENT(IN)  :: LX3D(:,:,:),LY3D(:,:,:),LZ3D(:,:,:)
  REAL(8),          INTENT(IN)  :: f(:,:,:),g(:,:,:)
  REAL(8),          INTENT(OUT) :: rfxgx(:,:,:)
  REAL(8),          ALLOCATABLE :: rfx(:,:,:),rgx(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:,:),kg(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:,:),liky(:,:,:),likz(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: kfxgx(:,:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: fDIMS(3)
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE    ! CURRENT SPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2,CSPACE3

  fDIMS=SHAPE(f)

  IF(LEN(CSPACE).EQ.3) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   CSPACE3=CSPACE(3:3)
  ELSE IF(LEN(CSPACE).LT.3) THEN
   CSPACE1="x"
   CSPACE2="y"
   CSPACE3="z"
  ELSE IF(LEN(CSPACE).GT.3) THEN
   PRINT*, "ERROR, GRADfGRADg: NUMBER OF CURRENT SPACE ARE TOO MANY!"
   STOP
  END IF

  IF(PSMDSCHEME(fldID).OR.XPSMDSCHEME(fldID).OR.YPSMDSCHEME(fldID).OR.ZPSMDSCHEME(fldID)) THEN
   IF(ALLOCATED(kf).EQV..FALSE.)    ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
   IF(ALLOCATED(kg).EQV..FALSE.)    ALLOCATE(kg(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
   IF(ALLOCATED(likx).EQV..FALSE.)  ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
   IF(ALLOCATED(liky).EQV..FALSE.)  ALLOCATE(liky(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
   IF(ALLOCATED(likz).EQV..FALSE.)  ALLOCATE(likz(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
   IF(ALLOCATED(kfxgx).EQV..FALSE.) ALLOCATE(kfxgx(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
   CALL KGRIDBUILDER(LX3D,likx)
   CALL KGRIDBUILDER(LY3D,liky)
   CALL KGRIDBUILDER(LZ3D,liky)
   CALL FFTW(f,kf)
   CALL FFTW(g,kg)
   CALL GRADfGRADg(kf,kg,likx,liky,likz,kfxgx,fldID,CSPACE)
   CALL iFFTW(kfxgx,rfxgx)
  ELSE
   IF(ALLOCATED(rfx)) DEALLOCATE(rfx)
   IF(ALLOCATED(rgx)) DEALLOCATE(rgx)
   ALLOCATE(rfx(fDIMS(1),fDIMS(2),fDIMS(3)))
   ALLOCATE(rgx(fDIMS(1),fDIMS(2),fDIMS(3)))
   CALL Df(f,LX3D,rfx,1,fldID,CSPACE1)
   CALL Df(g,LX3D,rgx,1,fldID,CSPACE1)
   rfxgx=rfx*rgx
   CALL Df(f,LY3D,rfx,1,fldID,CSPACE2)
   CALL Df(g,LY3D,rgx,1,fldID,CSPACE2)
   rfxgx=rfxgx+rfx*rgx
   CALL Df(f,LZ3D,rfx,1,fldID,CSPACE3)
   CALL Df(g,LZ3D,rgx,1,fldID,CSPACE3)
   rfxgx=rfxgx+rfx*rgx
  END IF

  RETURN
 END SUBROUTINE r8r8r8GRADfGRADg3D


!************ FINDING THE LAPLACIAN OF A FIELD (LPLCf) *******************
 SUBROUTINE c8c8c8LPLCf2DNONE(kf,likx,liky,kLPLCf,DORDER)
  IMPLICIT NONE
  COMPLEX(8), INTENT(IN)  :: likx(:,:),liky(:,:)
  COMPLEX(8), INTENT(IN)  :: kf(:,:)
  COMPLEX(8), INTENT(OUT) :: kLPLCf(:,:)
  INTEGER(4), INTENT(IN)  :: DORDER

  CALL LPLCf(kf,likx,liky,kLPLCf,DORDER,1,"xy")

  RETURN
 END SUBROUTINE c8c8c8LPLCf2DNONE

 SUBROUTINE c8c8c8LPLCf2D1INT(kf,likx,liky,kLPLCf,DORDER,fldID)
  IMPLICIT NONE
  COMPLEX(8), INTENT(IN)  :: likx(:,:),liky(:,:)
  COMPLEX(8), INTENT(IN)  :: kf(:,:)
  COMPLEX(8), INTENT(OUT) :: kLPLCf(:,:)
  INTEGER(4), INTENT(IN)  :: DORDER,fldID

  CALL LPLCf(kf,likx,liky,kLPLCf,DORDER,fldID,"xy")

  RETURN
 END SUBROUTINE c8c8c8LPLCf2D1INT

 SUBROUTINE c8c8c8LPLCf2D1CHR(kf,likx,liky,kLPLCf,DORDER,CSPACE)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)  :: likx(:,:),liky(:,:)
  COMPLEX(8),       INTENT(IN)  :: kf(:,:)
  COMPLEX(8),       INTENT(OUT) :: kLPLCf(:,:)
  INTEGER(4),       INTENT(IN)  :: DORDER
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE

  CALL LPLCf(kf,likx,liky,kLPLCf,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE c8c8c8LPLCf2D1CHR

 SUBROUTINE c8c8c8LPLCf2D(kf,likx,liky,kLPLCf,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)  :: likx(:,:),liky(:,:)
  COMPLEX(8),       INTENT(IN)  :: kf(:,:)
  COMPLEX(8),       INTENT(OUT) :: kLPLCf(:,:)
  INTEGER(4),       INTENT(IN)  :: DORDER
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: IORDER
  INTEGER(4)                    :: kfDIMS(2)
  REAL(8),         ALLOCATABLE  :: llplc(:,:)
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2    ! CURRENT SPACE

  IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, LPLCf: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, LPLCf: NUMBER OF CURRENT SPACES ARE NOT ENOUGH"
   STOP
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, LPLCf: NUMBER OF CURRENT SPACES ARE TOO MANY"
   STOP
  END IF

  kfDIMS=SHAPE(kf)
  ALLOCATE(llplc(kfDIMS(1),kfDIMS(2)))
  llplc=REAL(likx*likx+liky*liky,8)

  kLPLCf=kf
  DO IORDER=1,DORDER
   kLPLCf=llplc*kLPLCf
  END DO

  RETURN
 END SUBROUTINE c8c8c8LPLCf2D

 SUBROUTINE r4r4c8LPLCf2DNONE(f,LX2D,LY2D,kLPLCf)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX2D(:,:),LY2D(:,:)
  REAL(4),          INTENT(IN)     :: f(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kLPLCf(:,:)

  CALL LPLCf(f,LX2D,LY2D,kLPLCf,1,"xy")

  RETURN
 END SUBROUTINE r4r4c8LPLCf2DNONE

 SUBROUTINE r4r4c8LPLCf2D1INT(f,LX2D,LY2D,kLPLCf,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(4), INTENT(IN)              :: f(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kLPLCf(:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL LPLCf(f,LX2D,LY2D,kLPLCf,fldID,"xy")

  RETURN
 END SUBROUTINE r4r4c8LPLCf2D1INT

 SUBROUTINE r4r4c8LPLCf2D1CHR(f,LX2D,LY2D,kLPLCf,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(4), INTENT(IN)              :: f(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kLPLCf(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL LPLCf(f,LX2D,LY2D,kLPLCf,1,CSPACE)

  RETURN
 END SUBROUTINE r4r4c8LPLCf2D1CHR

 SUBROUTINE r4r4c8LPLCf2D(f,LX2D,LY2D,kLPLCf,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)  :: LX2D(:,:),LY2D(:,:)
  REAL(4),          INTENT(IN)  :: f(:,:)
  REAL(4),          ALLOCATABLE :: rLPLCf(:,:)
  REAL(4),          ALLOCATABLE :: rfx(:,:),rgy(:,:)
  COMPLEX(8),       INTENT(OUT) :: kLPLCf(:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:),liky(:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: DxDIR,DyDIR
  INTEGER(4)                    :: fDIMS(2)
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2    ! CURRENT SPACE

  fDIMS=SHAPE(f)

  IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, LPLCf: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, LPLCf: NUMBER OF CURRENT SPACES ARE NOT ENOUGH"
   STOP
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, LPLCf: NUMBER OF CURRENT SPACES ARE TOO MANY"
   STOP
  END IF

  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2)))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2)))
  IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(fDIMS(1)/2+1,fDIMS(2)))

  CALL KGRIDBUILDER(LX2D,likx)
  CALL KGRIDBUILDER(LY2D,liky)
  CALL FFTW(f,kf)
  CALL LPLCf(kf,likx,liky,kLPLCf,fldID,CSPACE)

  RETURN
 END SUBROUTINE r4r4c8LPLCf2D

 SUBROUTINE r4r4r4LPLCf2DNONE(f,LX2D,LY2D,rLPLCf)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(4), INTENT(IN)              :: f(:,:)
  REAL(4), INTENT(OUT)             :: rLPLCf(:,:)

  CALL LPLCf(f,LX2D,LY2D,rLPLCf,1,"xy")

  RETURN
 END SUBROUTINE r4r4r4LPLCf2DNONE

 SUBROUTINE r4r4r4LPLCf2D1INT(f,LX2D,LY2D,rLPLCf,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(4), INTENT(IN)              :: f(:,:)
  REAL(4), INTENT(OUT)             :: rLPLCf(:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL LPLCf(f,LX2D,LY2D,rLPLCf,fldID,"xy")

  RETURN
 END SUBROUTINE r4r4r4LPLCf2D1INT

 SUBROUTINE r4r4r4LPLCf2D1CHR(f,LX2D,LY2D,rLPLCf,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(4), INTENT(IN)              :: f(:,:)
  REAL(4), INTENT(OUT)             :: rLPLCf(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL LPLCf(f,LX2D,LY2D,rLPLCf,1,CSPACE)

  RETURN
 END SUBROUTINE r4r4r4LPLCf2D1CHR

 SUBROUTINE r4r4r4LPLCf2D(f,LX2D,LY2D,rLPLCf,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: f(:,:)
  REAL(4),    INTENT(OUT)          :: rLPLCf(:,:)
  REAL(4),    INTENT(IN)           :: LX2D(:,:),LY2D(:,:)
  REAL(4),    ALLOCATABLE          :: rfx(:,:),rgy(:,:),llplc(:,:)
  COMPLEX(8), ALLOCATABLE          :: kf(:,:),likx(:,:),liky(:,:),kLPLCf(:,:)
  INTEGER(4), INTENT(IN)           :: fldID
  INTEGER(4)                       :: fDIM(2)
  INTEGER(4)                       :: DxDIR,DyDIR
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
  CHARACTER(LEN=1)                 :: CSPACE1,CSPACE2    ! CURRENT SPACE

  fDIM=SHAPE(f)

  IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, LPLCf: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, LPLCf: NUMBER OF CURRENT SPACES ARE NOT ENOUGH"
   STOP
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, LPLCf: NUMBER OF CURRENT SPACES ARE TOO MANY"
   STOP
  END IF

  IF(PSMDSCHEME(fldID).OR.XPSMDSCHEME(fldID).OR.YPSMDSCHEME(fldID).OR.ZPSMDSCHEME(fldID)) THEN
   IF(ALLOCATED(kf).EQV..FALSE.)     ALLOCATE(kf(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(likx).EQV..FALSE.)   ALLOCATE(likx(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(liky).EQV..FALSE.)   ALLOCATE(liky(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(llplc).EQV..FALSE.)  ALLOCATE(llplc(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(kLPLCf).EQV..FALSE.) ALLOCATE(kLPLCf(fDIM(1)/2+1,fDIM(2)))
   CALL KGRIDBUILDER(LX2D,likx)
   CALL KGRIDBUILDER(LY2D,liky)
   CALL FFTW(f,kf)
   CALL LPLCf(kf,likx,liky,kLPLCf,1,fldID,CSPACE)
   CALL iFFTW(kLPLCf,rLPLCf)
  ELSE
   IF(ALLOCATED(rfx)) DEALLOCATE(rfx)
   IF(ALLOCATED(rgy)) DEALLOCATE(rgy)
   ALLOCATE(rfx(fDIM(1),fDIM(2)))
   ALLOCATE(rgy(fDIM(1),fDIM(2)))
   CALL Df(f,LX2D,rfx,2,fldID,CSPACE1)
   CALL Df(f,LY2D,rgy,2,fldID,CSPACE2)
   rLPLCf=rfx+rgy
  END IF

  RETURN
 END SUBROUTINE r4r4r4LPLCf2D

 SUBROUTINE r8r4c8LPLCf2DNONE(f,LX2D,LY2D,kLPLCf)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX2D(:,:),LY2D(:,:)
  REAL(8),          INTENT(IN)     :: f(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kLPLCf(:,:)

  CALL LPLCf(f,LX2D,LY2D,kLPLCf,1,"xy")

  RETURN
 END SUBROUTINE r8r4c8LPLCf2DNONE

 SUBROUTINE r8r4c8LPLCf2D1INT(f,LX2D,LY2D,kLPLCf,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kLPLCf(:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL LPLCf(f,LX2D,LY2D,kLPLCf,fldID,"xy")

  RETURN
 END SUBROUTINE r8r4c8LPLCf2D1INT

 SUBROUTINE r8r4c8LPLCf2D1CHR(f,LX2D,LY2D,kLPLCf,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kLPLCf(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL LPLCf(f,LX2D,LY2D,kLPLCf,1,CSPACE)

  RETURN
 END SUBROUTINE r8r4c8LPLCf2D1CHR

 SUBROUTINE r8r4c8LPLCf2D(f,LX2D,LY2D,kLPLCf,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)  :: LX2D(:,:),LY2D(:,:)
  REAL(8),          INTENT(IN)  :: f(:,:)
  REAL(8),          ALLOCATABLE :: rLPLCf(:,:)
  REAL(8),          ALLOCATABLE :: rfx(:,:),rgy(:,:)
  COMPLEX(8),       INTENT(OUT) :: kLPLCf(:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:),liky(:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: fDIMS(2)
  INTEGER(4)                    :: DxDIR,DyDIR
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2    ! CURRENT SPACE

  fDIMS=SHAPE(f)

  IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, LPLCf: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, LPLCf: NUMBER OF CURRENT SPACES ARE NOT ENOUGH"
   STOP
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, LPLCf: NUMBER OF CURRENT SPACES ARE TOO MANY"
   STOP
  END IF

  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2)))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2)))
  IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(fDIMS(1)/2+1,fDIMS(2)))

  CALL KGRIDBUILDER(LX2D,likx)
  CALL KGRIDBUILDER(LY2D,liky)
  CALL FFTW(f,kf)
  CALL LPLCf(kf,likx,liky,kLPLCf,fldID,CSPACE)

  RETURN
 END SUBROUTINE r8r4c8LPLCf2D

 SUBROUTINE r8r8c8LPLCf2DNONE(f,LX2D,LY2D,kLPLCf)
  IMPLICIT NONE
  REAL(8),          INTENT(IN)     :: LX2D(:,:),LY2D(:,:)
  REAL(8),          INTENT(IN)     :: f(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kLPLCf(:,:)

  CALL LPLCf(f,LX2D,LY2D,kLPLCf,1,"xy")

  RETURN
 END SUBROUTINE r8r8c8LPLCf2DNONE

 SUBROUTINE r8r8c8LPLCf2D1INT(f,LX2D,LY2D,kLPLCf,fldID)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kLPLCf(:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL LPLCf(f,LX2D,LY2D,kLPLCf,fldID,"xy")

  RETURN
 END SUBROUTINE r8r8c8LPLCf2D1INT

 SUBROUTINE r8r8c8LPLCf2D1CHR(f,LX2D,LY2D,kLPLCf,CSPACE)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kLPLCf(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL LPLCf(f,LX2D,LY2D,kLPLCf,1,CSPACE)

  RETURN
 END SUBROUTINE r8r8c8LPLCf2D1CHR

 SUBROUTINE r8r8c8LPLCf2D(f,LX2D,LY2D,kLPLCf,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8),          INTENT(IN)  :: LX2D(:,:),LY2D(:,:)
  REAL(8),          INTENT(IN)  :: f(:,:)
  REAL(8),          ALLOCATABLE :: rLPLCf(:,:)
  REAL(8),          ALLOCATABLE :: rfx(:,:),rgy(:,:)
  COMPLEX(8),       INTENT(OUT) :: kLPLCf(:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:),liky(:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: fDIMS(2)
  INTEGER(4)                    :: DxDIR,DyDIR
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2    ! CURRENT SPACE

  fDIMS=SHAPE(f)

  IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, LPLCf: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, LPLCf: NUMBER OF CURRENT SPACES ARE NOT ENOUGH"
   STOP
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, LPLCf: NUMBER OF CURRENT SPACES ARE TOO MANY"
   STOP
  END IF

  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2)))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2)))
  IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(fDIMS(1)/2+1,fDIMS(2)))

  CALL KGRIDBUILDER(LX2D,likx)
  CALL KGRIDBUILDER(LY2D,liky)
  CALL FFTW(f,kf)
  CALL LPLCf(kf,likx,liky,kLPLCf,fldID,CSPACE)

  RETURN
 END SUBROUTINE r8r8c8LPLCf2D

 SUBROUTINE r8r4r8LPLCf2DNONE(f,LX2D,LY2D,rLPLCf)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:)
  REAL(8), INTENT(OUT)             :: rLPLCf(:,:)

  CALL LPLCf(f,LX2D,LY2D,rLPLCf,1,"xy")

  RETURN
 END SUBROUTINE r8r4r8LPLCf2DNONE

 SUBROUTINE r8r4r8LPLCf2D1INT(f,LX2D,LY2D,rLPLCf,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:)
  REAL(8), INTENT(OUT)             :: rLPLCf(:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL LPLCf(f,LX2D,LY2D,rLPLCf,fldID,"xy")

  RETURN
 END SUBROUTINE r8r4r8LPLCf2D1INT

 SUBROUTINE r8r4r8LPLCf2D1CHR(f,LX2D,LY2D,rLPLCf,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:)
  REAL(8), INTENT(OUT)             :: rLPLCf(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL LPLCf(f,LX2D,LY2D,rLPLCf,1,CSPACE)

  RETURN
 END SUBROUTINE r8r4r8LPLCf2D1CHR

 SUBROUTINE r8r4r8LPLCf2D(f,LX2D,LY2D,rLPLCf,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: f(:,:)
  REAL(8), INTENT(OUT)             :: rLPLCf(:,:)
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8),   ALLOCATABLE           :: rfx(:,:),rgy(:,:),llplc(:,:)
  COMPLEX(8),ALLOCATABLE           :: kf(:,:),likx(:,:),liky(:,:),kLPLCf(:,:)
  INTEGER(4), INTENT(IN)           :: fldID
  INTEGER(4)                       :: fDIM(2)
  INTEGER(4)                       :: DxDIR,DyDIR
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
  CHARACTER(LEN=1)                 :: CSPACE1,CSPACE2    ! CURRENT SPACE
  LOGICAL                          :: XYDIR=.FALSE.
  LOGICAL                          :: XZDIR=.FALSE.
  LOGICAL                          :: YZDIR=.FALSE.

  fDIM=SHAPE(f)

  IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   IF((CSPACE1.EQ."x".OR.CSPACE1.EQ."X").AND.(CSPACE2.EQ."y".OR.CSPACE2.EQ."Y")) THEN
    XYDIR=.TRUE.
   ELSE IF((CSPACE1.EQ."x".OR.CSPACE1.EQ."X").AND.(CSPACE2.EQ."z".OR.CSPACE2.EQ."Z")) THEN
    XZDIR=.TRUE.
   ELSE IF((CSPACE1.EQ."y".OR.CSPACE1.EQ."Y").AND.(CSPACE2.EQ."z".OR.CSPACE2.EQ."Z")) THEN
    YZDIR=.TRUE.
   END IF
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, LPLCf: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, LPLCf: NUMBER OF CURRENT SPACES ARE NOT ENOUGH"
   STOP
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, LPLCf: NUMBER OF CURRENT SPACES ARE TOO MANY"
   STOP
  END IF

  IF(PSMDSCHEME(fldID).OR.((XYDIR.AND.XPSMDSCHEME(fldID)).OR.(XZDIR.AND.YPSMDSCHEME(fldID)).OR.(YZDIR.AND.ZPSMDSCHEME(fldID)))) THEN
   IF(ALLOCATED(kf).EQV..FALSE.)     ALLOCATE(kf(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(likx).EQV..FALSE.)   ALLOCATE(likx(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(liky).EQV..FALSE.)   ALLOCATE(liky(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(llplc).EQV..FALSE.)  ALLOCATE(llplc(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(kLPLCf).EQV..FALSE.) ALLOCATE(kLPLCf(fDIM(1)/2+1,fDIM(2)))
   CALL KGRIDBUILDER(LX2D,likx)
   CALL KGRIDBUILDER(LY2D,liky)
   CALL FFTW(f,kf)
   CALL LPLCf(kf,likx,liky,kLPLCf,1,fldID,CSPACE)
   CALL iFFTW(kLPLCf,rLPLCf)
  ELSE
   IF(ALLOCATED(rfx)) DEALLOCATE(rfx)
   IF(ALLOCATED(rgy)) DEALLOCATE(rgy)
   ALLOCATE(rfx(fDIM(1),fDIM(2)))
   ALLOCATE(rgy(fDIM(1),fDIM(2)))
   CALL Df(f,LX2D,rfx,2,fldID,CSPACE1)
   CALL Df(f,LY2D,rgy,2,fldID,CSPACE2)
   rLPLCf=rfx+rgy
  END IF

  RETURN
 END SUBROUTINE r8r4r8LPLCf2D

 SUBROUTINE r8r8r8LPLCf2DNONE(f,LX2D,LY2D,rLPLCf)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:)
  REAL(8), INTENT(OUT)             :: rLPLCf(:,:)

  CALL LPLCf(f,LX2D,LY2D,rLPLCf,1,"xy")

  RETURN
 END SUBROUTINE r8r8r8LPLCf2DNONE

 SUBROUTINE r8r8r8LPLCf2D1INT(f,LX2D,LY2D,rLPLCf,fldID)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:)
  REAL(8), INTENT(OUT)             :: rLPLCf(:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL LPLCf(f,LX2D,LY2D,rLPLCf,fldID,"xy")

  RETURN
 END SUBROUTINE r8r8r8LPLCf2D1INT

 SUBROUTINE r8r8r8LPLCf2D1CHR(f,LX2D,LY2D,rLPLCf,CSPACE)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:)
  REAL(8), INTENT(OUT)             :: rLPLCf(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL LPLCf(f,LX2D,LY2D,rLPLCf,1,CSPACE)

  RETURN
 END SUBROUTINE r8r8r8LPLCf2D1CHR

 SUBROUTINE r8r8r8LPLCf2D(f,LX2D,LY2D,rLPLCf,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:)
  REAL(8), INTENT(OUT)             :: rLPLCf(:,:)
  REAL(8),   ALLOCATABLE           :: rfx(:,:),rgy(:,:),llplc(:,:)
  COMPLEX(8),ALLOCATABLE           :: kf(:,:),likx(:,:),liky(:,:),kLPLCf(:,:)
  INTEGER(4), INTENT(IN)           :: fldID
  INTEGER(4)                       :: fDIM(2)
  INTEGER(4)                       :: DxDIR,DyDIR
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
  CHARACTER(LEN=1)                 :: CSPACE1,CSPACE2    ! CURRENT SPACE
  LOGICAL                          :: XYDIR=.FALSE.
  LOGICAL                          :: XZDIR=.FALSE.
  LOGICAL                          :: YZDIR=.FALSE.

  fDIM=SHAPE(f)

  IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   IF((CSPACE1.EQ."x".OR.CSPACE1.EQ."X").AND.(CSPACE2.EQ."y".OR.CSPACE2.EQ."Y")) THEN
    XYDIR=.TRUE.
   ELSE IF((CSPACE1.EQ."x".OR.CSPACE1.EQ."X").AND.(CSPACE2.EQ."z".OR.CSPACE2.EQ."Z")) THEN
    XZDIR=.TRUE.
   ELSE IF((CSPACE1.EQ."y".OR.CSPACE1.EQ."Y").AND.(CSPACE2.EQ."z".OR.CSPACE2.EQ."Z")) THEN
    YZDIR=.TRUE.
   END IF
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, LPLCf: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, LPLCf: NUMBER OF CURRENT SPACES ARE NOT ENOUGH"
   STOP
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, LPLCf: NUMBER OF CURRENT SPACES ARE TOO MANY"
   STOP
  END IF

  IF(PSMDSCHEME(fldID).OR.((XYDIR.AND.XPSMDSCHEME(fldID)).OR.(XZDIR.AND.YPSMDSCHEME(fldID)).OR.(YZDIR.AND.ZPSMDSCHEME(fldID)))) THEN
   IF(ALLOCATED(kf).EQV..FALSE.)     ALLOCATE(kf(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(likx).EQV..FALSE.)   ALLOCATE(likx(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(liky).EQV..FALSE.)   ALLOCATE(liky(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(llplc).EQV..FALSE.)  ALLOCATE(llplc(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(kLPLCf).EQV..FALSE.) ALLOCATE(kLPLCf(fDIM(1)/2+1,fDIM(2)))
   CALL KGRIDBUILDER(LX2D,likx)
   CALL KGRIDBUILDER(LY2D,liky)
   CALL FFTW(f,kf)
   CALL LPLCf(kf,likx,liky,kLPLCf,1,fldID,CSPACE)
   CALL iFFTW(kLPLCf,rLPLCf)
  ELSE
   IF(ALLOCATED(rfx)) DEALLOCATE(rfx)
   IF(ALLOCATED(rgy)) DEALLOCATE(rgy)
   ALLOCATE(rfx(fDIM(1),fDIM(2)))
   ALLOCATE(rgy(fDIM(1),fDIM(2)))
   CALL Df(f,LX2D,rfx,2,fldID,CSPACE1)
   CALL Df(f,LY2D,rgy,2,fldID,CSPACE2)
   rLPLCf=rfx+rgy
  END IF

  RETURN
 END SUBROUTINE r8r8r8LPLCf2D

 SUBROUTINE c8c8c8LPLCf3DNONE(kf,likx,liky,kLPLCf,DORDER)
  IMPLICIT NONE
  COMPLEX(8), INTENT(IN)  :: likx(:,:,:),liky(:,:,:)
  COMPLEX(8), INTENT(IN)  :: kf(:,:,:)
  COMPLEX(8), INTENT(OUT) :: kLPLCf(:,:,:)
  INTEGER(4), INTENT(IN)  :: DORDER

  CALL LPLCf(kf,likx,liky,kLPLCf,DORDER,1,"xy")

  RETURN
 END SUBROUTINE c8c8c8LPLCf3DNONE

 SUBROUTINE c8c8c8LPLCf3D1INT(kf,likx,liky,kLPLCf,DORDER,fldID)
  IMPLICIT NONE
  COMPLEX(8), INTENT(IN)  :: likx(:,:,:),liky(:,:,:)
  COMPLEX(8), INTENT(IN)  :: kf(:,:,:)
  COMPLEX(8), INTENT(OUT) :: kLPLCf(:,:,:)
  INTEGER(4), INTENT(IN)  :: DORDER,fldID

  CALL LPLCf(kf,likx,liky,kLPLCf,DORDER,fldID,"xy")

  RETURN
 END SUBROUTINE c8c8c8LPLCf3D1INT

 SUBROUTINE c8c8c8LPLCf3D1CHR(kf,likx,liky,kLPLCf,DORDER,CSPACE)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)  :: likx(:,:,:),liky(:,:,:)
  COMPLEX(8),       INTENT(IN)  :: kf(:,:,:)
  COMPLEX(8),       INTENT(OUT) :: kLPLCf(:,:,:)
  INTEGER(4),       INTENT(IN)  :: DORDER
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE

  CALL LPLCf(kf,likx,liky,kLPLCf,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE c8c8c8LPLCf3D1CHR

 SUBROUTINE c8c8c8LPLCf3D(kf,likx,liky,kLPLCf,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)  :: likx(:,:,:),liky(:,:,:)
  COMPLEX(8),       INTENT(IN)  :: kf(:,:,:)
  COMPLEX(8),       INTENT(OUT) :: kLPLCf(:,:,:)
  INTEGER(4),       INTENT(IN)  :: DORDER
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: IORDER
  INTEGER(4)                    :: kfDIMS(3)
  REAL(8),         ALLOCATABLE  :: llplc(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2,CSPACE3    ! CURRENT SPACE

  IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, LPLCf: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
   IF(CSPACE2.EQ.CSPACE3) THEN
    PRINT*, "ERROR, LPLCf: (CSPACE2 = CSPACE3) IS NOT ALLOWED"
    STOP
   END IF
   IF(CSPACE1.EQ.CSPACE3) THEN
    PRINT*, "ERROR, LPLCf: (CSPACE1 = CSPACE3) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, LPLCf: NUMBER OF CURRENT SPACES ARE NOT ENOUGH"
   STOP
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, LPLCf: NUMBER OF CURRENT SPACES ARE TOO MANY"
   STOP
  END IF

  kfDIMS=SHAPE(kf)
  ALLOCATE(llplc(kfDIMS(1),kfDIMS(2),kfDIMS(3)))
  llplc=REAL(likx*likx+liky*liky,8)

  kLPLCf=kf
  DO IORDER=1,DORDER
   kLPLCf=llplc*kLPLCf
  END DO

  RETURN
 END SUBROUTINE c8c8c8LPLCf3D

 SUBROUTINE r4r4c8LPLCf3DNONE(f,LX3D,LY3D,kLPLCf)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(4),          INTENT(IN)     :: f(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kLPLCf(:,:,:)
  INTEGER(4)                       :: MATDIMS(3)

  CALL LPLCf(f,LX3D,LY3D,kLPLCf,1,"xy")

  RETURN
 END SUBROUTINE r4r4c8LPLCf3DNONE

 SUBROUTINE r4r4c8LPLCf3D1INT(f,LX3D,LY3D,kLPLCf,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(4), INTENT(IN)              :: f(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kLPLCf(:,:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL LPLCf(f,LX3D,LY3D,kLPLCf,fldID,"xy")

  RETURN
 END SUBROUTINE r4r4c8LPLCf3D1INT

 SUBROUTINE r4r4c8LPLCf3D1CHR(f,LX3D,LY3D,kLPLCf,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(4), INTENT(IN)              :: f(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kLPLCf(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL LPLCf(f,LX3D,LY3D,kLPLCf,1,CSPACE)

  RETURN
 END SUBROUTINE r4r4c8LPLCf3D1CHR

 SUBROUTINE r4r4c8LPLCf3D(f,LX3D,LY3D,kLPLCf,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)  :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(4),          INTENT(IN)  :: f(:,:,:)
  REAL(4),          ALLOCATABLE :: rLPLCf(:,:,:)
  REAL(4),          ALLOCATABLE :: rfx(:,:,:),rgy(:,:,:)
  COMPLEX(8),       INTENT(OUT) :: kLPLCf(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:,:),liky(:,:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: fDIMS(3)
  INTEGER(4)                    :: DxDIR,DyDIR
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2,CSPACE3    ! CURRENT SPACE

  fDIMS=SHAPE(f)

  IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   CSPACE3=CSPACE(3:3)
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, LPLCf: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
   IF(CSPACE2.EQ.CSPACE3) THEN
    PRINT*, "ERROR, LPLCf: (CSPACE2 = CSPACE3) IS NOT ALLOWED"
    STOP
   END IF
   IF(CSPACE1.EQ.CSPACE3) THEN
    PRINT*, "ERROR, LPLCf: (CSPACE1 = CSPACE3) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).LT.3) THEN
   PRINT*, "ERROR, LPLCf: NUMBER OF CURRENT SPACES ARE NOT ENOUGH"
   STOP
  ELSE IF(LEN(CSPACE).GT.3) THEN
   PRINT*, "ERROR, LPLCf: NUMBER OF CURRENT SPACES ARE TOO MANY"
   STOP
  END IF

  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))

  CALL KGRIDBUILDER(LX3D,likx)
  CALL KGRIDBUILDER(LY3D,liky)
  CALL FFTW(f,kf)
  CALL LPLCf(kf,likx,liky,kLPLCf,fldID,CSPACE)

  RETURN
 END SUBROUTINE r4r4c8LPLCf3D

 SUBROUTINE r4r4r4LPLCf3DNONE(f,LX3D,LY3D,rLPLCf)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(4), INTENT(IN)              :: f(:,:,:)
  REAL(4), INTENT(OUT)             :: rLPLCf(:,:,:)

  CALL LPLCf(f,LX3D,LY3D,rLPLCf,1,"xy")

  RETURN
 END SUBROUTINE r4r4r4LPLCf3DNONE

 SUBROUTINE r4r4r4LPLCf3D1INT(f,LX3D,LY3D,rLPLCf,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(4), INTENT(IN)              :: f(:,:,:)
  REAL(4), INTENT(OUT)             :: rLPLCf(:,:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL LPLCf(f,LX3D,LY3D,rLPLCf,fldID,"xy")

  RETURN
 END SUBROUTINE r4r4r4LPLCf3D1INT

 SUBROUTINE r4r4r4LPLCf3D1CHR(f,LX3D,LY3D,rLPLCf,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(4), INTENT(IN)              :: f(:,:,:)
  REAL(4), INTENT(OUT)             :: rLPLCf(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL LPLCf(f,LX3D,LY3D,rLPLCf,1,CSPACE)

  RETURN
 END SUBROUTINE r4r4r4LPLCf3D1CHR

 SUBROUTINE r4r4r4LPLCf3D(f,LX3D,LY3D,rLPLCf,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: f(:,:,:)
  REAL(4), INTENT(OUT)             :: rLPLCf(:,:,:)
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(4),   ALLOCATABLE           :: rfx(:,:,:),rgy(:,:,:),llplc(:,:,:)
  COMPLEX(8),ALLOCATABLE           :: kf(:,:,:),likx(:,:,:),liky(:,:,:),kLPLCf(:,:,:)
  INTEGER(4), INTENT(IN)           :: fldID
  INTEGER(4)                       :: fDIM(3),ifDIM1,ifDIM2,ifDIM3
  INTEGER(4)                       :: DxDIR,DyDIR
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2,CSPACE3    ! CURRENT SPACE

  fDIM=SHAPE(f)

  IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   CSPACE3=CSPACE(3:3)
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, LPLCf: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
   IF(CSPACE2.EQ.CSPACE3) THEN
    PRINT*, "ERROR, LPLCf: (CSPACE2 = CSPACE3) IS NOT ALLOWED"
    STOP
   END IF
   IF(CSPACE1.EQ.CSPACE3) THEN
    PRINT*, "ERROR, LPLCf: (CSPACE1 = CSPACE3) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).LT.3) THEN
   PRINT*, "ERROR, LPLCf: NUMBER OF CURRENT SPACES ARE NOT ENOUGH"
   STOP
  ELSE IF(LEN(CSPACE).GT.3) THEN
   PRINT*, "ERROR, LPLCf: NUMBER OF CURRENT SPACES ARE TOO MANY"
   STOP
  END IF

  IF(PSMDSCHEME(fldID).OR.XPSMDSCHEME(fldID).OR.YPSMDSCHEME(fldID).OR.ZPSMDSCHEME(fldID)) THEN
   IF(ALLOCATED(kf).EQV..FALSE.)     ALLOCATE(kf(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(likx).EQV..FALSE.)   ALLOCATE(likx(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(liky).EQV..FALSE.)   ALLOCATE(liky(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(llplc).EQV..FALSE.)  ALLOCATE(llplc(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(kLPLCf).EQV..FALSE.) ALLOCATE(kLPLCf(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   CALL KGRIDBUILDER(LX3D,likx)
   CALL KGRIDBUILDER(LY3D,liky)
   CALL FFTW(f,kf)
   CALL LPLCf(kf,likx,liky,kLPLCf,1,fldID,CSPACE)
   CALL iFFTW(kLPLCf,rLPLCf)
  ELSE
   IF(ALLOCATED(rfx)) DEALLOCATE(rfx)
   IF(ALLOCATED(rgy)) DEALLOCATE(rgy)
   ALLOCATE(rfx(fDIM(1),fDIM(2),fDIM(3)))
   ALLOCATE(rgy(fDIM(1),fDIM(2),fDIM(3)))
   CALL Df(f,LX3D,rfx,2,fldID,CSPACE1)
   CALL Df(f,LY3D,rgy,2,fldID,CSPACE2)
   rLPLCf=rfx+rgy
  END IF

  RETURN
 END SUBROUTINE r4r4r4LPLCf3D

 SUBROUTINE r8r4c8LPLCf3DNONE(f,LX3D,LY3D,kLPLCf)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8),          INTENT(IN)     :: f(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kLPLCf(:,:,:)

  CALL LPLCf(f,LX3D,LY3D,kLPLCf,1,"xy")

  RETURN
 END SUBROUTINE r8r4c8LPLCf3DNONE
  
 SUBROUTINE r8r4c8LPLCf3D1INT(f,LX3D,LY3D,kLPLCf,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kLPLCf(:,:,:)
  INTEGER(4),       INTENT(IN)     :: fldID
   
  CALL LPLCf(f,LX3D,LY3D,kLPLCf,fldID,"xy")
   
  RETURN
 END SUBROUTINE r8r4c8LPLCf3D1INT
   
 SUBROUTINE r8r4c8LPLCf3D1CHR(f,LX3D,LY3D,kLPLCf,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kLPLCf(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
  
  CALL LPLCf(f,LX3D,LY3D,kLPLCf,1,CSPACE)

  RETURN
 END SUBROUTINE r8r4c8LPLCf3D1CHR
  
 SUBROUTINE r8r4c8LPLCf3D(f,LX3D,LY3D,kLPLCf,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)  :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8),          INTENT(IN)  :: f(:,:,:)
  REAL(8),          ALLOCATABLE :: rLPLCf(:,:,:)
  REAL(8),          ALLOCATABLE :: rfx(:,:,:),rgy(:,:,:)
  COMPLEX(8),       INTENT(OUT) :: kLPLCf(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:,:),liky(:,:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: fDIMS(3)
  INTEGER(4)                    :: DxDIR,DyDIR
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2,CSPACE3    ! CURRENT SPACE

  fDIMS=SHAPE(f)

  IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   CSPACE3=CSPACE(2:2)
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, LPLCf: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
   IF(CSPACE2.EQ.CSPACE3) THEN
    PRINT*, "ERROR, LPLCf: (CSPACE2 = CSPACE3) IS NOT ALLOWED"
    STOP
   END IF
   IF(CSPACE1.EQ.CSPACE3) THEN
    PRINT*, "ERROR, LPLCf: (CSPACE1 = CSPACE3) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).LT.3) THEN
   PRINT*, "ERROR, LPLCf: NUMBER OF CURRENT SPACES ARE NOT ENOUGH"
   STOP
  ELSE IF(LEN(CSPACE).GT.3) THEN
   PRINT*, "ERROR, LPLCf: NUMBER OF CURRENT SPACES ARE TOO MANY"
   STOP
  END IF

  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))

  CALL KGRIDBUILDER(LX3D,likx)
  CALL KGRIDBUILDER(LY3D,liky)
  CALL FFTW(f,kf)
  CALL LPLCf(kf,likx,liky,kLPLCf,fldID,CSPACE)

  RETURN
 END SUBROUTINE r8r4c8LPLCf3D

 SUBROUTINE r8r8c8LPLCf3DNONE(f,LX3D,LY3D,kLPLCf)
  IMPLICIT NONE
  REAL(8),          INTENT(IN)     :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8),          INTENT(IN)     :: f(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kLPLCf(:,:,:)

  CALL LPLCf(f,LX3D,LY3D,kLPLCf,1,"xy")

  RETURN
 END SUBROUTINE r8r8c8LPLCf3DNONE
  
 SUBROUTINE r8r8c8LPLCf3D1INT(f,LX3D,LY3D,kLPLCf,fldID)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kLPLCf(:,:,:)
  INTEGER(4),       INTENT(IN)     :: fldID
   
  CALL LPLCf(f,LX3D,LY3D,kLPLCf,fldID,"xy")
   
  RETURN
 END SUBROUTINE r8r8c8LPLCf3D1INT
   
 SUBROUTINE r8r8c8LPLCf3D1CHR(f,LX3D,LY3D,kLPLCf,CSPACE)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kLPLCf(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
  
  CALL LPLCf(f,LX3D,LY3D,kLPLCf,1,CSPACE)

  RETURN
 END SUBROUTINE r8r8c8LPLCf3D1CHR
  
 SUBROUTINE r8r8c8LPLCf3D(f,LX3D,LY3D,kLPLCf,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8),          INTENT(IN)  :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8),          INTENT(IN)  :: f(:,:,:)
  REAL(8),          ALLOCATABLE :: rLPLCf(:,:,:)
  REAL(8),          ALLOCATABLE :: rfx(:,:,:),rgy(:,:,:)
  COMPLEX(8),       INTENT(OUT) :: kLPLCf(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:,:),liky(:,:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: fDIMS(3)
  INTEGER(4)                    :: DxDIR,DyDIR
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2,CSPACE3    ! CURRENT SPACE

  fDIMS=SHAPE(f)

  IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   CSPACE3=CSPACE(2:2)
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, LPLCf: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
   IF(CSPACE2.EQ.CSPACE3) THEN
    PRINT*, "ERROR, LPLCf: (CSPACE2 = CSPACE3) IS NOT ALLOWED"
    STOP
   END IF
   IF(CSPACE1.EQ.CSPACE3) THEN
    PRINT*, "ERROR, LPLCf: (CSPACE1 = CSPACE3) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).LT.3) THEN
   PRINT*, "ERROR, LPLCf: NUMBER OF CURRENT SPACES ARE NOT ENOUGH"
   STOP
  ELSE IF(LEN(CSPACE).GT.3) THEN
   PRINT*, "ERROR, LPLCf: NUMBER OF CURRENT SPACES ARE TOO MANY"
   STOP
  END IF

  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))

  CALL KGRIDBUILDER(LX3D,likx)
  CALL KGRIDBUILDER(LY3D,liky)
  CALL FFTW(f,kf)
  CALL LPLCf(kf,likx,liky,kLPLCf,fldID,CSPACE)

  RETURN
 END SUBROUTINE r8r8c8LPLCf3D

 SUBROUTINE r8r4r8LPLCf3DNONE(f,LX3D,LY3D,rLPLCf)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:)
  REAL(8), INTENT(OUT)             :: rLPLCf(:,:,:)

  CALL LPLCf(f,LX3D,LY3D,rLPLCf,1,"xy")

  RETURN
 END SUBROUTINE r8r4r8LPLCf3DNONE

 SUBROUTINE r8r4r8LPLCf3D1INT(f,LX3D,LY3D,rLPLCf,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:)
  REAL(8), INTENT(OUT)             :: rLPLCf(:,:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL LPLCf(f,LX3D,LY3D,rLPLCf,fldID,"xy")
  
  RETURN
 END SUBROUTINE r8r4r8LPLCf3D1INT  
  
 SUBROUTINE r8r4r8LPLCf3D1CHR(f,LX3D,LY3D,rLPLCf,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:)
  REAL(8), INTENT(OUT)             :: rLPLCf(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL LPLCf(f,LX3D,LY3D,rLPLCf,1,CSPACE)
   
  RETURN
 END SUBROUTINE r8r4r8LPLCf3D1CHR

 SUBROUTINE r8r4r8LPLCf3D(f,LX3D,LY3D,rLPLCf,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: f(:,:,:)
  REAL(8), INTENT(OUT)             :: rLPLCf(:,:,:)
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8),   ALLOCATABLE           :: rfx(:,:,:),rgy(:,:,:),llplc(:,:,:)
  COMPLEX(8),ALLOCATABLE           :: kf(:,:,:),likx(:,:,:),liky(:,:,:),kLPLCf(:,:,:)
  INTEGER(4), INTENT(IN)           :: fldID
  INTEGER(4)                       :: fDIM(3),ifDIM1,ifDIM2,ifDIM3
  INTEGER(4)                       :: DxDIR,DyDIR
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
  CHARACTER(LEN=1)                 :: CSPACE1,CSPACE2,CSPACE3    ! CURRENT SPACE

  fDIM=SHAPE(f)

  IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   CSPACE3=CSPACE(3:3)
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, LPLCf: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
   IF(CSPACE2.EQ.CSPACE3) THEN
    PRINT*, "ERROR, LPLCf: (CSPACE2 = CSPACE3) IS NOT ALLOWED"
    STOP
   END IF
   IF(CSPACE1.EQ.CSPACE3) THEN
    PRINT*, "ERROR, LPLCf: (CSPACE1 = CSPACE3) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).LT.3) THEN
   PRINT*, "ERROR, LPLCf: NUMBER OF CURRENT SPACES ARE NOT ENOUGH"
   STOP
  ELSE IF(LEN(CSPACE).GT.3) THEN
   PRINT*, "ERROR, LPLCf: NUMBER OF CURRENT SPACES ARE TOO MANY"
   STOP
  END IF

  IF(PSMDSCHEME(fldID).OR.XPSMDSCHEME(fldID).OR.YPSMDSCHEME(fldID).OR.ZPSMDSCHEME(fldID)) THEN
   IF(ALLOCATED(kf).EQV..FALSE.)     ALLOCATE(kf(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(likx).EQV..FALSE.)   ALLOCATE(likx(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(liky).EQV..FALSE.)   ALLOCATE(liky(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(llplc).EQV..FALSE.)  ALLOCATE(llplc(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(kLPLCf).EQV..FALSE.) ALLOCATE(kLPLCf(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   CALL KGRIDBUILDER(LX3D,likx)
   CALL KGRIDBUILDER(LY3D,liky)
   CALL FFTW(f,kf)
   CALL LPLCf(kf,likx,liky,kLPLCf,1,fldID,CSPACE)
   CALL iFFTW(kLPLCf,rLPLCf)
  ELSE
   IF(ALLOCATED(rfx)) DEALLOCATE(rfx)
   IF(ALLOCATED(rgy)) DEALLOCATE(rgy)
   ALLOCATE(rfx(fDIM(1),fDIM(2),fDIM(3)))
   ALLOCATE(rgy(fDIM(1),fDIM(2),fDIM(3)))
   CALL Df(f,LX3D,rfx,2,fldID,CSPACE1)
   CALL Df(f,LY3D,rgy,2,fldID,CSPACE2)
   rLPLCf=rfx+rgy
  END IF

  RETURN
 END SUBROUTINE r8r4r8LPLCf3D

 SUBROUTINE r8r8r8LPLCf3DNONE(f,LX3D,LY3D,rLPLCf)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:)
  REAL(8), INTENT(OUT)             :: rLPLCf(:,:,:)

  CALL LPLCf(f,LX3D,LY3D,rLPLCf,1,"xy")

  RETURN
 END SUBROUTINE r8r8r8LPLCf3DNONE

 SUBROUTINE r8r8r8LPLCf3D1INT(f,LX3D,LY3D,rLPLCf,fldID)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:)
  REAL(8), INTENT(OUT)             :: rLPLCf(:,:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL LPLCf(f,LX3D,LY3D,rLPLCf,fldID,"xy")
  
  RETURN
 END SUBROUTINE r8r8r8LPLCf3D1INT  
  
 SUBROUTINE r8r8r8LPLCf3D1CHR(f,LX3D,LY3D,rLPLCf,CSPACE)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:)
  REAL(8), INTENT(OUT)             :: rLPLCf(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL LPLCf(f,LX3D,LY3D,rLPLCf,1,CSPACE)
   
  RETURN
 END SUBROUTINE r8r8r8LPLCf3D1CHR

 SUBROUTINE r8r8r8LPLCf3D(f,LX3D,LY3D,rLPLCf,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:)
  REAL(8), INTENT(OUT)             :: rLPLCf(:,:,:)
  REAL(8),   ALLOCATABLE           :: rfx(:,:,:),rgy(:,:,:),llplc(:,:,:)
  COMPLEX(8),ALLOCATABLE           :: kf(:,:,:),likx(:,:,:),liky(:,:,:),kLPLCf(:,:,:)
  INTEGER(4), INTENT(IN)           :: fldID
  INTEGER(4)                       :: fDIM(3),ifDIM1,ifDIM2,ifDIM3
  INTEGER(4)                       :: DxDIR,DyDIR
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
  CHARACTER(LEN=1)                 :: CSPACE1,CSPACE2,CSPACE3    ! CURRENT SPACE

  fDIM=SHAPE(f)

  IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   CSPACE3=CSPACE(3:3)
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, LPLCf: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
   IF(CSPACE2.EQ.CSPACE3) THEN
    PRINT*, "ERROR, LPLCf: (CSPACE2 = CSPACE3) IS NOT ALLOWED"
    STOP
   END IF
   IF(CSPACE1.EQ.CSPACE3) THEN
    PRINT*, "ERROR, LPLCf: (CSPACE1 = CSPACE3) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).LT.3) THEN
   PRINT*, "ERROR, LPLCf: NUMBER OF CURRENT SPACES ARE NOT ENOUGH"
   STOP
  ELSE IF(LEN(CSPACE).GT.3) THEN
   PRINT*, "ERROR, LPLCf: NUMBER OF CURRENT SPACES ARE TOO MANY"
   STOP
  END IF

  IF(PSMDSCHEME(fldID).OR.XPSMDSCHEME(fldID).OR.YPSMDSCHEME(fldID).OR.ZPSMDSCHEME(fldID)) THEN
   IF(ALLOCATED(kf).EQV..FALSE.)     ALLOCATE(kf(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(likx).EQV..FALSE.)   ALLOCATE(likx(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(liky).EQV..FALSE.)   ALLOCATE(liky(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(llplc).EQV..FALSE.)  ALLOCATE(llplc(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(kLPLCf).EQV..FALSE.) ALLOCATE(kLPLCf(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   CALL KGRIDBUILDER(LX3D,likx)
   CALL KGRIDBUILDER(LY3D,liky)
   CALL FFTW(f,kf)
   CALL LPLCf(kf,likx,liky,kLPLCf,1,fldID,CSPACE)
   CALL iFFTW(kLPLCf,rLPLCf)
  ELSE
   IF(ALLOCATED(rfx)) DEALLOCATE(rfx)
   IF(ALLOCATED(rgy)) DEALLOCATE(rgy)
   ALLOCATE(rfx(fDIM(1),fDIM(2),fDIM(3)))
   ALLOCATE(rgy(fDIM(1),fDIM(2),fDIM(3)))
   CALL Df(f,LX3D,rfx,2,fldID,CSPACE1)
   CALL Df(f,LY3D,rgy,2,fldID,CSPACE2)
   rLPLCf=rfx+rgy
  END IF

  RETURN
 END SUBROUTINE r8r8r8LPLCf3D


!************ POSSION BRACKET OF TWO FIELDS (PBKfg) *******************
 SUBROUTINE c8c8c8PBKfg2DNONE(kf,kg,likx,liky,kfxgy)
  IMPLICIT NONE
  COMPLEX(8), INTENT(IN)           :: likx(:,:),liky(:,:)
  COMPLEX(8), INTENT(IN)           :: kf(:,:),kg(:,:)
  COMPLEX(8), INTENT(OUT)          :: kfxgy(:,:)

  CALL PBKfg(kf,kg,likx,liky,kfxgy,1,"xy")

  RETURN
 END SUBROUTINE c8c8c8PBKfg2DNONE

 SUBROUTINE c8c8c8PBKfg2D1INT(kf,kg,likx,liky,kfxgy,fldID)
  IMPLICIT NONE
  COMPLEX(8), INTENT(IN)           :: likx(:,:),liky(:,:)
  COMPLEX(8), INTENT(IN)           :: kf(:,:),kg(:,:)
  COMPLEX(8), INTENT(OUT)          :: kfxgy(:,:)
  INTEGER(4), INTENT(IN)           :: fldID

  CALL PBKfg(kf,kg,likx,liky,kfxgy,fldID,"xy")

  RETURN
 END SUBROUTINE c8c8c8PBKfg2D1INT

 SUBROUTINE c8c8c8PBKfg2D1CHR(kf,kg,likx,liky,kfxgy,CSPACE)
  IMPLICIT NONE
  complex(8),       INTENT(IN)     :: likx(:,:),liky(:,:)
  COMPLEX(8),       INTENT(IN)     :: kf(:,:),kg(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL PBKfg(kf,kg,likx,liky,kfxgy,1,CSPACE)

  RETURN
 END SUBROUTINE c8c8c8PBKfg2D1CHR

 SUBROUTINE c8c8c8PBKfg2D(kf,kg,likx,liky,kfxgy,fldID,CSPACE)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)  :: likx(:,:),liky(:,:)
  COMPLEX(8),       INTENT(IN)  :: kf(:,:),kg(:,:)
  COMPLEX(8),       INTENT(OUT) :: kfxgy(:,:)
  COMPLEX(8),       ALLOCATABLE :: kfx(:,:),kgy(:,:)
  COMPLEX(8),       ALLOCATABLE :: kfxgx(:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: fDIMS(2)
  INTEGER(4)                    :: DxDIR,DyDIR
  REAL(8),          ALLOCATABLE :: rfxgy(:,:)
  REAL(8),          ALLOCATABLE :: rfx(:,:),rgy(:,:)
  REAL(8),          ALLOCATABLE :: tmp(:,:)
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2    ! CURRENT SPACE

  fDIMS=SHAPE(kf)

  IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, PBKfg: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, PBKfg: NUMBER OF CURRENT SPACES ARE NOT ENOUGH"
   STOP
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, PBKfg: NUMBER OF CURRENT SPACES ARE TOO MANY"
   STOP
  END IF

  IF(ALLOCATED(kfxgx).EQV..FALSE.) ALLOCATE(kfxgx(fDIMS(1),fDIMS(2)))
  kfxgy=CMPLX(0.0d0,0.0d0)
  CALL DfDg(kf,kg,likx,liky,kfxgx,fldID,CSPACE)
  kfxgy=kfxgy+kfxgx
  CALL DfDg(kf,kg,liky,likx,kfxgx,fldID,CSPACE)
  kfxgy=kfxgy-kfxgx

  RETURN
 END SUBROUTINE c8c8c8PBKfg2D

 SUBROUTINE r4r4c8PBKfg2DNONE(f,g,LX2D,LY2D,kfxgy)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX2D(:,:),LY2D(:,:)
  REAL(4),    INTENT(IN)           :: f(:,:),g(:,:)
  COMPLEX(8), INTENT(OUT)          :: kfxgy(:,:)

  CALL PBKfg(f,g,LX2D,LY2D,kfxgy,1,"xy")

  RETURN
 END SUBROUTINE r4r4c8PBKfg2DNONE

 SUBROUTINE r4r4c8PBKfg2D1INT(f,g,LX2D,LY2D,kfxgy,fldID)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX2D(:,:),LY2D(:,:)
  REAL(4),    INTENT(IN)           :: f(:,:),g(:,:)
  COMPLEX(8), INTENT(OUT)          :: kfxgy(:,:)
  INTEGER(4), INTENT(IN)           :: fldID

  CALL PBKfg(f,g,LX2D,LY2D,kfxgy,fldID,"xy")

  RETURN
 END SUBROUTINE r4r4c8PBKfg2D1INT

 SUBROUTINE r4r4c8PBKfg2D1CHR(f,g,LX2D,LY2D,kfxgy,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX2D(:,:),LY2D(:,:)
  REAL(4),          INTENT(IN)     :: f(:,:),g(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL PBKfg(f,g,LX2D,LY2D,kfxgy,1,CSPACE)

  RETURN
 END SUBROUTINE r4r4c8PBKfg2D1CHR

 SUBROUTINE r4r4c8PBKfg2D(f,g,LX2D,LY2D,kfxgy,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)  :: LX2D(:,:),LY2D(:,:)
  REAL(4),          INTENT(IN)  :: f(:,:),g(:,:)
  REAL(4),          ALLOCATABLE :: rfxgy(:,:)
  REAL(4),          ALLOCATABLE :: rfx(:,:),rgy(:,:)
  REAL(4),          ALLOCATABLE :: tmp(:,:)
  COMPLEX(8),       INTENT(OUT) :: kfxgy(:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:),kg(:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:),liky(:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: fDIMS(2)
  INTEGER(4)                    :: DxDIR,DyDIR
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2    ! CURRENT SPACE

  fDIMS=SHAPE(f)

  IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, PBKfg: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, PBKfg: NUMBER OF CURRENT SPACES ARE NOT ENOUGH"
   STOP
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, PBKfg: NUMBER OF CURRENT SPACES ARE TOO MANY"
   STOP
  END IF

  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2)))
  IF(ALLOCATED(kg).EQV..FALSE.)   ALLOCATE(kg(fDIMS(1)/2+1,fDIMS(2)))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2)))
  IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(fDIMS(1)/2+1,fDIMS(2)))

  CALL KGRIDBUILDER(LX2D,likx)
  CALL KGRIDBUILDER(LY2D,liky)
  CALL FFTW(f,kf)
  CALL FFTW(g,kg)
  CALL PBKfg(kf,kg,likx,liky,kfxgy,fldID,CSPACE)

  RETURN
 END SUBROUTINE r4r4c8PBKfg2D

 SUBROUTINE r4r4r4PBKfg2DNONE(f,g,LX2D,LY2D,rfxgy)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(4), INTENT(IN)              :: f(:,:),g(:,:)
  REAL(4), INTENT(OUT)             :: rfxgy(:,:)

  CALL PBKfg(f,g,LX2D,LY2D,rfxgy,1,"xy")

  RETURN
 END SUBROUTINE r4r4r4PBKfg2DNONE

 SUBROUTINE r4r4r4PBKfg2D1INT(f,g,LX2D,LY2D,rfxgy,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(4), INTENT(IN)              :: f(:,:),g(:,:)
  REAL(4), INTENT(OUT)             :: rfxgy(:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL PBKfg(f,g,LX2D,LY2D,rfxgy,fldID,"xy")

  RETURN
 END SUBROUTINE r4r4r4PBKfg2D1INT

 SUBROUTINE r4r4r4PBKfg2D1CHR(f,g,LX2D,LY2D,rfxgy,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(4), INTENT(IN)              :: f(:,:),g(:,:)
  REAL(4), INTENT(OUT)             :: rfxgy(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL PBKfg(f,g,LX2D,LY2D,rfxgy,1,CSPACE)

  RETURN
 END SUBROUTINE r4r4r4PBKfg2D1CHR

 SUBROUTINE r4r4r4PBKfg2D(f,g,LX2D,LY2D,rfxgy,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)  :: LX2D(:,:),LY2D(:,:)
  REAL(4),          INTENT(IN)  :: f(:,:),g(:,:)
  REAL(4),          INTENT(OUT) :: rfxgy(:,:)
  REAL(4),          ALLOCATABLE :: rfx(:,:),rgy(:,:)
  COMPLEX(8),       ALLOCATABLE :: kfxgy(:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:),kg(:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:),liky(:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: fDIM(2)
  INTEGER(4)                    :: DxDIR,DyDIR
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2    ! CURRENT SPACE

  fDIM=SHAPE(f)

  IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, PBKfg: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, PBKfg: NUMBER OF CURRENT SPACES ARE NOT ENOUGH"
   STOP
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, PBKfg: NUMBER OF CURRENT SPACES ARE TOO MANY"
   STOP
  END IF


  IF(PSMDSCHEME(fldID).OR.XPSMDSCHEME(fldID).OR.YPSMDSCHEME(fldID).OR.ZPSMDSCHEME(fldID)) THEN
   IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(kg).EQV..FALSE.)   ALLOCATE(kg(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(fDIM(1)/2+1,fDIM(2)))
   CALL KGRIDBUILDER(LX2D,likx)
   CALL KGRIDBUILDER(LY2D,liky)
   CALL FFTW(f,kf)
   CALL FFTW(g,kg)
   CALL PBKfg(kf,kg,likx,liky,kfxgy,fldID,CSPACE)
   CALL iFFTW(kfxgy,rfxgy)
  ELSE
   IF(ALLOCATED(rfx).EQV..FALSE.) ALLOCATE(rfx(fDIM(1),fDIM(2)))
   IF(ALLOCATED(rgy).EQV..FALSE.) ALLOCATE(rgy(fDIM(1),fDIM(2)))
   CALL Df(f,LX2D,rfx,1,fldID,CSPACE1)
   CALL Df(g,LY2D,rgy,1,fldID,CSPACE2)
   rfxgy=rfx*rgy
   CALL Df(f,LY2D,rfx,1,fldID,CSPACE1)
   CALL Df(g,LX2D,rgy,1,fldID,CSPACE2)
   rfxgy=rfxgy-rfx*rgy
  END IF


  RETURN
 END SUBROUTINE r4r4r4PBKfg2D

 SUBROUTINE r8r4c8PBKfg2DNONE(f,g,LX2D,LY2D,kfxgy)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX2D(:,:),LY2D(:,:)
  REAL(8),    INTENT(IN)           :: f(:,:),g(:,:)
  COMPLEX(8), INTENT(OUT)          :: kfxgy(:,:)

  CALL PBKfg(f,g,LX2D,LY2D,kfxgy,1,"xy")

  RETURN
 END SUBROUTINE r8r4c8PBKfg2DNONE

 SUBROUTINE r8r4c8PBKfg2D1INT(f,g,LX2D,LY2D,kfxgy,fldID)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX2D(:,:),LY2D(:,:)
  REAL(8),    INTENT(IN)           :: f(:,:),g(:,:)
  COMPLEX(8), INTENT(OUT)          :: kfxgy(:,:)
  INTEGER(4), INTENT(IN)           :: fldID

  CALL PBKfg(f,g,LX2D,LY2D,kfxgy,fldID,"xy")

  RETURN
 END SUBROUTINE r8r4c8PBKfg2D1INT

 SUBROUTINE r8r4c8PBKfg2D1CHR(f,g,LX2D,LY2D,kfxgy,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX2D(:,:),LY2D(:,:)
  REAL(8),          INTENT(IN)     :: f(:,:),g(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL PBKfg(f,g,LX2D,LY2D,kfxgy,1,CSPACE)

  RETURN
 END SUBROUTINE r8r4c8PBKfg2D1CHR

 SUBROUTINE r8r4c8PBKfg2D(f,g,LX2D,LY2D,kfxgy,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)  :: LX2D(:,:),LY2D(:,:)
  REAL(8),          INTENT(IN)  :: f(:,:),g(:,:)
  REAL(8),          ALLOCATABLE :: rfxgy(:,:)
  REAL(8),          ALLOCATABLE :: rfx(:,:),rgy(:,:)
  COMPLEX(8),       INTENT(OUT) :: kfxgy(:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:),kg(:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:),liky(:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: fDIMS(2)
  INTEGER(4)                    :: DxDIR,DyDIR
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2    ! CURRENT SPACE

  fDIMS=SHAPE(f)

  IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, PBKfg: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, PBKfg: NUMBER OF CURRENT SPACES ARE NOT ENOUGH"
   STOP
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, PBKfg: NUMBER OF CURRENT SPACES ARE TOO MANY"
   STOP
  END IF

  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2)))
  IF(ALLOCATED(kg).EQV..FALSE.)   ALLOCATE(kg(fDIMS(1)/2+1,fDIMS(2)))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2)))
  IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(fDIMS(1)/2+1,fDIMS(2)))

  CALL KGRIDBUILDER(LX2D,likx)
  CALL KGRIDBUILDER(LY2D,liky)
  CALL FFTW(f,kf)
  CALL FFTW(g,kg)
  CALL PBKfg(kf,kg,likx,liky,kfxgy,fldID,CSPACE)

  RETURN
 END SUBROUTINE r8r4c8PBKfg2D

 SUBROUTINE r8r8c8PBKfg2DNONE(f,g,LX2D,LY2D,kfxgy)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)           :: LX2D(:,:),LY2D(:,:)
  REAL(8),    INTENT(IN)           :: f(:,:),g(:,:)
  COMPLEX(8), INTENT(OUT)          :: kfxgy(:,:)

  CALL PBKfg(f,g,LX2D,LY2D,kfxgy,1,"xy")

  RETURN
 END SUBROUTINE r8r8c8PBKfg2DNONE

 SUBROUTINE r8r8c8PBKfg2D1INT(f,g,LX2D,LY2D,kfxgy,fldID)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)           :: LX2D(:,:),LY2D(:,:)
  REAL(8),    INTENT(IN)           :: f(:,:),g(:,:)
  COMPLEX(8), INTENT(OUT)          :: kfxgy(:,:)
  INTEGER(4), INTENT(IN)           :: fldID

  CALL PBKfg(f,g,LX2D,LY2D,kfxgy,fldID,"xy")

  RETURN
 END SUBROUTINE r8r8c8PBKfg2D1INT

 SUBROUTINE r8r8c8PBKfg2D1CHR(f,g,LX2D,LY2D,kfxgy,CSPACE)
  IMPLICIT NONE
  REAL(8),          INTENT(IN)     :: LX2D(:,:),LY2D(:,:)
  REAL(8),          INTENT(IN)     :: f(:,:),g(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL PBKfg(f,g,LX2D,LY2D,kfxgy,1,CSPACE)

  RETURN
 END SUBROUTINE r8r8c8PBKfg2D1CHR

 SUBROUTINE r8r8c8PBKfg2D(f,g,LX2D,LY2D,kfxgy,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8),          INTENT(IN)  :: LX2D(:,:),LY2D(:,:)
  REAL(8),          INTENT(IN)  :: f(:,:),g(:,:)
  REAL(8),          ALLOCATABLE :: rfxgy(:,:)
  REAL(8),          ALLOCATABLE :: rfx(:,:),rgy(:,:)
  COMPLEX(8),       INTENT(OUT) :: kfxgy(:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:),kg(:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:),liky(:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: fDIMS(2)
  INTEGER(4)                    :: DxDIR,DyDIR
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2    ! CURRENT SPACE

  fDIMS=SHAPE(f)

  IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, PBKfg: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, PBKfg: NUMBER OF CURRENT SPACES ARE NOT ENOUGH"
   STOP
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, PBKfg: NUMBER OF CURRENT SPACES ARE TOO MANY"
   STOP
  END IF

  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2)))
  IF(ALLOCATED(kg).EQV..FALSE.)   ALLOCATE(kg(fDIMS(1)/2+1,fDIMS(2)))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2)))
  IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(fDIMS(1)/2+1,fDIMS(2)))

  CALL KGRIDBUILDER(LX2D,likx)
  CALL KGRIDBUILDER(LY2D,liky)
  CALL FFTW(f,kf)
  CALL FFTW(g,kg)
  CALL PBKfg(kf,kg,likx,liky,kfxgy,fldID,CSPACE)

  RETURN
 END SUBROUTINE r8r8c8PBKfg2D

 SUBROUTINE r8r4r8PBKfg2DNONE(f,g,LX2D,LY2D,rfxgy)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:),g(:,:)
  REAL(8), INTENT(OUT)             :: rfxgy(:,:)

  CALL PBKfg(f,g,LX2D,LY2D,rfxgy,1,"xy")

  RETURN
 END SUBROUTINE r8r4r8PBKfg2DNONE

 SUBROUTINE r8r4r8PBKfg2D1INT(f,g,LX2D,LY2D,rfxgy,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:),g(:,:)
  REAL(8), INTENT(OUT)             :: rfxgy(:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL PBKfg(f,g,LX2D,LY2D,rfxgy,fldID,"xy")

  RETURN
 END SUBROUTINE r8r4r8PBKfg2D1INT

 SUBROUTINE r8r4r8PBKfg2D1CHR(f,g,LX2D,LY2D,rfxgy,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:),g(:,:)
  REAL(8), INTENT(OUT)             :: rfxgy(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL PBKfg(f,g,LX2D,LY2D,rfxgy,1,CSPACE)

  RETURN
 END SUBROUTINE r8r4r8PBKfg2D1CHR

 SUBROUTINE r8r4r8PBKfg2D(f,g,LX2D,LY2D,rfxgy,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)  :: LX2D(:,:),LY2D(:,:)
  REAL(8),          INTENT(IN)  :: f(:,:),g(:,:)
  REAL(8),          INTENT(OUT) :: rfxgy(:,:)
  REAL(8),          ALLOCATABLE :: rfx(:,:),rgy(:,:)
  COMPLEX(8),       ALLOCATABLE :: kfxgy(:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:),kg(:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:),liky(:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: fDIM(2)
  INTEGER(4)                    :: DxDIR,DyDIR
  LOGICAL,    SAVE              :: FDMACCESSID=.TRUE.
  LOGICAL,    SAVE              :: PSMACCESSID=.TRUE.
  LOGICAL,    SAVE              :: CSMACCESSID=.TRUE.
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2    ! CURRENT SPACE

  fDIM=SHAPE(f)

  IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, PBKfg: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, PBKfg: NUMBER OF CURRENT SPACES ARE NOT ENOUGH"
   STOP
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, PBKfg: NUMBER OF CURRENT SPACES ARE TOO MANY"
   STOP
  END IF

  IF(PSMDSCHEME(fldID).OR.XPSMDSCHEME(fldID).OR.YPSMDSCHEME(fldID).OR.ZPSMDSCHEME(fldID)) THEN
   IF(PSMACCESSID) THEN
    IF( PSMDSCHEME(fldID)) PRINT*, " PSMDSCHEME("//CHAR(48+fldID)//")"
    IF(XPSMDSCHEME(fldID)) PRINT*, "XPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(YPSMDSCHEME(fldID)) PRINT*, "YPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(ZPSMDSCHEME(fldID)) PRINT*, "ZPSMDSCHEME("//CHAR(48+fldID)//")"
    PSMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(kf).EQV..FALSE.)    ALLOCATE(kf(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(kg).EQV..FALSE.)    ALLOCATE(kg(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(kfxgy).EQV..FALSE.) ALLOCATE(kfxgy(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(likx).EQV..FALSE.)  ALLOCATE(likx(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(liky).EQV..FALSE.)  ALLOCATE(liky(fDIM(1)/2+1,fDIM(2)))
   CALL KGRIDBUILDER(LX2D,likx)
   CALL KGRIDBUILDER(LY2D,liky)
   CALL FFTW(f,kf)
   CALL FFTW(g,kg)
   CALL PBKfg(kf,kg,likx,liky,kfxgy,fldID,CSPACE)
   CALL iFFTW(kfxgy,rfxgy)
  ELSE
   IF(ALLOCATED(rfx).EQV..FALSE.) ALLOCATE(rfx(fDIM(1),fDIM(2)))
   IF(ALLOCATED(rgy).EQV..FALSE.) ALLOCATE(rgy(fDIM(1),fDIM(2)))
   CALL Df(f,LX2D,rfx,1,fldID,CSPACE1)
   CALL Df(g,LY2D,rgy,1,fldID,CSPACE2)
   rfxgy=rfx*rgy
   CALL Df(f,LY2D,rfx,1,fldID,CSPACE1)
   CALL Df(g,LX2D,rgy,1,fldID,CSPACE2)
   rfxgy=rfxgy-rfx*rgy
  END IF

  RETURN
 END SUBROUTINE r8r4r8PBKfg2D

 SUBROUTINE r8r8r8PBKfg2DNONE(f,g,LX2D,LY2D,rfxgy)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:),g(:,:)
  REAL(8), INTENT(OUT)             :: rfxgy(:,:)

  CALL PBKfg(f,g,LX2D,LY2D,rfxgy,1,"xy")

  RETURN
 END SUBROUTINE r8r8r8PBKfg2DNONE

 SUBROUTINE r8r8r8PBKfg2D1INT(f,g,LX2D,LY2D,rfxgy,fldID)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:),g(:,:)
  REAL(8), INTENT(OUT)             :: rfxgy(:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL PBKfg(f,g,LX2D,LY2D,rfxgy,fldID,"xy")

  RETURN
 END SUBROUTINE r8r8r8PBKfg2D1INT

 SUBROUTINE r8r8r8PBKfg2D1CHR(f,g,LX2D,LY2D,rfxgy,CSPACE)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:),g(:,:)
  REAL(8), INTENT(OUT)             :: rfxgy(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL PBKfg(f,g,LX2D,LY2D,rfxgy,1,CSPACE)

  RETURN
 END SUBROUTINE r8r8r8PBKfg2D1CHR

 SUBROUTINE r8r8r8PBKfg2D(f,g,LX2D,LY2D,rfxgy,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8),          INTENT(IN)  :: LX2D(:,:),LY2D(:,:)
  REAL(8),          INTENT(IN)  :: f(:,:),g(:,:)
  REAL(8),          INTENT(OUT) :: rfxgy(:,:)
  REAL(8),          ALLOCATABLE :: rfx(:,:),rgy(:,:)
  COMPLEX(8),       ALLOCATABLE :: kfxgy(:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:),kg(:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:),liky(:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: fDIM(2)
  INTEGER(4)                    :: DxDIR,DyDIR
  LOGICAL,    SAVE              :: FDMACCESSID=.TRUE.
  LOGICAL,    SAVE              :: PSMACCESSID=.TRUE.
  LOGICAL,    SAVE              :: CSMACCESSID=.TRUE.
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2    ! CURRENT SPACE

  fDIM=SHAPE(f)

  IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, PBKfg: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, PBKfg: NUMBER OF CURRENT SPACES ARE NOT ENOUGH"
   STOP
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, PBKfg: NUMBER OF CURRENT SPACES ARE TOO MANY"
   STOP
  END IF

  IF(PSMDSCHEME(fldID).OR.XPSMDSCHEME(fldID).OR.YPSMDSCHEME(fldID).OR.ZPSMDSCHEME(fldID)) THEN
   IF(PSMACCESSID) THEN
    IF( PSMDSCHEME(fldID)) PRINT*, " PSMDSCHEME("//CHAR(48+fldID)//")"
    IF(XPSMDSCHEME(fldID)) PRINT*, "XPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(YPSMDSCHEME(fldID)) PRINT*, "YPSMDSCHEME("//CHAR(48+fldID)//")"
    IF(ZPSMDSCHEME(fldID)) PRINT*, "ZPSMDSCHEME("//CHAR(48+fldID)//")"
    PSMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(kf).EQV..FALSE.)    ALLOCATE(kf(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(kg).EQV..FALSE.)    ALLOCATE(kg(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(kfxgy).EQV..FALSE.) ALLOCATE(kfxgy(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(likx).EQV..FALSE.)  ALLOCATE(likx(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(liky).EQV..FALSE.)  ALLOCATE(liky(fDIM(1)/2+1,fDIM(2)))
   CALL KGRIDBUILDER(LX2D,likx)
   CALL KGRIDBUILDER(LY2D,liky)
   CALL FFTW(f,kf)
   CALL FFTW(g,kg)
   CALL PBKfg(kf,kg,likx,liky,kfxgy,fldID,CSPACE)
   CALL iFFTW(kfxgy,rfxgy)
  ELSE
   IF(ALLOCATED(rfx).EQV..FALSE.) ALLOCATE(rfx(fDIM(1),fDIM(2)))
   IF(ALLOCATED(rgy).EQV..FALSE.) ALLOCATE(rgy(fDIM(1),fDIM(2)))
   CALL Df(f,LX2D,rfx,1,fldID,CSPACE1)
   CALL Df(g,LY2D,rgy,1,fldID,CSPACE2)
   rfxgy=rfx*rgy
   CALL Df(f,LY2D,rfx,1,fldID,CSPACE1)
   CALL Df(g,LX2D,rgy,1,fldID,CSPACE2)
   rfxgy=rfxgy-rfx*rgy
  END IF

  RETURN
 END SUBROUTINE r8r8r8PBKfg2D

 SUBROUTINE c8c8c8PBKfg3DNONE(kf,kg,likx,liky,kfxgy)
  IMPLICIT NONE
  COMPLEX(8), INTENT(IN)           :: likx(:,:,:),liky(:,:,:)
  COMPLEX(8), INTENT(IN)           :: kf(:,:,:),kg(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: kfxgy(:,:,:)

  CALL PBKfg(kf,kg,likx,liky,kfxgy,1,"xy")

  RETURN
 END SUBROUTINE c8c8c8PBKfg3DNONE

 SUBROUTINE c8c8c8PBKfg3D1INT(kf,kg,likx,liky,kfxgy,fldID)
  IMPLICIT NONE
  COMPLEX(8), INTENT(IN)           :: likx(:,:,:),liky(:,:,:)
  COMPLEX(8), INTENT(IN)           :: kf(:,:,:),kg(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: kfxgy(:,:,:)
  INTEGER(4), INTENT(IN)           :: fldID

  CALL PBKfg(kf,kg,likx,liky,kfxgy,fldID,"xy")

  RETURN
 END SUBROUTINE c8c8c8PBKfg3D1INT

 SUBROUTINE c8c8c8PBKfg3D1CHR(kf,kg,likx,liky,kfxgy,CSPACE)
  IMPLICIT NONE
  complex(8),       INTENT(IN)     :: likx(:,:,:),liky(:,:,:)
  COMPLEX(8),       INTENT(IN)     :: kf(:,:,:),kg(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL PBKfg(kf,kg,likx,liky,kfxgy,1,CSPACE)

  RETURN
 END SUBROUTINE c8c8c8PBKfg3D1CHR

 SUBROUTINE c8c8c8PBKfg3D(kf,kg,likx,liky,kfxgy,fldID,CSPACE)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)  :: likx(:,:,:),liky(:,:,:)
  COMPLEX(8),       INTENT(IN)  :: kf(:,:,:),kg(:,:,:)
  COMPLEX(8),       INTENT(OUT) :: kfxgy(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: kfx(:,:,:),kgy(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: kfxgx(:,:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: fDIMS(3)
  INTEGER(4)                    :: DxDIR,DyDIR
  REAL(8),          ALLOCATABLE :: rfxgy(:,:,:)
  REAL(8),          ALLOCATABLE :: rfx(:,:,:),rgy(:,:,:)
  REAL(8),          ALLOCATABLE :: tmp(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2    ! CURRENT SPACE

  fDIMS=SHAPE(kf)

  IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, PBKfg: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, PBKfg: NUMBER OF CURRENT SPACES ARE NOT ENOUGH"
   STOP
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, PBKfg: NUMBER OF CURRENT SPACES ARE TOO MANY"
   STOP
  END IF

  IF(ALLOCATED(kfxgx).EQV..FALSE.) ALLOCATE(kfxgx(fDIMS(1),fDIMS(2),fDIMS(3)))
  kfxgy=CMPLX(0.0d0,0.0d0)
  CALL DfDg(kf,kg,likx,liky,kfxgx,fldID,CSPACE)
  kfxgy=kfxgy+kfxgy
  CALL DfDg(kf,kg,liky,likx,kfxgx,fldID,CSPACE)
  kfxgy=kfxgy-kfxgx

  RETURN
 END SUBROUTINE c8c8c8PBKfg3D

 SUBROUTINE r4r4c8PBKfg3DNONE(f,g,LX3D,LY3D,kfxgy)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(4),    INTENT(IN)           :: f(:,:,:),g(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: kfxgy(:,:,:)
  
  CALL PBKfg(f,g,LX3D,LY3D,kfxgy,1,"xy")

  RETURN
 END SUBROUTINE r4r4c8PBKfg3DNONE
  
 SUBROUTINE r4r4c8PBKfg3D1INT(f,g,LX3D,LY3D,kfxgy,fldID)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(4),    INTENT(IN)           :: f(:,:,:),g(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: kfxgy(:,:,:)
  INTEGER(4), INTENT(IN)           :: fldID
   
  CALL PBKfg(f,g,LX3D,LY3D,kfxgy,fldID,"xy")

  RETURN
 END SUBROUTINE r4r4c8PBKfg3D1INT
  
 SUBROUTINE r4r4c8PBKfg3D1CHR(f,g,LX3D,LY3D,kfxgy,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(4),          INTENT(IN)     :: f(:,:,:),g(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL PBKfg(f,g,LX3D,LY3D,kfxgy,1,CSPACE)
 
  RETURN
 END SUBROUTINE r4r4c8PBKfg3D1CHR  

 SUBROUTINE r4r4c8PBKfg3D(f,g,LX3D,LY3D,kfxgy,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)  :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(4),          INTENT(IN)  :: f(:,:,:),g(:,:,:)
  REAL(4),          ALLOCATABLE :: rfxgy(:,:,:)
  REAL(4),          ALLOCATABLE :: rfx(:,:,:),rgy(:,:,:)
  COMPLEX(8),       INTENT(OUT) :: kfxgy(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:,:),kg(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:,:),liky(:,:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: fDIMS(3)
  INTEGER(4)                    :: DxDIR,DyDIR
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2    ! CURRENT SPACE

  fDIMS=SHAPE(f)

  IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, PBKfg: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, PBKfg: NUMBER OF CURRENT SPACES ARE NOT ENOUGH"
   STOP
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, PBKfg: NUMBER OF CURRENT SPACES ARE TOO MANY"
   STOP
  END IF

  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(kg).EQV..FALSE.)   ALLOCATE(kg(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))

  CALL KGRIDBUILDER(LX3D,likx)
  CALL KGRIDBUILDER(LY3D,liky)
  CALL FFTW(f,kf)
  CALL FFTW(g,kg)
  CALL PBKfg(kf,kg,likx,liky,kfxgy,fldID,CSPACE)

  RETURN
 END SUBROUTINE r4r4c8PBKfg3D

 SUBROUTINE r4r4r4PBKfg3DNONE(f,g,LX3D,LY3D,rfxgy)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(4), INTENT(IN)              :: f(:,:,:),g(:,:,:)
  REAL(4), INTENT(OUT)             :: rfxgy(:,:,:)

  CALL PBKfg(f,g,LX3D,LY3D,rfxgy,1,"xy")

  RETURN
 END SUBROUTINE r4r4r4PBKfg3DNONE

 SUBROUTINE r4r4r4PBKfg3D1INT(f,g,LX3D,LY3D,rfxgy,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(4), INTENT(IN)              :: f(:,:,:),g(:,:,:)
  REAL(4), INTENT(OUT)             :: rfxgy(:,:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL PBKfg(f,g,LX3D,LY3D,rfxgy,fldID,"xy")

  RETURN
 END SUBROUTINE r4r4r4PBKfg3D1INT

 SUBROUTINE r4r4r4PBKfg3D1CHR(f,g,LX3D,LY3D,rfxgy,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(4), INTENT(IN)              :: f(:,:,:),g(:,:,:)
  REAL(4), INTENT(OUT)             :: rfxgy(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL PBKfg(f,g,LX3D,LY3D,rfxgy,1,CSPACE)

  RETURN
 END SUBROUTINE r4r4r4PBKfg3D1CHR

 SUBROUTINE r4r4r4PBKfg3D(f,g,LX3D,LY3D,rfxgy,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)  :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(4),          INTENT(IN)  :: f(:,:,:),g(:,:,:)
  REAL(4),          INTENT(OUT) :: rfxgy(:,:,:)
  REAL(4),          ALLOCATABLE :: rfx(:,:,:),rgy(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: kfxgy(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:,:),kg(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:,:),liky(:,:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: fDIM(3)
  INTEGER(4)                    :: DxDIR,DyDIR
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2    ! CURRENT SPACE

  fDIM=SHAPE(f)

  IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, PBKfg: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, PBKfg: NUMBER OF CURRENT SPACES ARE NOT ENOUGH"
   STOP
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, PBKfg: NUMBER OF CURRENT SPACES ARE TOO MANY"
   STOP
  END IF

  IF(PSMDSCHEME(fldID).OR.XPSMDSCHEME(fldID).OR.YPSMDSCHEME(fldID).OR.ZPSMDSCHEME(fldID)) THEN
   IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(kg).EQV..FALSE.)   ALLOCATE(kg(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   CALL KGRIDBUILDER(LX3D,likx)
   CALL KGRIDBUILDER(LY3D,liky)
   CALL FFTW(f,kf)
   CALL FFTW(g,kg)
   CALL PBKfg(kf,kg,likx,liky,kfxgy,fldID,CSPACE)
   CALL iFFTW(kfxgy,rfxgy)
  ELSE
   IF(ALLOCATED(rfx).EQV..FALSE.) ALLOCATE(rfx(fDIM(1),fDIM(2),fDIM(3)))
   IF(ALLOCATED(rgy).EQV..FALSE.) ALLOCATE(rgy(fDIM(1),fDIM(2),fDIM(3)))
   CALL Df(f,LX3D,rfx,1,fldID,CSPACE1)
   CALL Df(g,LY3D,rgy,1,fldID,CSPACE2)
   rfxgy=rfx*rgy
   CALL Df(f,LY3D,rfx,1,fldID,CSPACE1)
   CALL Df(g,LX3D,rgy,1,fldID,CSPACE2)
   rfxgy=rfxgy-rfx*rgy
  END IF

  RETURN
 END SUBROUTINE r4r4r4PBKfg3D

 SUBROUTINE r8r4c8PBKfg3DNONE(f,g,LX3D,LY3D,kfxgy)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8),    INTENT(IN)           :: f(:,:,:),g(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: kfxgy(:,:,:)

  CALL PBKfg(f,g,LX3D,LY3D,kfxgy,1,"xy")

  RETURN
 END SUBROUTINE r8r4c8PBKfg3DNONE

 SUBROUTINE r8r4c8PBKfg3D1INT(f,g,LX3D,LY3D,kfxgy,fldID)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8),    INTENT(IN)           :: f(:,:,:),g(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: kfxgy(:,:,:)
  INTEGER(4), INTENT(IN)           :: fldID

  CALL PBKfg(f,g,LX3D,LY3D,kfxgy,fldID,"xy")

  RETURN
 END SUBROUTINE r8r4c8PBKfg3D1INT

 SUBROUTINE r8r4c8PBKfg3D1CHR(f,g,LX3D,LY3D,kfxgy,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8),          INTENT(IN)     :: f(:,:,:),g(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL PBKfg(f,g,LX3D,LY3D,kfxgy,1,CSPACE)

  RETURN
 END SUBROUTINE r8r4c8PBKfg3D1CHR

 SUBROUTINE r8r4c8PBKfg3D(f,g,LX3D,LY3D,kfxgy,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)  :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8),          INTENT(IN)  :: f(:,:,:),g(:,:,:)
  REAL(8),          ALLOCATABLE :: rfxgy(:,:,:)
  REAL(8),          ALLOCATABLE :: rfx(:,:,:),rgy(:,:,:)
  COMPLEX(8),       INTENT(OUT) :: kfxgy(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:,:),kg(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:,:),liky(:,:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: fDIMS(3)
  INTEGER(4)                    :: DxDIR,DyDIR
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2    ! CURRENT SPACE

  fDIMS=SHAPE(f)

  IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, PBKfg: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, PBKfg: NUMBER OF CURRENT SPACES ARE NOT ENOUGH"
   STOP
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, PBKfg: NUMBER OF CURRENT SPACES ARE TOO MANY"
   STOP
  END IF

  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(kg).EQV..FALSE.)   ALLOCATE(kg(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))

  CALL KGRIDBUILDER(LX3D,likx)
  CALL KGRIDBUILDER(LY3D,liky)
  CALL FFTW(f,kf)
  CALL FFTW(g,kg)
  CALL PBKfg(kf,kg,likx,liky,kfxgy,fldID,CSPACE)

  RETURN
 END SUBROUTINE r8r4c8PBKfg3D

 SUBROUTINE r8r8c8PBKfg3DNONE(f,g,LX3D,LY3D,kfxgy)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)           :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8),    INTENT(IN)           :: f(:,:,:),g(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: kfxgy(:,:,:)

  CALL PBKfg(f,g,LX3D,LY3D,kfxgy,1,"xy")

  RETURN
 END SUBROUTINE r8r8c8PBKfg3DNONE

 SUBROUTINE r8r8c8PBKfg3D1INT(f,g,LX3D,LY3D,kfxgy,fldID)
  IMPLICIT NONE
  REAL(8),    INTENT(IN)           :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8),    INTENT(IN)           :: f(:,:,:),g(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: kfxgy(:,:,:)
  INTEGER(4), INTENT(IN)           :: fldID

  CALL PBKfg(f,g,LX3D,LY3D,kfxgy,fldID,"xy")

  RETURN
 END SUBROUTINE r8r8c8PBKfg3D1INT

 SUBROUTINE r8r8c8PBKfg3D1CHR(f,g,LX3D,LY3D,kfxgy,CSPACE)
  IMPLICIT NONE
  REAL(8),          INTENT(IN)     :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8),          INTENT(IN)     :: f(:,:,:),g(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfxgy(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL PBKfg(f,g,LX3D,LY3D,kfxgy,1,CSPACE)

  RETURN
 END SUBROUTINE r8r8c8PBKfg3D1CHR

 SUBROUTINE r8r8c8PBKfg3D(f,g,LX3D,LY3D,kfxgy,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8),          INTENT(IN)  :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8),          INTENT(IN)  :: f(:,:,:),g(:,:,:)
  REAL(8),          ALLOCATABLE :: rfxgy(:,:,:)
  REAL(8),          ALLOCATABLE :: rfx(:,:,:),rgy(:,:,:)
  COMPLEX(8),       INTENT(OUT) :: kfxgy(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:,:),kg(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:,:),liky(:,:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: fDIMS(3)
  INTEGER(4)                    :: DxDIR,DyDIR
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2    ! CURRENT SPACE

  fDIMS=SHAPE(f)

  IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, PBKfg: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, PBKfg: NUMBER OF CURRENT SPACES ARE NOT ENOUGH"
   STOP
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, PBKfg: NUMBER OF CURRENT SPACES ARE TOO MANY"
   STOP
  END IF

  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(kg).EQV..FALSE.)   ALLOCATE(kg(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))

  CALL KGRIDBUILDER(LX3D,likx)
  CALL KGRIDBUILDER(LY3D,liky)
  CALL FFTW(f,kf)
  CALL FFTW(g,kg)
  CALL PBKfg(kf,kg,likx,liky,kfxgy,fldID,CSPACE)

  RETURN
 END SUBROUTINE r8r8c8PBKfg3D

 SUBROUTINE r8r4r8PBKfg3DNONE(f,g,LX3D,LY3D,rfxgy)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:),g(:,:,:)
  REAL(8), INTENT(OUT)             :: rfxgy(:,:,:)

  CALL PBKfg(f,g,LX3D,LY3D,rfxgy,1,"xy")

  RETURN
 END SUBROUTINE r8r4r8PBKfg3DNONE

 SUBROUTINE r8r4r8PBKfg3D1INT(f,g,LX3D,LY3D,rfxgy,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:),g(:,:,:)
  REAL(8), INTENT(OUT)             :: rfxgy(:,:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL PBKfg(f,g,LX3D,LY3D,rfxgy,fldID,"xy")

  RETURN
 END SUBROUTINE r8r4r8PBKfg3D1INT

 SUBROUTINE r8r4r8PBKfg3D1CHR(f,g,LX3D,LY3D,rfxgy,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:),g(:,:,:)
  REAL(8), INTENT(OUT)             :: rfxgy(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL PBKfg(f,g,LX3D,LY3D,rfxgy,1,CSPACE)

  RETURN
 END SUBROUTINE r8r4r8PBKfg3D1CHR

 SUBROUTINE r8r4r8PBKfg3D(f,g,LX3D,LY3D,rfxgy,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)  :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8),          INTENT(IN)  :: f(:,:,:),g(:,:,:)
  REAL(8),          INTENT(OUT) :: rfxgy(:,:,:)
  REAL(8),          ALLOCATABLE :: rfx(:,:,:),rgy(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: kfxgy(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:,:),kg(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:,:),liky(:,:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: fDIM(3)
  INTEGER(4)                    :: DxDIR,DyDIR
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2    ! CURRENT SPACE

  fDIM=SHAPE(f)

  IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, PBKfg: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, PBKfg: NUMBER OF CURRENT SPACES ARE NOT ENOUGH"
   STOP
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, PBKfg: NUMBER OF CURRENT SPACES ARE TOO MANY"
   STOP
  END IF

  IF(PSMDSCHEME(fldID).OR.XPSMDSCHEME(fldID).OR.YPSMDSCHEME(fldID).OR.ZPSMDSCHEME(fldID)) THEN
   IF(ALLOCATED(kf).EQV..FALSE.)    ALLOCATE(kf(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(kg).EQV..FALSE.)    ALLOCATE(kg(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(kfxgy).EQV..FALSE.) ALLOCATE(kfxgy(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(likx).EQV..FALSE.)  ALLOCATE(likx(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(liky).EQV..FALSE.)  ALLOCATE(liky(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   CALL KGRIDBUILDER(LX3D,likx)
   CALL KGRIDBUILDER(LY3D,liky)
   CALL FFTW(f,kf)
   CALL FFTW(g,kg)
   CALL PBKfg(kf,kg,likx,liky,kfxgy,fldID,CSPACE)
   CALL iFFTW(kfxgy,rfxgy)
  ELSE
   IF(ALLOCATED(rfx).EQV..FALSE.) ALLOCATE(rfx(fDIM(1),fDIM(2),fDIM(3)))
   IF(ALLOCATED(rgy).EQV..FALSE.) ALLOCATE(rgy(fDIM(1),fDIM(2),fDIM(3)))
   CALL Df(f,LX3D,rfx,1,fldID,CSPACE1)
   CALL Df(g,LY3D,rgy,1,fldID,CSPACE2)
   rfxgy=rfx*rgy
   CALL Df(f,LY3D,rfx,1,fldID,CSPACE1)
   CALL Df(g,LX3D,rgy,1,fldID,CSPACE2)
   rfxgy=rfxgy-rfx*rgy
  END IF

  RETURN
 END SUBROUTINE r8r4r8PBKfg3D

 SUBROUTINE r8r8r8PBKfg3DNONE(f,g,LX3D,LY3D,rfxgy)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:),g(:,:,:)
  REAL(8), INTENT(OUT)             :: rfxgy(:,:,:)

  CALL PBKfg(f,g,LX3D,LY3D,rfxgy,1,"xy")

  RETURN
 END SUBROUTINE r8r8r8PBKfg3DNONE

 SUBROUTINE r8r8r8PBKfg3D1INT(f,g,LX3D,LY3D,rfxgy,fldID)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:),g(:,:,:)
  REAL(8), INTENT(OUT)             :: rfxgy(:,:,:)
  INTEGER(4),       INTENT(IN)     :: fldID

  CALL PBKfg(f,g,LX3D,LY3D,rfxgy,fldID,"xy")

  RETURN
 END SUBROUTINE r8r8r8PBKfg3D1INT

 SUBROUTINE r8r8r8PBKfg3D1CHR(f,g,LX3D,LY3D,rfxgy,CSPACE)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:),g(:,:,:)
  REAL(8), INTENT(OUT)             :: rfxgy(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL PBKfg(f,g,LX3D,LY3D,rfxgy,1,CSPACE)

  RETURN
 END SUBROUTINE r8r8r8PBKfg3D1CHR

 SUBROUTINE r8r8r8PBKfg3D(f,g,LX3D,LY3D,rfxgy,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8),          INTENT(IN)  :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8),          INTENT(IN)  :: f(:,:,:),g(:,:,:)
  REAL(8),          INTENT(OUT) :: rfxgy(:,:,:)
  REAL(8),          ALLOCATABLE :: rfx(:,:,:),rgy(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: kfxgy(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:,:),kg(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:,:),liky(:,:,:)
  INTEGER(4),       INTENT(IN)  :: fldID
  INTEGER(4)                    :: fDIM(3)
  INTEGER(4)                    :: DxDIR,DyDIR
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2    ! CURRENT SPACE

  fDIM=SHAPE(f)

  IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, PBKfg: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, PBKfg: NUMBER OF CURRENT SPACES ARE NOT ENOUGH"
   STOP
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, PBKfg: NUMBER OF CURRENT SPACES ARE TOO MANY"
   STOP
  END IF

  IF(PSMDSCHEME(fldID).OR.XPSMDSCHEME(fldID).OR.YPSMDSCHEME(fldID).OR.ZPSMDSCHEME(fldID)) THEN
   IF(ALLOCATED(kf).EQV..FALSE.)    ALLOCATE(kf(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(kg).EQV..FALSE.)    ALLOCATE(kg(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(kfxgy).EQV..FALSE.) ALLOCATE(kfxgy(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(likx).EQV..FALSE.)  ALLOCATE(likx(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(liky).EQV..FALSE.)  ALLOCATE(liky(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   CALL KGRIDBUILDER(LX3D,likx)
   CALL KGRIDBUILDER(LY3D,liky)
   CALL FFTW(f,kf)
   CALL FFTW(g,kg)
   CALL PBKfg(kf,kg,likx,liky,kfxgy,fldID,CSPACE)
   CALL iFFTW(kfxgy,rfxgy)
  ELSE
   IF(ALLOCATED(rfx).EQV..FALSE.) ALLOCATE(rfx(fDIM(1),fDIM(2),fDIM(3)))
   IF(ALLOCATED(rgy).EQV..FALSE.) ALLOCATE(rgy(fDIM(1),fDIM(2),fDIM(3)))
   CALL Df(f,LX3D,rfx,1,fldID,CSPACE1)
   CALL Df(g,LY3D,rgy,1,fldID,CSPACE2)
   rfxgy=rfx*rgy
   CALL Df(f,LY3D,rfx,1,fldID,CSPACE1)
   CALL Df(g,LX3D,rgy,1,fldID,CSPACE2)
   rfxgy=rfxgy-rfx*rgy
  END IF

  RETURN
 END SUBROUTINE r8r8r8PBKfg3D



!*********************************************************
!             SPACIAL INTEGRATION OF FIELDS
!*********************************************************
 SUBROUTINE c8c8c8intDf1DNONE(kf,likx,kfx,DORDER)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:)
  COMPLEX(8),       INTENT(IN)     :: kf(:)
  COMPLEX(8),       INTENT(OUT)    :: kfx(:)
  INTEGER(4),       INTENT(IN)     :: DORDER

  CALL intDf(kf,likx,kfx,DORDER,1,"x")

  RETURN
 END SUBROUTINE c8c8c8intDf1DNONE

 SUBROUTINE c8c8c8intDf1D1INT(kf,likx,kfx,DORDER,fldID)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:)
  COMPLEX(8),       INTENT(IN)     :: kf(:)
  COMPLEX(8),       INTENT(OUT)    :: kfx(:)
  INTEGER(4),       INTENT(IN)     :: DORDER,fldID

  CALL intDf(kf,likx,kfx,DORDER,fldID,"x")

  RETURN
 END SUBROUTINE c8c8c8intDf1D1INT

 SUBROUTINE c8c8c8intDf1D1CHR(kf,likx,kfx,DORDER,CSPACE)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:)
  COMPLEX(8),       INTENT(IN)     :: kf(:)
  COMPLEX(8),       INTENT(OUT)    :: kfx(:)
  INTEGER(4),       INTENT(IN)     :: DORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE            ! CURRENT SPACE

  CALL intDf(kf,likx,kfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE c8c8c8intDf1D1CHR

 SUBROUTINE c8c8c8intDf1D(kf,likx,kfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:)
  COMPLEX(8),       INTENT(IN)     :: kf(:)
  COMPLEX(8),       INTENT(OUT)    :: kfx(:)
  INTEGER(4),       INTENT(IN)     :: DORDER,fldID
  INTEGER(4)                       :: MATDIM
  INTEGER(4)                       :: IORDER,ifDIM
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE            ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1

  CSPACE1=CSPACE(1:1)

  MATDIM=SIZE(kf)

  kfx=kf
  DO IORDER=1,DORDER
   DO ifDIM=1,MATDIM
    IF(likx(ifDIM).EQ.0.0d0) THEN
     kfx(ifDIM)=CMPLX(0.0d0,0.0d0)
    ELSE
     kfx(ifDIM)=kfx(ifDIM)/likx(ifDIM)
    END IF
   END DO
  END DO

  RETURN
 END SUBROUTINE c8c8c8intDf1D


 SUBROUTINE r4r4c8intDf1DNONE(f,LX1D,kfx,DORDER)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX1D(:)
  REAL(4),    INTENT(IN)           :: f(:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:)
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL intDf(f,LX1D,kfx,DORDER,1,"x")

  RETURN
 END SUBROUTINE r4r4c8intDf1DNONE

 SUBROUTINE r4r4c8intDf1D1INT(f,LX1D,kfx,DORDER,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX1D(:)
  REAL(4), INTENT(IN)              :: f(:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:)
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4), INTENT(IN)           :: fldID

  CALL intDf(f,LX1D,kfx,DORDER,fldID,"x")

  RETURN
 END SUBROUTINE r4r4c8intDf1D1INT

 SUBROUTINE r4r4c8intDf1D1CHR(f,LX1D,kfx,DORDER,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX1D(:)
  REAL(4),          INTENT(IN)     :: f(:)
  COMPLEX(8),       INTENT(OUT)    :: kfx(:)
  INTEGER(4),       INTENT(IN)     :: DORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL intDf(f,LX1D,kfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE r4r4c8intDf1D1CHR

 SUBROUTINE r4r4c8intDf1D(f,LX1D,kfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX1D(:)
  REAL(4),          INTENT(IN)     :: f(:)
  REAL(4),          ALLOCATABLE    :: rfx(:)
  COMPLEX(8),       INTENT(OUT)    :: kfx(:)
  COMPLEX(8),       ALLOCATABLE    :: kf(:),likx(:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
  INTEGER(4),       INTENT(IN)     :: DORDER
  INTEGER(4),       INTENT(IN)     :: fldID
  INTEGER(4)                       :: fDIM

  fDIM=SIZE(f)

  IF(ALLOCATED(kf).EQV..FALSE.) ALLOCATE(kf(fDIM/2+1))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIM/2+1))
  CALL KGRIDBUILDER(LX1D,likx)
  CALL FFTW(f,kf)
  CALL intDf(kf,likx,kfx,DORDER,fldID,CSPACE)

  RETURN
 END SUBROUTINE r4r4c8intDf1D

 SUBROUTINE r4r4r4intDf1DNONE(f,LX1D,rfx,DORDER)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX1D(:)
  REAL(4), INTENT(IN)              :: f(:)
  REAL(4), INTENT(OUT)             :: rfx(:)
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL intDf(f,LX1D,rfx,DORDER,1,"x")

  RETURN
 END SUBROUTINE r4r4r4intDf1DNONE

 SUBROUTINE r4r4r4intDf1D1INT(f,LX1D,rfx,DORDER,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX1D(:)
  REAL(4), INTENT(IN)              :: f(:)
  REAL(4), INTENT(OUT)             :: rfx(:)
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4), INTENT(IN)           :: fldID

  CALL intDf(f,LX1D,rfx,DORDER,fldID,"x")

  RETURN
 END SUBROUTINE r4r4r4intDf1D1INT

 SUBROUTINE r4r4r4intDf1D1CHR(f,LX1D,rfx,DORDER,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX1D(:)
  REAL(4), INTENT(IN)              :: f(:)
  REAL(4), INTENT(OUT)             :: rfx(:)
  INTEGER(4), INTENT(IN)           :: DORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL intDf(f,LX1D,rfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE r4r4r4intDf1D1CHR

 SUBROUTINE r4r4r4intDf1D(f,LX1D,rfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX1D(:)
  REAL(4), INTENT(IN)              :: f(:)
  REAL(4), INTENT(OUT)             :: rfx(:)
  REAL(4), ALLOCATABLE             :: Dx(:)
  REAL(8), ALLOCATABLE             :: DMAT(:,:)
  REAL(4),    ALLOCATABLE          :: tf(:)
  COMPLEX(8), ALLOCATABLE          :: kf(:),kfx(:)
  COMPLEX(8), ALLOCATABLE          :: likx(:)
  INTEGER(4), INTENT(IN)           :: fldID
  INTEGER(4)                       :: fDIM,ifDIM
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4)                       :: IORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE            ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1
  LOGICAL,    SAVE                 :: FDMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: PSMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: CSMACCESSID=.TRUE.
  LOGICAL                          :: XDIR=.FALSE.
  LOGICAL                          :: YDIR=.FALSE.
  LOGICAL                          :: ZDIR=.FALSE.

  fDIM=SIZE(f)

  CSPACE1=CSPACE(1:1)
  IF(CSPACE1.EQ."x".OR.CSPACE1.EQ."X") THEN
   XDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."y".OR.CSPACE1.EQ."Y") THEN
   YDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."z".OR.CSPACE1.EQ."Z") THEN
   ZDIR=.TRUE.
  END IF

  IF(FDMISCHEME(fldID).OR.((XDIR.AND.XFDMISCHEME(fldID)).OR.(YDIR.AND.YFDMISCHEME(fldID)).OR.(ZDIR.AND.ZFDMISCHEME(fldID)))) THEN
   IF(FDMACCESSID) THEN
    IF( FDMISCHEME(fldID)) PRINT*, " FDMISCHEME("//CHAR(48+fldID)//")"
    IF(XFDMISCHEME(fldID)) PRINT*, "XFDMISCHEME("//CHAR(48+fldID)//")"
    IF(YFDMISCHEME(fldID)) PRINT*, "YFDMISCHEME("//CHAR(48+fldID)//")"
    IF(ZFDMISCHEME(fldID)) PRINT*, "ZFDMISCHEME("//CHAR(48+fldID)//")"
    FDMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(DMAT)) DEALLOCATE(DMAT)
   ALLOCATE(DMAT(fDIM,fDIM))
   IF(ALLOCATED(Dx)) DEALLOCATE(Dx)
   ALLOCATE(Dx(fDIM))
   Dx(1:fDIM-1)=LX1D(2:fDIM)-LX1D(1:fDIM-1)
   Dx(fDIM)=Dx(fDIM-1)

   IF(DORDER.EQ.1) THEN
    IF(FDMORDER.EQ.2) THEN
     DMAT=0.0
     DMAT(1,2)=1.0/(2.0*Dx(1))
     DO ifDIM=2,fDIM-1
      DMAT(ifDIM,ifDIM-1)=-1.0/(2.0*Dx(ifDIM));DMAT(ifDIM,ifDIM+1)=1.0/(2.0*Dx(ifDIM))
     END DO
     DMAT(fDIM,fDIM-1)=-1.0/(2.0*Dx(fDIM))
    ELSE IF(FDMORDER.EQ.4) THEN
     DMAT=0.0
     DMAT(1,2)= 8.0/(12.0*Dx(1));DMAT(1,3)=-1.0/(12.0*Dx(1))
     DMAT(2,1)=-8.0/(12.0*Dx(2));DMAT(2,3)=8.0/(12.0*Dx(2));DMAT(2,4)=-1.0/(12.0*Dx(2))
     DO ifDIM=3,fDIM-2
      DMAT(ifDIM,ifDIM-2)=1.0/(12.0*Dx(ifDIM));DMAT(ifDIM,ifDIM-1)=-8.0/(12.0*Dx(ifDIM))
      DMAT(ifDIM,ifDIM+2)=-1.0/(12.0*Dx(ifDIM));DMAT(ifDIM,ifDIM+1)=8.0/(12.0*Dx(ifDIM))
     END DO
     DMAT(fDIM-1,fDIM-3)=1.0/(12.0*Dx(fDIM-1));DMAT(fDIM-1,fDIM-2)=-8.0/(12.0*Dx(fDIM-1));DMAT(fDIM-1,fDIM)=8.0/(12.0*Dx(fDIM-1))
     DMAT(fDIM,fDIM-2)=1.0/(12.0*Dx(fDIM));DMAT(fDIM,fDIM-1)=-8.0/(12.0*Dx(fDIM))
    END IF
   ELSE IF(DORDER.EQ.2) THEN
    IF(FDMORDER.EQ.2) THEN
     DMAT=0.0
     DMAT(1,1)=-2.0/(Dx(1)**2);DMAT(1,2)=1.0/(Dx(1)**2)
     DO ifDIM=2,fDIM-1
      DMAT(ifDIM,ifDIM-1)=1.0/(Dx(ifDIM)**2);DMAT(ifDIM,ifDIM)=-2.0/(Dx(ifDIM)**2);DMAT(ifDIM,ifDIM+1)=1.0/(Dx(ifDIM)**2)
     END DO
     DMAT(fDIM,fDIM-1)=1.0/(Dx(fDIM)**2);DMAT(fDIM,fDIM)=-2.0/(Dx(fDIM)**2)
    ELSE IF(FDMORDER.EQ.4) THEN
     DMAT=0.0
     DMAT(1,1)=-30.0/(12.0*Dx(1)**2);
     DMAT(1,2)=16.0/(12.0*Dx(1)**2);DMAT(1,3)=-1.0/(12.0*Dx(1)**2)
     DMAT(2,1)=16.0/(12.0*Dx(2)**2);
     DMAT(2,2)=-30.0/(12.0*Dx(2)**2);
     DMAT(2,3)=16.0/(12.0*Dx(1)**2);DMAT(2,4)=-1.0/(12.0*Dx(1)**2)
     DO ifDIM=2,fDIM-2
      DMAT(ifDIM,ifDIM-2)=-1.0/(12.0*Dx(ifDIM)**2);DMAT(ifDIM,ifDIM-1)=16.0/(12.0*Dx(ifDIM)**2);
      DMAT(ifDIM,ifDIM)=-30.0/(12.0*Dx(ifDIM)**2);
      DMAT(ifDIM,ifDIM+1)=16.0/(12.0*Dx(ifDIM)**2);DMAT(ifDIM,ifDIM+2)=-1.0/(12.0*Dx(ifDIM)**2)
     END DO
     DMAT(fDIM-1,fDIM-3)=-1.0/(12.0*Dx(fDIM-1)**2);DMAT(fDIM-1,fDIM-2)=16.0/(12.0*Dx(fDIM-1)**2);
     DMAT(fDIM-1,fDIM-1)=-30.0/(12.0*Dx(fDIM-1)**2);
     DMAT(fDIM-1,fDIM)=16.0/(12.0*Dx(fDIM-1)**2)
     DMAT(fDIM,fDIM-2)=-1.0/(12.0*Dx(fDIM)**2);DMAT(fDIM,fDIM-1)=16.0/(12.0*Dx(fDIM)**2);
     DMAT(fDIM,fDIM)=-30.0/(12.0*Dx(fDIM)**2)
    END IF
   END IF
   CALL MATINV(DMAT)
   rfx=MATMUL(DMAT,f)
   DO ifDIM=1,IORDER
    rfx=MATMUL(DMAT,rfx)
   END DO
  ELSE IF(PSMISCHEME(fldID).OR.((XDIR.AND.XPSMISCHEME(fldID)).OR.(YDIR.AND.YPSMISCHEME(fldID)).OR.(ZDIR.AND.ZPSMISCHEME(fldID)))) THEN
   IF(PSMACCESSID) THEN
    IF( PSMISCHEME(fldID)) PRINT*, " PSMISCHEME("//CHAR(48+fldID)//")"
    IF(XPSMISCHEME(fldID)) PRINT*, "XPSMISCHEME("//CHAR(48+fldID)//")"
    IF(YPSMISCHEME(fldID)) PRINT*, "YPSMISCHEME("//CHAR(48+fldID)//")"
    IF(ZPSMISCHEME(fldID)) PRINT*, "ZPSMISCHEME("//CHAR(48+fldID)//")"
    PSMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIM/2+1))
   IF(ALLOCATED(kfx).EQV..FALSE.)  ALLOCATE(kfx(fDIM/2+1))
   IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIM/2+1))
   CALL KGRIDBUILDER(LX1D,likx)
   CALL FFTW(f,kf)
   CALL intDf(kf,likx,kfx,DORDER,fldID,CSPACE)
   CALL iFFTW(kfx,rfx)
  END IF

  XDIR=.FALSE.
  YDIR=.FALSE.
  ZDIR=.FALSE.

  RETURN
 END SUBROUTINE r4r4r4intDf1D

 SUBROUTINE r8r4c8intDf1DNONE(f,LX1D,kfx,DORDER)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX1D(:)
  REAL(8),    INTENT(IN)           :: f(:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:)
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL intDf(f,LX1D,kfx,DORDER,1,"x")

  RETURN
 END SUBROUTINE r8r4c8intDf1DNONE

 SUBROUTINE r8r4c8intDf1D1INT(f,LX1D,kfx,DORDER,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX1D(:)
  REAL(8), INTENT(IN)              :: f(:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:)
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4), INTENT(IN)           :: fldID

  CALL intDf(f,LX1D,kfx,DORDER,fldID,"x")

  RETURN
 END SUBROUTINE r8r4c8intDf1D1INT

 SUBROUTINE r8r4c8intDf1D1CHR(f,LX1D,kfx,DORDER,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX1D(:)
  REAL(8),          INTENT(IN)     :: f(:)
  COMPLEX(8),       INTENT(OUT)    :: kfx(:)
  INTEGER(4),       INTENT(IN)     :: DORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL intDf(f,LX1D,kfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE r8r4c8intDf1D1CHR

 SUBROUTINE r8r4c8intDf1D(f,LX1D,kfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX1D(:)
  REAL(8),          INTENT(IN)     :: f(:)
  REAL(8),          ALLOCATABLE    :: rfx(:)
  COMPLEX(8),       INTENT(OUT)    :: kfx(:)
  COMPLEX(8),       ALLOCATABLE    :: kf(:),likx(:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
  INTEGER(4),       INTENT(IN)     :: DORDER
  INTEGER(4),       INTENT(IN)     :: fldID
  INTEGER(4)                       :: fDIM

  fDIM=SIZE(f)
  
  IF(ALLOCATED(kf).EQV..FALSE.) ALLOCATE(kf(fDIM/2+1))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIM/2+1))
  CALL KGRIDBUILDER(LX1D,likx)
  CALL FFTW(f,kf)
  CALL intDf(kf,likx,kfx,DORDER,fldID,CSPACE)

  RETURN
 END SUBROUTINE r8r4c8intDf1D

 SUBROUTINE r8r4r8intDf1DNONE(f,LX1D,rfx,DORDER)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX1D(:)
  REAL(8), INTENT(IN)              :: f(:)
  REAL(8), INTENT(OUT)             :: rfx(:)
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL intDf(f,LX1D,rfx,DORDER,1,"x")

  RETURN
 END SUBROUTINE r8r4r8intDf1DNONE

 SUBROUTINE r8r4r8intDf1D1INT(f,LX1D,rfx,DORDER,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX1D(:)
  REAL(8), INTENT(IN)              :: f(:)
  REAL(8), INTENT(OUT)             :: rfx(:)
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4), INTENT(IN)           :: fldID

  CALL intDf(f,LX1D,rfx,DORDER,fldID,"x")

  RETURN
 END SUBROUTINE r8r4r8intDf1D1INT

 SUBROUTINE r8r4r8intDf1D1CHR(f,LX1D,rfx,DORDER,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX1D(:)
  REAL(8), INTENT(IN)              :: f(:)
  REAL(8), INTENT(OUT)             :: rfx(:)
  INTEGER(4), INTENT(IN)           :: DORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL intDf(f,LX1D,rfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE r8r4r8intDf1D1CHR

 SUBROUTINE r8r4r8intDf1D(f,LX1D,rfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX1D(:)
  REAL(8), INTENT(IN)              :: f(:)
  REAL(8), INTENT(OUT)             :: rfx(:)
  REAL(8), ALLOCATABLE             :: Dx(:)
  REAL(8), ALLOCATABLE             :: DMAT(:,:)
  REAL(8),    ALLOCATABLE          :: tf(:)
  COMPLEX(8), ALLOCATABLE          :: kf(:),kfx(:)
  COMPLEX(8), ALLOCATABLE          :: likx(:)
  INTEGER(4), INTENT(IN)           :: fldID
  INTEGER(4)                       :: fDIM,ifDIM
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4)                       :: IORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE       ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1
  LOGICAL,    SAVE                 :: FDMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: PSMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: CSMACCESSID=.TRUE.
  LOGICAL                          :: XDIR=.FALSE.
  LOGICAL                          :: YDIR=.FALSE.
  LOGICAL                          :: ZDIR=.FALSE.

  fDIM=SIZE(f)

  CSPACE1=CSPACE(1:1)
  IF(CSPACE1.EQ."x".OR.CSPACE1.EQ."X") THEN
   XDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."y".OR.CSPACE1.EQ."Y") THEN
   YDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."z".OR.CSPACE1.EQ."Z") THEN
   ZDIR=.TRUE.
  END IF

  IF(FDMISCHEME(fldID).OR.((XDIR.AND.XFDMISCHEME(fldID)).OR.(YDIR.AND.YFDMISCHEME(fldID)).OR.(ZDIR.AND.ZFDMISCHEME(fldID)))) THEN
   IF(FDMACCESSID) THEN
    IF( FDMISCHEME(fldID)) PRINT*, " FDMISCHEME("//CHAR(48+fldID)//")"
    IF(XFDMISCHEME(fldID)) PRINT*, "XFDMISCHEME("//CHAR(48+fldID)//")"
    IF(YFDMISCHEME(fldID)) PRINT*, "YFDMISCHEME("//CHAR(48+fldID)//")"
    IF(ZFDMISCHEME(fldID)) PRINT*, "ZFDMISCHEME("//CHAR(48+fldID)//")"
    FDMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(DMAT)) DEALLOCATE(DMAT)
   ALLOCATE(DMAT(fDIM,fDIM))
   IF(ALLOCATED(Dx)) DEALLOCATE(Dx)
   ALLOCATE(Dx(fDIM))
   Dx(1:fDIM-1)=LX1D(2:fDIM)-LX1D(1:fDIM-1)
   Dx(fDIM)=Dx(fDIM-1)

   IF(DORDER.EQ.1) THEN
    IF(FDMORDER.EQ.2) THEN
     DMAT=0.0d0
     DMAT(1,2)=1.0d0/(2.0d0*Dx(1))
     DO ifDIM=2,fDIM-1
      DMAT(ifDIM,ifDIM-1)=-1.0d0/(2.0d0*Dx(ifDIM));DMAT(ifDIM,ifDIM+1)=1.0d0/(2.0d0*Dx(ifDIM))
     END DO
     DMAT(fDIM,fDIM-1)=-1.0d0/(2.0d0*Dx(fDIM))
    ELSE IF(FDMORDER.EQ.4) THEN
     DMAT=0.0d0
     DMAT(1,2)= 8.0d0/(12.0d0*Dx(1));DMAT(1,3)=-1.0d0/(12.0d0*Dx(1))
     DMAT(2,1)=-8.0d0/(12.0d0*Dx(2));DMAT(2,3)=8.0d0/(12.0d0*Dx(2));DMAT(2,4)=-1.0d0/(12.0d0*Dx(2))
     DO ifDIM=3,fDIM-2
      DMAT(ifDIM,ifDIM-2)=1.0d0/(12.0d0*Dx(ifDIM));DMAT(ifDIM,ifDIM-1)=-8.0d0/(12.0d0*Dx(ifDIM))
      DMAT(ifDIM,ifDIM+2)=-1.0d0/(12.0d0*Dx(ifDIM));DMAT(ifDIM,ifDIM+1)=8.0d0/(12.0d0*Dx(ifDIM))
     END DO
     DMAT(fDIM-1,fDIM-3)=1.0d0/(12.0d0*Dx(fDIM-1));DMAT(fDIM-1,fDIM-2)=-8.0d0/(12.0d0*Dx(fDIM-1));DMAT(fDIM-1,fDIM)=8.0d0/(12.0d0*Dx(fDIM-1))
     DMAT(fDIM,fDIM-2)=1.0d0/(12.0d0*Dx(fDIM));DMAT(fDIM,fDIM-1)=-8.0d0/(12.0d0*Dx(fDIM))
    END IF
   ELSE IF(DORDER.EQ.2) THEN
    IF(FDMORDER.EQ.2) THEN
     DMAT=0.0d0
     DMAT(1,1)=-2.0d0/(Dx(1)**2);DMAT(1,2)=1.0d0/(Dx(1)**2)
     DO ifDIM=2,fDIM-1
      DMAT(ifDIM,ifDIM-1)=1.0d0/(Dx(ifDIM)**2);DMAT(ifDIM,ifDIM)=-2.0d0/(Dx(ifDIM)**2);DMAT(ifDIM,ifDIM+1)=1.0d0/(Dx(ifDIM)**2)
     END DO
     DMAT(fDIM,fDIM-1)=1.0d0/(Dx(fDIM)**2);DMAT(fDIM,fDIM)=-2.0d0/(Dx(fDIM)**2)
    ELSE IF(FDMORDER.EQ.4) THEN
     DMAT=0.0
     DMAT(1,1)=-30.0d0/(12.0d0*Dx(1)**2);
     DMAT(1,2)=16.0d0/(12.0d0*Dx(1)**2);DMAT(1,3)=-1.0d0/(12.0d0*Dx(1)**2)
     DMAT(2,1)=16.0d0/(12.0d0*Dx(2)**2);
     DMAT(2,2)=-30.0d0/(12.0d0*Dx(2)**2);
     DMAT(2,3)=16.0d0/(12.0d0*Dx(1)**2);DMAT(2,4)=-1.0/(12.0d0*Dx(1)**2)
     DO ifDIM=2,fDIM-2
      DMAT(ifDIM,ifDIM-2)=-1.0d0/(12.0d0*Dx(ifDIM)**2);DMAT(ifDIM,ifDIM-1)=16.0d0/(12.0d0*Dx(ifDIM)**2);
      DMAT(ifDIM,ifDIM)=-30.0d0/(12.0d0*Dx(ifDIM)**2);
      DMAT(ifDIM,ifDIM+1)=16.0d0/(12.0d0*Dx(ifDIM)**2);DMAT(ifDIM,ifDIM+2)=-1.0d0/(12.0d0*Dx(ifDIM)**2)
     END DO
     DMAT(fDIM-1,fDIM-3)=-1.0d0/(12.0d0*Dx(fDIM-1)**2);DMAT(fDIM-1,fDIM-2)=16.0d0/(12.0d0*Dx(fDIM-1)**2);
     DMAT(fDIM-1,fDIM-1)=-30.0d0/(12.0d0*Dx(fDIM-1)**2);
     DMAT(fDIM-1,fDIM)=16.0d0/(12.0d0*Dx(fDIM-1)**2)
     DMAT(fDIM,fDIM-2)=-1.0d0/(12.0d0*Dx(fDIM)**2);DMAT(fDIM,fDIM-1)=16.0d0/(12.0*Dx(fDIM)**2);
     DMAT(fDIM,fDIM)=-30.0d0/(12.0d0*Dx(fDIM)**2)
    END IF
   END IF
   CALL MATINV(DMAT)
   rfx=MATMUL(DMAT,f)
   DO ifDIM=1,IORDER
    rfx=MATMUL(DMAT,rfx)
   END DO
  ELSE IF(PSMISCHEME(fldID).OR.((XDIR.AND.XPSMISCHEME(fldID)).OR.(YDIR.AND.YPSMISCHEME(fldID)).OR.(ZDIR.AND.ZPSMISCHEME(fldID)))) THEN
   IF(PSMACCESSID) THEN
    IF( PSMISCHEME(fldID)) PRINT*, " PSMISCHEME(",fldID,")"
    IF(XPSMISCHEME(fldID)) PRINT*, "XPSMISCHEME(",fldID,")"
    IF(YPSMISCHEME(fldID)) PRINT*, "YPSMISCHEME(",fldID,")"
    IF(ZPSMISCHEME(fldID)) PRINT*, "ZPSMISCHEME(",fldID,")"
    PSMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(kf).EQV..FALSE.)    ALLOCATE(kf(fDIM/2+1))
   IF(ALLOCATED(kfx).EQV..FALSE.)   ALLOCATE(kfx(fDIM/2+1))
   IF(ALLOCATED(likx).EQV..FALSE.)  ALLOCATE(likx(fDIM/2+1))
   CALL KGRIDBUILDER(LX1D,likx)
   CALL FFTW(f,kf)
   CALL intDf(kf,likx,kfx,DORDER,fldID,CSPACE)
   CALL iFFTW(kfx,rfx)
  END IF

  XDIR=.FALSE.
  YDIR=.FALSE.
  ZDIR=.FALSE.

  RETURN
 END SUBROUTINE r8r4r8intDf1D

 SUBROUTINE c8c8c8intDf2DNONE(kf,likx,kfx,DORDER)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:,:)
  COMPLEX(8),       INTENT(IN)     :: kf(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfx(:,:)
  INTEGER(4),       INTENT(IN)     :: DORDER

  CALL intDf(kf,likx,kfx,DORDER,1,"x")

  RETURN
 END SUBROUTINE c8c8c8intDf2DNONE

 SUBROUTINE c8c8c8intDf2D1INT(kf,likx,kfx,DORDER,fldID)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:,:)
  COMPLEX(8),       INTENT(IN)     :: kf(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfx(:,:)
  INTEGER(4),       INTENT(IN)     :: DORDER,fldID

  CALL intDf(kf,likx,kfx,DORDER,fldID,"x")

  RETURN
 END SUBROUTINE c8c8c8intDf2D1INT

 SUBROUTINE c8c8c8intDf2D1CHR(kf,likx,kfx,DORDER,CSPACE)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:,:)
  COMPLEX(8),       INTENT(IN)     :: kf(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfx(:,:)
  INTEGER(4),       INTENT(IN)     :: DORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE            ! CURRENT SPACE

  CALL intDf(kf,likx,kfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE c8c8c8intDf2D1CHR

 SUBROUTINE c8c8c8intDf2D(kf,likx,kfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:,:)
  COMPLEX(8),       INTENT(IN)     :: kf(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfx(:,:)
  INTEGER(4),       INTENT(IN)     :: DORDER,fldID
  INTEGER(4)                       :: MATDIMS(2)
  INTEGER(4)                       :: IORDER,ifDIM1,ifDIM2
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE            ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1

  CSPACE1=CSPACE(1:1)

  MATDIMS=SHAPE(kf)
  kfx=kf
  DO IORDER=1,DORDER
   DO ifDIM1=1,MATDIMS(1)
    DO ifDIM2=1,MATDIMS(2)
     IF(likx(ifDIM1,ifDIM2).EQ.0.0d0) THEN
      kfx(ifDIM1,ifDIM2)=CMPLX(0.0d0,0.0d0)
     ELSE
      kfx(ifDIM1,ifDIM2)=kfx(ifDIM1,ifDIM2)/likx(ifDIM1,ifDIM2)
     END IF
    END DO
   END DO
  END DO

  RETURN
 END SUBROUTINE c8c8c8intDf2D


 SUBROUTINE r4r4c8intDf2DNONE(f,LX2D,kfx,DORDER)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX2D(:,:)
  REAL(4),    INTENT(IN)           :: f(:,:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:,:)
  INTEGER(4), INTENT(IN)           :: DORDER
     
  CALL intDf(f,LX2D,kfx,DORDER,1,"x")
   
  RETURN
 END SUBROUTINE r4r4c8intDf2DNONE
   
 SUBROUTINE r4r4c8intDf2D1INT(f,LX2D,kfx,DORDER,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:)
  REAL(4), INTENT(IN)              :: f(:,:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:,:)
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4), INTENT(IN)           :: fldID
   
  CALL intDf(f,LX2D,kfx,DORDER,fldID,"x")
   
  RETURN
 END SUBROUTINE r4r4c8intDf2D1INT
   
 SUBROUTINE r4r4c8intDf2D1CHR(f,LX2D,kfx,DORDER,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX2D(:,:)
  REAL(4),          INTENT(IN)     :: f(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfx(:,:)
  INTEGER(4),       INTENT(IN)     :: DORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
  
  CALL intDf(f,LX2D,kfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE r4r4c8intDf2D1CHR
  
 SUBROUTINE r4r4c8intDf2D(f,LX2D,kfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX2D(:,:)
  REAL(4),          INTENT(IN)     :: f(:,:)
  REAL(4),          ALLOCATABLE    :: rfx(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfx(:,:)
  COMPLEX(8),       ALLOCATABLE    :: kf(:,:),likx(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
  INTEGER(4),       INTENT(IN)     :: DORDER
  INTEGER(4),       INTENT(IN)     :: fldID
  INTEGER(4)                       :: fDIMS(2)

  fDIMS=SHAPE(f)

  IF(ALLOCATED(kf).EQV..FALSE.) ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2)))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2)))
  CALL KGRIDBUILDER(LX2D,likx)
  CALL FFTW(f,kf)
  CALL intDf(kf,likx,kfx,DORDER,fldID,CSPACE)

  RETURN
 END SUBROUTINE r4r4c8intDf2D

 SUBROUTINE r4r4r4intDf2DNONE(f,LX2D,rfx,DORDER)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:)
  REAL(4), INTENT(IN)              :: f(:,:)
  REAL(4), INTENT(OUT)             :: rfx(:,:)
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL intDf(f,LX2D,rfx,DORDER,1,"x")

  RETURN
 END SUBROUTINE r4r4r4intDf2DNONE

 SUBROUTINE r4r4r4intDf2D1INT(f,LX2D,rfx,DORDER,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:)
  REAL(4), INTENT(IN)              :: f(:,:)
  REAL(4), INTENT(OUT)             :: rfx(:,:)
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4), INTENT(IN)           :: fldID

  CALL intDf(f,LX2D,rfx,DORDER,fldID,"x")

  RETURN
 END SUBROUTINE r4r4r4intDf2D1INT

 SUBROUTINE r4r4r4intDf2D1CHR(f,LX2D,rfx,DORDER,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:)
  REAL(4), INTENT(IN)              :: f(:,:)
  REAL(4), INTENT(OUT)             :: rfx(:,:)
  INTEGER(4), INTENT(IN)           :: DORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL intDf(f,LX2D,rfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE r4r4r4intDf2D1CHR

 SUBROUTINE r4r4r4intDf2D(f,LX2D,rfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:)
  REAL(4), INTENT(IN)              :: f(:,:)
  REAL(4), INTENT(OUT)             :: rfx(:,:)
  REAL(8),    ALLOCATABLE          :: tf(:,:)
  COMPLEX(8), ALLOCATABLE          :: kf(:,:),kfx(:,:)
  COMPLEX(8), ALLOCATABLE          :: likx(:,:)
  INTEGER(4), INTENT(IN)           :: fldID
  INTEGER(4)                       :: fDIM(2),DxDIR,ifDIM
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4)                       :: IORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE              ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1
  LOGICAL,    SAVE                 :: FDMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: PSMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: CSMACCESSID=.TRUE.
  LOGICAL                          :: XDIR=.FALSE.
  LOGICAL                          :: YDIR=.FALSE.
  LOGICAL                          :: ZDIR=.FALSE.

  fDIM=SHAPE(f)

  DxDIR=1
  DO ifDIM=1,fDIM(2)
   IF(LX2D(1,ifDIM).NE.LX2D(1,1)) THEN
    DxDIR=2
    EXIT
   END IF
  END DO

  CSPACE1=CSPACE(1:1)
  IF(CSPACE1.EQ."x".OR.CSPACE1.EQ."X") THEN
   XDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."y".OR.CSPACE1.EQ."Y") THEN
   YDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."z".OR.CSPACE1.EQ."Z") THEN
   ZDIR=.TRUE.
  END IF

  IF(PSMISCHEME(fldID).OR.((XDIR.AND.XPSMISCHEME(fldID)).OR.(YDIR.AND.YPSMISCHEME(fldID)).OR.(ZDIR.AND.ZPSMISCHEME(fldID)))) THEN
   IF(PSMACCESSID) THEN
    IF( PSMISCHEME(fldID)) PRINT*, " PSMISCHEME("//CHAR(48+fldID)//")"
    IF(XPSMISCHEME(fldID)) PRINT*, "XPSMISCHEME("//CHAR(48+fldID)//")"
    IF(YPSMISCHEME(fldID)) PRINT*, "YPSMISCHEME("//CHAR(48+fldID)//")"
    IF(ZPSMISCHEME(fldID)) PRINT*, "ZPSMISCHEME("//CHAR(48+fldID)//")"
    PSMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(kf).EQV..FALSE.)    ALLOCATE(kf(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(kfx).EQV..FALSE.)   ALLOCATE(kfx(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(likx).EQV..FALSE.)  ALLOCATE(likx(fDIM(1)/2+1,fDIM(2)))
   CALL KGRIDBUILDER(LX2D,likx)
   CALL FFTW(f,kf)
   CALL intDf(kf,likx,kfx,DORDER,fldID,CSPACE)
   CALL iFFTW(kfx,rfx)
  ELSE
   IF(DxDIR.EQ.1) THEN
    DO ifDIM=1,fDIM(2)
     CALL intDf(f(:,ifDIM),LX2D(:,ifDIM),rfx(:,ifDIM),DORDER,fldID,CSPACE1)
    END DO
   ELSE IF(DxDIR.EQ.2) THEN
    DO ifDIM=1,fDIM(1)
     CALL intDf(f(ifDIM,:),LX2D(ifDIM,:),rfx(ifDIM,:),DORDER,fldID,CSPACE1)
    END DO
   END IF
  END IF

  RETURN
 END SUBROUTINE r4r4r4intDf2D

 SUBROUTINE r8r4c8intDf2DNONE(f,LX2D,kfx,DORDER)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX2D(:,:)
  REAL(8),    INTENT(IN)           :: f(:,:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:,:)
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL intDf(f,LX2D,kfx,DORDER,1,"x")

  RETURN
 END SUBROUTINE r8r4c8intDf2DNONE

 SUBROUTINE r8r4c8intDf2D1INT(f,LX2D,kfx,DORDER,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:,:)
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4), INTENT(IN)           :: fldID

  CALL intDf(f,LX2D,kfx,DORDER,fldID,"x")

  RETURN
 END SUBROUTINE r8r4c8intDf2D1INT

 SUBROUTINE r8r4c8intDf2D1CHR(f,LX2D,kfx,DORDER,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX2D(:,:)
  REAL(8),          INTENT(IN)     :: f(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfx(:,:)
  INTEGER(4),       INTENT(IN)     :: DORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL intDf(f,LX2D,kfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE r8r4c8intDf2D1CHR

 SUBROUTINE r8r4c8intDf2D(f,LX2D,kfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX2D(:,:)
  REAL(8),          INTENT(IN)     :: f(:,:)
  REAL(8),          ALLOCATABLE    :: rfx(:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfx(:,:)
  COMPLEX(8),       ALLOCATABLE    :: kf(:,:),likx(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
  INTEGER(4),       INTENT(IN)     :: DORDER
  INTEGER(4),       INTENT(IN)     :: fldID
  INTEGER(4)                       :: fDIMS(2)

  fDIMS=SHAPE(f)

  IF(ALLOCATED(kf).EQV..FALSE.) ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2)))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2)))
  CALL KGRIDBUILDER(LX2D,likx)
  CALL FFTW(f,kf)
  CALL intDf(kf,likx,kfx,DORDER,fldID,CSPACE)

  RETURN
 END SUBROUTINE r8r4c8intDf2D


 SUBROUTINE r8r4r8intDf2DNONE(f,LX2D,rfx,DORDER)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:)
  REAL(8), INTENT(OUT)             :: rfx(:,:)
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL intDf(f,LX2D,rfx,DORDER,1,"x") 
  
  RETURN
 END SUBROUTINE r8r4r8intDf2DNONE  
  
 SUBROUTINE r8r4r8intDf2D1INT(f,LX2D,rfx,DORDER,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:)
  REAL(8), INTENT(OUT)             :: rfx(:,:)
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4), INTENT(IN)           :: fldID

  CALL intDf(f,LX2D,rfx,DORDER,fldID,"x")

  RETURN
 END SUBROUTINE r8r4r8intDf2D1INT

 SUBROUTINE r8r4r8intDf2D1CHR(f,LX2D,rfx,DORDER,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:)
  REAL(8), INTENT(OUT)             :: rfx(:,:)
  INTEGER(4), INTENT(IN)           :: DORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL intDf(f,LX2D,rfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE r8r4r8intDf2D1CHR

 SUBROUTINE r8r4r8intDf2D(f,LX2D,rfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:)
  REAL(8), INTENT(OUT)             :: rfx(:,:)
  REAL(8),    ALLOCATABLE          :: tf(:,:)
  COMPLEX(8), ALLOCATABLE          :: kf(:,:),kfx(:,:)
  COMPLEX(8), ALLOCATABLE          :: likx(:,:)
  INTEGER(4), INTENT(IN)           :: fldID
  INTEGER(4)                       :: fDIM(2),DxDIR,ifDIM
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4)                       :: IORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE    ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1
  LOGICAL,    SAVE                 :: FDMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: PSMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: CSMACCESSID=.TRUE.
  LOGICAL                          :: XDIR=.FALSE.
  LOGICAL                          :: YDIR=.FALSE.
  LOGICAL                          :: ZDIR=.FALSE.

  fDIM=SHAPE(f)

  CSPACE1=CSPACE(1:1)
  IF(CSPACE1.EQ."x".OR.CSPACE1.EQ."X") THEN
   XDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."y".OR.CSPACE1.EQ."Y") THEN
   YDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."z".OR.CSPACE1.EQ."Z") THEN
   ZDIR=.TRUE.
  END IF

  DxDIR=1
  DO ifDIM=1,fDIM(2)
   IF(LX2D(1,ifDIM).NE.LX2D(1,1)) THEN
    DxDIR=2
    EXIT
   END IF
  END DO

  IF(PSMISCHEME(fldID).OR.((XDIR.AND.XPSMISCHEME(fldID)).OR.(YDIR.AND.YPSMISCHEME(fldID)).OR.(ZDIR.AND.ZPSMISCHEME(fldID)))) THEN
   IF(PSMACCESSID) THEN
    IF( PSMISCHEME(fldID)) PRINT*, " PSMISCHEME("//CHAR(48+fldID)//")",fldID,")"
    IF(XPSMISCHEME(fldID)) PRINT*, "XPSMISCHEME("//CHAR(48+fldID)//")",fldID,")"
    IF(YPSMISCHEME(fldID)) PRINT*, "YPSMISCHEME("//CHAR(48+fldID)//")",fldID,")"
    IF(ZPSMISCHEME(fldID)) PRINT*, "ZPSMISCHEME("//CHAR(48+fldID)//")",fldID,")"
    PSMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(kf).EQV..FALSE.)    ALLOCATE(kf(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(kfx).EQV..FALSE.)   ALLOCATE(kfx(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(likx).EQV..FALSE.)  ALLOCATE(likx(fDIM(1)/2+1,fDIM(2)))
   CALL KGRIDBUILDER(LX2D,likx)
   CALL FFTW(f,kf)
   CALL intDf(kf,likx,kfx,DORDER,fldID,CSPACE)
   CALL iFFTW(kfx,rfx)
  ELSE
   IF(DxDIR.EQ.1) THEN
    DO ifDIM=1,fDIM(2)
     CALL intDf(f(:,ifDIM),LX2D(:,ifDIM),rfx(:,ifDIM),DORDER,fldID,CSPACE1)
    END DO
   ELSE IF(DxDIR.EQ.2) THEN
    DO ifDIM=1,fDIM(1)
     CALL intDf(f(ifDIM,:),LX2D(ifDIM,:),rfx(ifDIM,:),DORDER,fldID,CSPACE1)
    END DO
   END IF
  END IF

  RETURN
 END SUBROUTINE r8r4r8intDf2D

 SUBROUTINE c8c8c8intDf3DNONE(kf,likx,kfx,DORDER)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:,:,:)
  COMPLEX(8),       INTENT(IN)     :: kf(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfx(:,:,:)
  INTEGER(4),       INTENT(IN)     :: DORDER

  CALL intDf(kf,likx,kfx,DORDER,1,"x")

  RETURN
 END SUBROUTINE c8c8c8intDf3DNONE

 SUBROUTINE c8c8c8intDf3D1INT(kf,likx,kfx,DORDER,fldID)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:,:,:)
  COMPLEX(8),       INTENT(IN)     :: kf(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfx(:,:,:)
  INTEGER(4),       INTENT(IN)     :: DORDER,fldID

  CALL intDf(kf,likx,kfx,DORDER,fldID,"x")

  RETURN
 END SUBROUTINE c8c8c8intDf3D1INT

 SUBROUTINE c8c8c8intDf3D1CHR(kf,likx,kfx,DORDER,CSPACE)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:,:,:)
  COMPLEX(8),       INTENT(IN)     :: kf(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfx(:,:,:)
  INTEGER(4),       INTENT(IN)     :: DORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE            ! CURRENT SPACE

  CALL intDf(kf,likx,kfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE c8c8c8intDf3D1CHR

 SUBROUTINE c8c8c8intDf3D(kf,likx,kfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)     :: likx(:,:,:)
  COMPLEX(8),       INTENT(IN)     :: kf(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfx(:,:,:)
  INTEGER(4),       INTENT(IN)     :: DORDER,fldID
  INTEGER(4)                       :: MATDIMS(3)
  INTEGER(4)                       :: IORDER,ifDIM1,ifDIM2,ifDIM3
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE            ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1

  CSPACE1=CSPACE(1:1)

  MATDIMS=SHAPE(kf)

  kfx=kf
  DO IORDER=1,DORDER
   DO ifDIM1=1,MATDIMS(1)
    DO ifDIM2=1,MATDIMS(2)
     DO ifDIM3=1,MATDIMS(3)
      IF(likx(ifDIM1,ifDIM2,ifDIM3).EQ.0.0d0) THEN
       kfx(ifDIM1,ifDIM2,ifDIM3)=CMPLX(0.0d0,0.0d0)
      ELSE
       kfx(ifDIM1,ifDIM2,ifDIM3)=kfx(ifDIM1,ifDIM2,ifDIM3)/likx(ifDIM1,ifDIM2,ifDIM3)
      END IF
     END DO
    END DO
   END DO
  END DO

  RETURN
 END SUBROUTINE c8c8c8intDf3D

 SUBROUTINE r4r4c8intDf3DNONE(f,LX3D,kfx,DORDER)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX3D(:,:,:)
  REAL(4),    INTENT(IN)           :: f(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:,:,:)
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL intDf(f,LX3D,kfx,DORDER,1,"x")

  RETURN
 END SUBROUTINE r4r4c8intDf3DNONE

 SUBROUTINE r4r4c8intDf3D1INT(f,LX3D,kfx,DORDER,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:)
  REAL(4), INTENT(IN)              :: f(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:,:,:)
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4), INTENT(IN)           :: fldID

  CALL intDf(f,LX3D,kfx,DORDER,fldID,"x")

  RETURN
 END SUBROUTINE r4r4c8intDf3D1INT

 SUBROUTINE r4r4c8intDf3D1CHR(f,LX3D,kfx,DORDER,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX3D(:,:,:)
  REAL(4),          INTENT(IN)     :: f(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfx(:,:,:)
  INTEGER(4),       INTENT(IN)     :: DORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL intDf(f,LX3D,kfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE r4r4c8intDf3D1CHR

 SUBROUTINE r4r4c8intDf3D(f,LX3D,kfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX3D(:,:,:)
  REAL(4),          INTENT(IN)     :: f(:,:,:)
  REAL(4),          ALLOCATABLE    :: rfx(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfx(:,:,:)
  COMPLEX(8),       ALLOCATABLE    :: kf(:,:,:),likx(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
  INTEGER(4),       INTENT(IN)     :: DORDER
  INTEGER(4),       INTENT(IN)     :: fldID
  INTEGER(4)                       :: fDIMS(3)

  fDIMS=SHAPE(f)

  IF(ALLOCATED(kf).EQV..FALSE.) ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  CALL KGRIDBUILDER(LX3D,likx)
  CALL FFTW(f,kf)
  CALL intDf(kf,likx,kfx,DORDER,fldID,CSPACE)

  RETURN
 END SUBROUTINE r4r4c8intDf3D

 SUBROUTINE r4r4r4intDf3DNONE(f,LX3D,rfx,DORDER)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:)
  REAL(4), INTENT(IN)              :: f(:,:,:)
  REAL(4), INTENT(OUT)             :: rfx(:,:,:)
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL intDf(f,LX3D,rfx,DORDER,1,"x") 
  
  RETURN
 END SUBROUTINE r4r4r4intDf3DNONE  
  
 SUBROUTINE r4r4r4intDf3D1INT(f,LX3D,rfx,DORDER,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:)
  REAL(4), INTENT(IN)              :: f(:,:,:)
  REAL(4), INTENT(OUT)             :: rfx(:,:,:)
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4), INTENT(IN)           :: fldID

  CALL intDf(f,LX3D,rfx,DORDER,fldID,"x")

  RETURN
 END SUBROUTINE r4r4r4intDf3D1INT

 SUBROUTINE r4r4r4intDf3D1CHR(f,LX3D,rfx,DORDER,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:)
  REAL(4), INTENT(IN)              :: f(:,:,:)
  REAL(4), INTENT(OUT)             :: rfx(:,:,:)
  INTEGER(4), INTENT(IN)           :: DORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL intDf(f,LX3D,rfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE r4r4r4intDf3D1CHR

 SUBROUTINE r4r4r4intDf3D(f,LX3D,rfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: f(:,:,:)
  REAL(4), INTENT(OUT)             :: rfx(:,:,:)
  REAL(4), INTENT(IN)              :: LX3D(:,:,:)
  REAL(8),    ALLOCATABLE          :: tf(:,:,:)
  COMPLEX(8), ALLOCATABLE          :: kf(:,:,:),kfx(:,:,:)
  COMPLEX(8), ALLOCATABLE          :: likx(:,:,:)
  INTEGER(4), INTENT(IN)           :: fldID
  INTEGER(4)                       :: fDIM(3),DxDIR,ifDIM1,ifDIM2,ifDIM3
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4)                       :: IORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE            ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1
  LOGICAL,    SAVE                 :: FDMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: PSMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: CSMACCESSID=.TRUE.
  LOGICAL                          :: XDIR=.FALSE.
  LOGICAL                          :: YDIR=.FALSE.
  LOGICAL                          :: ZDIR=.FALSE.

  fDIM=SHAPE(f)

  CSPACE1=CSPACE(1:1)
  IF(CSPACE1.EQ."x".OR.CSPACE1.EQ."X") THEN
   XDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."y".OR.CSPACE1.EQ."Y") THEN
   YDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."z".OR.CSPACE1.EQ."Z") THEN
   ZDIR=.TRUE.
  END IF

  DxDIR=1
  DO ifDIM2=1,fDIM(2)
   IF(LX3D(1,ifDIM2,1).NE.LX3D(1,1,1)) THEN
    DxDIR=2
    EXIT
   END IF
  END DO
  DO ifDIM3=1,fDIM(3)
   IF(LX3D(1,1,ifDIM3).NE.LX3D(1,1,1)) THEN
    DxDIR=3
    EXIT
   END IF
  END DO

  IF(PSMISCHEME(fldID).OR.((XDIR.AND.XPSMISCHEME(fldID)).OR.(YDIR.AND.YPSMISCHEME(fldID)).OR.(ZDIR.AND.ZPSMISCHEME(fldID)))) THEN
   IF(PSMACCESSID) THEN
    IF( PSMISCHEME(fldID)) PRINT*, " PSMSCHEME("//CHAR(48+fldID)//")",fldID,")"
    IF(XPSMISCHEME(fldID)) PRINT*, "XPSMSCHEME("//CHAR(48+fldID)//")",fldID,")"
    IF(YPSMISCHEME(fldID)) PRINT*, "YPSMSCHEME("//CHAR(48+fldID)//")",fldID,")"
    IF(ZPSMISCHEME(fldID)) PRINT*, "ZPSMSCHEME("//CHAR(48+fldID)//")",fldID,")"
    PSMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(kf).EQV..FALSE.)    ALLOCATE(kf(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(kfx).EQV..FALSE.)   ALLOCATE(kfx(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(likx).EQV..FALSE.)  ALLOCATE(likx(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   CALL KGRIDBUILDER(LX3D,likx)
   CALL FFTW(f,kf)
   CALL intDf(kf,likx,kfx,DORDER,fldID,CSPACE)
   CALL iFFTW(kfx,rfx)
  ELSE
   IF(DxDIR.EQ.1) THEN
    DO ifDIM2=1,fDIM(2)
     DO ifDIM3=1,fDIM(3)
      CALL intDf(f(:,ifDIM2,ifDIM3),LX3D(:,ifDIM2,ifDIM3),rfx(:,ifDIM2,ifDIM3),DORDER,fldID,CSPACE1)
     END DO
    END DO
   ELSE IF(DxDIR.EQ.2) THEN
    DO ifDIM1=1,fDIM(1)
     DO ifDIM3=1,fDIM(3)
      CALL intDf(f(ifDIM1,:,ifDIM3),LX3D(ifDIM1,:,ifDIM3),rfx(ifDIM1,:,ifDIM3),DORDER,fldID,CSPACE1)
     END DO
    END DO
   ELSE IF(DxDIR.EQ.3) THEN
    DO ifDIM1=1,fDIM(1)
     DO ifDIM2=1,fDIM(2)
      CALL intDf(f(ifDIM1,ifDIM2,:),LX3D(ifDIM1,ifDIM2,:),rfx(ifDIM1,ifDIM2,:),DORDER,fldID,CSPACE1)
     END DO
    END DO
   END IF
  END IF

  RETURN
 END SUBROUTINE r4r4r4intDf3D

 SUBROUTINE r8r4c8intDf3DNONE(f,LX3D,kfx,DORDER)
  IMPLICIT NONE
  REAL(4),    INTENT(IN)           :: LX3D(:,:,:)
  REAL(8),    INTENT(IN)           :: f(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:,:,:)
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL intDf(f,LX3D,kfx,DORDER,1,"x")

  RETURN
 END SUBROUTINE r8r4c8intDf3DNONE

 SUBROUTINE r8r4c8intDf3D1INT(f,LX3D,kfx,DORDER,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: kfx(:,:,:)
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4), INTENT(IN)           :: fldID

  CALL intDf(f,LX3D,kfx,DORDER,fldID,"x")

  RETURN
 END SUBROUTINE r8r4c8intDf3D1INT

 SUBROUTINE r8r4c8intDf3D1CHR(f,LX3D,kfx,DORDER,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX3D(:,:,:)
  REAL(8),          INTENT(IN)     :: f(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfx(:,:,:)
  INTEGER(4),       INTENT(IN)     :: DORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL intDf(f,LX3D,kfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE r8r4c8intDf3D1CHR

 SUBROUTINE r8r4c8intDf3D(f,LX3D,kfx,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4),          INTENT(IN)     :: LX3D(:,:,:)
  REAL(8),          INTENT(IN)     :: f(:,:,:)
  REAL(8),          ALLOCATABLE    :: rfx(:,:,:)
  COMPLEX(8),       INTENT(OUT)    :: kfx(:,:,:)
  COMPLEX(8),       ALLOCATABLE    :: kf(:,:,:),likx(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
  INTEGER(4),       INTENT(IN)     :: DORDER
  INTEGER(4),       INTENT(IN)     :: fldID
  INTEGER(4)                       :: fDIMS(3)

  fDIMS=SHAPE(f)

  IF(ALLOCATED(kf).EQV..FALSE.) ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  CALL KGRIDBUILDER(LX3D,likx)
  CALL FFTW(f,kf)
  CALL intDf(kf,likx,kfx,DORDER,fldID,CSPACE)

  RETURN
 END SUBROUTINE r8r4c8intDf3D

 SUBROUTINE r8r4r8intDf3DNONE(f,LX3D,rfx,DORDER)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:)
  REAL(8), INTENT(OUT)             :: rfx(:,:,:)
  INTEGER(4), INTENT(IN)           :: DORDER

  CALL intDf(f,LX3D,rfx,DORDER,1,"x") 
  
  RETURN
 END SUBROUTINE r8r4r8intDf3DNONE  
  
 SUBROUTINE r8r4r8intDf3D1INT(f,LX3D,rfx,DORDER,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:)
  REAL(8), INTENT(OUT)             :: rfx(:,:,:)
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4), INTENT(IN)           :: fldID

  CALL intDf(f,LX3D,rfx,DORDER,fldID,"x")

  RETURN
 END SUBROUTINE r8r4r8intDf3D1INT

 SUBROUTINE r8r4r8intDf3D1CHR(f,LX3D,rfx,DORDER,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:)
  REAL(8), INTENT(OUT)             :: rfx(:,:,:)
  INTEGER(4), INTENT(IN)           :: DORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL intDf(f,LX3D,rfx,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE r8r4r8intDf3D1CHR

 SUBROUTINE r8r4r8intDf3D(f,LX3D,rfx,DORDER,fldid,CSPACE)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: f(:,:,:)
  REAL(8), INTENT(OUT)             :: rfx(:,:,:)
  REAL(4), INTENT(IN)              :: LX3D(:,:,:)
  REAL(8),    ALLOCATABLE          :: tf(:,:,:)
  COMPLEX(8), ALLOCATABLE          :: kf(:,:,:),kfx(:,:,:)
  COMPLEX(8), ALLOCATABLE          :: likx(:,:,:)
  INTEGER(4), INTENT(IN)           :: fldID
  INTEGER(4)                       :: fDIM(3),DxDIR,ifDIM1,ifDIM2,ifDIM3
  INTEGER(4), INTENT(IN)           :: DORDER
  INTEGER(4)                       :: IORDER
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE              ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1
  LOGICAL,    SAVE                 :: FDMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: PSMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: CSMACCESSID=.TRUE.
  LOGICAL                          :: XDIR=.FALSE.
  LOGICAL                          :: YDIR=.FALSE.
  LOGICAL                          :: ZDIR=.FALSE.

  fDIM=SHAPE(f)

  CSPACE1=CSPACE(1:1)
  IF(CSPACE1.EQ."x".OR.CSPACE1.EQ."X") THEN
   XDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."y".OR.CSPACE1.EQ."Y") THEN
   YDIR=.TRUE.
  ELSE IF(CSPACE1.EQ."z".OR.CSPACE1.EQ."Z") THEN
   ZDIR=.TRUE.
  END IF

  DxDIR=1
  DO ifDIM2=1,fDIM(2)
   IF(LX3D(1,ifDIM2,1).NE.LX3D(1,1,1)) THEN
    DxDIR=2
    EXIT
   END IF
  END DO
  DO ifDIM3=1,fDIM(3)
   IF(LX3D(1,1,ifDIM3).NE.LX3D(1,1,1)) THEN
    DxDIR=3
    EXIT
   END IF
  END DO

  IF(PSMISCHEME(fldID).OR.((XDIR.AND.XPSMISCHEME(fldID)).OR.(YDIR.AND.YPSMISCHEME(fldID)).OR.(ZDIR.AND.ZPSMISCHEME(fldID)))) THEN
   IF(PSMACCESSID) THEN
    IF( PSMISCHEME(fldID)) PRINT*, " PSMSCHEME("//CHAR(48+fldID)//")",fldID,")"
    IF(XPSMISCHEME(fldID)) PRINT*, "XPSMSCHEME("//CHAR(48+fldID)//")",fldID,")"
    IF(YPSMISCHEME(fldID)) PRINT*, "YPSMSCHEME("//CHAR(48+fldID)//")",fldID,")"
    IF(ZPSMISCHEME(fldID)) PRINT*, "ZPSMSCHEME("//CHAR(48+fldID)//")",fldID,")"
    PSMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(kf).EQV..FALSE.)    ALLOCATE(kf(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(kfx).EQV..FALSE.)   ALLOCATE(kfx(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(likx).EQV..FALSE.)  ALLOCATE(likx(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   CALL KGRIDBUILDER(LX3D,likx)
   CALL FFTW(f,kf)
   CALL intDf(kf,likx,kfx,DORDER,fldID,CSPACE)
   CALL iFFTW(kfx,rfx)
  ELSE
   IF(DxDIR.EQ.1) THEN
    DO ifDIM2=1,fDIM(2)
     DO ifDIM3=1,fDIM(3)
      CALL intDf(f(:,ifDIM2,ifDIM3),LX3D(:,ifDIM2,ifDIM3),rfx(:,ifDIM2,ifDIM3),DORDER,fldID,CSPACE1)
     END DO
    END DO
   ELSE IF(DxDIR.EQ.2) THEN
    DO ifDIM1=1,fDIM(1)
     DO ifDIM3=1,fDIM(3)
      CALL intDf(f(ifDIM1,:,ifDIM3),LX3D(ifDIM1,:,ifDIM3),rfx(ifDIM1,:,ifDIM3),DORDER,fldID,CSPACE1)
     END DO
    END DO
   ELSE IF(DxDIR.EQ.3) THEN
    DO ifDIM1=1,fDIM(1)
     DO ifDIM2=1,fDIM(2)
      CALL intDf(f(ifDIM1,ifDIM2,:),LX3D(ifDIM1,ifDIM2,:),rfx(ifDIM1,ifDIM2,:),DORDER,fldID,CSPACE1)
     END DO
    END DO
   END IF
  END IF

  RETURN
 END SUBROUTINE r8r4r8intDf3D



!************* Intgeration of LAPLACIAN OF FUNNCTION (LPLCf) ************
 SUBROUTINE c8c8c8intLPLCf2DNONE(kf,likx,liky,kLPLCf,DORDER)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)  :: likx(:,:),liky(:,:)
  COMPLEX(8),       INTENT(IN)  :: kf(:,:)
  COMPLEX(8),       INTENT(OUT) :: kLPLCf(:,:)
  INTEGER(4),       INTENT(IN)  :: DORDER

  CALL intLPLCf(kf,likx,liky,kLPLCf,DORDER,1,"xy")

  RETURN
 END SUBROUTINE c8c8c8intLPLCf2DNONE

 SUBROUTINE c8c8c8intLPLCf2D1INT(kf,likx,liky,kLPLCf,DORDER,fldID)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)  :: likx(:,:),liky(:,:)
  COMPLEX(8),       INTENT(IN)  :: kf(:,:)
  COMPLEX(8),       INTENT(OUT) :: kLPLCf(:,:)
  INTEGER(4),       INTENT(IN)  :: DORDER,fldID

  CALL intLPLCf(kf,likx,liky,kLPLCf,DORDER,fldID,"xy")

  RETURN
 END SUBROUTINE c8c8c8intLPLCf2D1INT

 SUBROUTINE c8c8c8intLPLCf2D1CHR(kf,likx,liky,kLPLCf,DORDER,CSPACE)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)  :: likx(:,:),liky(:,:)
  COMPLEX(8),       INTENT(IN)  :: kf(:,:)
  COMPLEX(8),       INTENT(OUT) :: kLPLCf(:,:)
  INTEGER(4),       INTENT(IN)  :: DORDER
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE

  CALL intLPLCf(kf,likx,liky,kLPLCf,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE c8c8c8intLPLCf2D1CHR

 SUBROUTINE c8c8c8intLPLCf2D(kf,likx,liky,kLPLCf,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)  :: likx(:,:),liky(:,:)
  COMPLEX(8),       INTENT(IN)  :: kf(:,:)
  COMPLEX(8),       INTENT(OUT) :: kLPLCf(:,:)
  INTEGER(4),       INTENT(IN)  :: DORDER,fldID
  INTEGER(4)                    :: IORDER,ifDIM1,ifDIM2
  INTEGER(4)                    :: kfDIMS(2)
  REAL(8),          ALLOCATABLE :: llplc(:,:)
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2

  IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, intLPLCf: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, intLPLCf: NUMBER OF CURRENT SPACES ARE NOT ENOUGH!"
   STOP
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, intLPLCf: NUMBER OF CURRENT SPACES ARE TOO MANY!"
   STOP
  END IF

  kfDIMS=SHAPE(kf)
  ALLOCATE(llplc(kfDIMS(1),kfDIMS(2)))

  kLPLCf=kf
  DO IORDER=1,DORDER
   DO ifDIM1=1,kfDIMS(1)
    DO ifDIM2=1,kfDIMS(2)
     llplc(ifDIM1,ifDIM2)=REAL(likx(ifDIM1,ifDIM2)*likx(ifDIM1,ifDIM2)+liky(ifDIM1,ifDIM2)*liky(ifDIM1,ifDIM2),8)
     IF(llplc(ifDIM1,ifDIM2).EQ.0.0d0) THEN
      kLPLCf(ifDIM1,ifDIM2)=CMPLX(0.0d0,0.0d0)
     ELSE
      kLPLCf(ifDIM1,ifDIM2)=kLPLCf(ifDIM1,ifDIM2)/llplc(ifDIM1,ifDIM2)
     END IF
    END DO
   END DO
  END DO

  RETURN
 END SUBROUTINE c8c8c8intLPLCf2D

 SUBROUTINE r4r4c8intLPLCf2DNONE(f,LX2D,LY2D,klintLPLCf)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(4), INTENT(IN)              :: f(:,:)
  COMPLEX(8), INTENT(OUT)          :: klintLPLCf(:,:)

  CALL intLPLCf(f,LX2D,LY2D,klintLPLCf,1,"xy")

  RETURN
 END SUBROUTINE r4r4c8intLPLCf2DNONE

 SUBROUTINE r4r4c8intLPLCf2D1INT(f,LX2D,LY2D,klintLPLCf,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(4), INTENT(IN)              :: f(:,:)
  COMPLEX(8), INTENT(OUT)          :: klintLPLCf(:,:)
  INTEGER(4), INTENT(IN)           :: fldID

  CALL intLPLCf(f,LX2D,LY2D,klintLPLCf,fldID,"xy")

  RETURN
 END SUBROUTINE r4r4c8intLPLCf2D1INT

 SUBROUTINE r4r4c8intLPLCf2D1CHR(f,LX2D,LY2D,klintLPLCf,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(4), INTENT(IN)              :: f(:,:)
  COMPLEX(8), INTENT(OUT)          :: klintLPLCf(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL intLPLCf(f,LX2D,LY2D,klintLPLCf,1,CSPACE)

  RETURN
 END SUBROUTINE r4r4c8intLPLCf2D1CHR

 SUBROUTINE r4r4c8intLPLCf2D(f,LX2D,LY2D,klintLPLCf,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)           :: LX2D(:,:),LY2D(:,:)
  REAL(4), INTENT(IN)           :: f(:,:)
  REAL(4), ALLOCATABLE          :: rlintLPLCf(:,:)
  COMPLEX(8), INTENT(OUT)       :: klintLPLCf(:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:),liky(:,:)
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE
  INTEGER(4), INTENT(IN)        :: fldID
  INTEGER(4)                    :: fDIMS(2)

  fDIMS=SHAPE(f)

  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2)))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2)))
  IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(fDIMS(1)/2+1,fDIMS(2)))

  CALL KGRIDBUILDER(LX2D,likx)
  CALL KGRIDBUILDER(LY2D,liky)
  CALL FFTW(f,kf)
  CALL intLPLCf(kf,likx,liky,klintLPLCf,fldID,CSPACE)

  RETURN
 END SUBROUTINE r4r4c8intLPLCf2D

 SUBROUTINE r4r4r4intLPLCf2DNONE(f,LX2D,LY2D,lintLPLCf)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(4), INTENT(IN)              :: f(:,:)
  REAL(4), INTENT(OUT)             :: lintLPLCf(:,:)

  CALL intLPLCf(f,LX2D,LY2D,lintLPLCf,1,"xy")

  RETURN
 END SUBROUTINE r4r4r4intLPLCf2DNONE

 SUBROUTINE r4r4r4intLPLCf2D1INT(f,LX2D,LY2D,lintLPLCf,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(4), INTENT(IN)              :: f(:,:)
  REAL(4), INTENT(OUT)             :: lintLPLCf(:,:)
  INTEGER(4), INTENT(IN)           :: fldID

  CALL intLPLCf(f,LX2D,LY2D,lintLPLCf,fldID,"xy")

  RETURN
 END SUBROUTINE r4r4r4intLPLCf2D1INT

 SUBROUTINE r4r4r4intLPLCf2D1CHR(f,LX2D,LY2D,lintLPLCf,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(4), INTENT(IN)              :: f(:,:)
  REAL(4), INTENT(OUT)             :: lintLPLCf(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL intLPLCf(f,LX2D,LY2D,lintLPLCf,1,CSPACE)

  RETURN
 END SUBROUTINE r4r4r4intLPLCf2D1CHR

 SUBROUTINE r4r4r4intLPLCf2D(f,LX2D,LY2D,lintLPLCf,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: f(:,:)
  REAL(4), INTENT(OUT)             :: lintLPLCf(:,:)
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(4), ALLOCATABLE             :: Dx(:),Dy(:)
  REAL(4), ALLOCATABLE             :: f1D(:),Df1D(:)
  REAL(4), ALLOCATABLE             :: IDMT(:,:)
  REAL(4), ALLOCATABLE             :: KRON1(:,:),KRON2(:,:)
  REAL(4), ALLOCATABLE             :: DxMAT(:,:),DyMAT(:,:)
  REAL(4), ALLOCATABLE             :: LPLC2D(:,:)
  REAL(4), ALLOCATABLE             :: tf(:,:)
  REAL(8), ALLOCATABLE             :: llplc(:,:)
  COMPLEX(8), ALLOCATABLE          :: likx(:,:),liky(:,:)
  COMPLEX(8), ALLOCATABLE          :: kf(:,:),kLPLCf(:,:)
  INTEGER(4)                       :: fDIM(2),ifDIM,ifDIM1,ifDIM2
  INTEGER(4), INTENT(IN)           :: fldID
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE          ! CURRENT SPACE
  CHARACTER(LEN=1)                 :: CSPACE1,CSPACE2
  LOGICAL,    SAVE                 :: FDMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: PSMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: CSMACCESSID=.TRUE.
  LOGICAL                          :: XYDIR=.FALSE.
  LOGICAL                          :: YZDIR=.FALSE.
  LOGICAL                          :: XZDIR=.FALSE.
  LOGICAL                          :: XYFDMISCHEME=.FALSE.
  LOGICAL                          :: YZFDMISCHEME=.FALSE.
  LOGICAL                          :: XZFDMISCHEME=.FALSE.
  LOGICAL                          :: XYPSMISCHEME=.FALSE.
  LOGICAL                          :: YZPSMISCHEME=.FALSE.
  LOGICAL                          :: XZPSMISCHEME=.FALSE.
  LOGICAL                          :: XYCSMISCHEME=.FALSE.
  LOGICAL                          :: YZCSMISCHEME=.FALSE.
  LOGICAL                          :: XZCSMISCHEME=.FALSE.

  fDIM=SHAPE(f)

  IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, intLPLCf: NUMBER OF CURRENT SPACES ARE NOT ENOUGH!"
   STOP
  ELSE IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, intLPLCf: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, intLPLCf: NUMBER OF CURRENT SPACES ARE TOO MANY!"
   STOP
  END IF

  IF((CSPACE1.EQ."x".AND.CSPACE1.EQ."X").AND.(CSPACE2.EQ."y".AND.CSPACE2.EQ."Y")) THEN
   XYDIR=.TRUE.
  ELSE IF((CSPACE1.EQ."y".AND.CSPACE1.EQ."Y").AND.(CSPACE2.EQ."z".AND.CSPACE2.EQ."Z")) THEN
   YZDIR=.TRUE.
  ELSE IF((CSPACE1.EQ."x".AND.CSPACE1.EQ."X").AND.(CSPACE2.EQ."z".AND.CSPACE2.EQ."Z")) THEN
   XZDIR=.TRUE.
  END IF

  IF(XFDMISCHEME(fldID).AND.YFDMISCHEME(fldID)) THEN
   XYFDMISCHEME=.TRUE.
  ELSE IF(YFDMISCHEME(fldID).AND.ZFDMISCHEME(fldID)) THEN
   YZFDMISCHEME=.TRUE.
  ELSE IF(XFDMISCHEME(fldID).AND.ZFDMISCHEME(fldID)) THEN
   XZFDMISCHEME=.TRUE.
  ELSE IF(XPSMISCHEME(fldID).AND.YPSMISCHEME(fldID)) THEN
   XYPSMISCHEME=.TRUE.
  ELSE IF(YPSMISCHEME(fldID).AND.ZPSMISCHEME(fldID)) THEN
   YZPSMISCHEME=.TRUE.
  ELSE IF(XPSMISCHEME(fldID).AND.ZPSMISCHEME(fldID)) THEN
   XZPSMISCHEME=.TRUE.
  ELSE IF(XCSMISCHEME(fldID).AND.YCSMISCHEME(fldID)) THEN
   XYCSMISCHEME=.TRUE.
  ELSE IF(YCSMISCHEME(fldID).AND.ZCSMISCHEME(fldID)) THEN
   YZCSMISCHEME=.TRUE.
  ELSE IF(XCSMISCHEME(fldID).AND.ZCSMISCHEME(fldID)) THEN
   XZCSMISCHEME=.TRUE.
  END IF

  IF(FDMISCHEME(fldID).OR.((XYDIR.AND.XYFDMISCHEME).OR.(YZDIR.AND.YZFDMISCHEME).OR.(XZDIR.AND.XZFDMISCHEME))) THEN
   IF(FDMACCESSID) THEN
    IF( FDMISCHEME(fldID)) PRINT*, " FDMISCHEME("//CHAR(48+fldID)//")"
    IF(XFDMISCHEME(fldID)) PRINT*, "XFDMISCHEME("//CHAR(48+fldID)//")",fldID,")"
    IF(YFDMISCHEME(fldID)) PRINT*, "YFDMISCHEME("//CHAR(48+fldID)//")",fldID,")"
    IF(ZFDMISCHEME(fldID)) PRINT*, "ZFDMISCHEME("//CHAR(48+fldID)//")",fldID,")"
    IF(ALLOCATED(IDMT)) DEALLOCATE(IDMT)
    ALLOCATE(IDMT(fDIM(1),fDIM(2)))
    CALL IDMAT(IDMT)
 
    IF(ALLOCATED(Dx)) DEALLOCATE(Dx)
    ALLOCATE(Dx(fDIM(1)))
    Dx(1:fDIM(1)-1)=LX2D(2:fDIM(1),1)-LX2D(1:fDIM(1)-1,1);Dx(fDIM(1))=Dx(fDIM(1)-1)
    IF(ALLOCATED(DxMAT)) DEALLOCATE(DxMAT)
    ALLOCATE(DxMAT(fDIM(1),fDIM(1)))
 
    IF(FDMORDER.EQ.2) THEN
     DxMAT=0.0
     DxMAT(1,1)=-2.0/(Dx(1)**2);DxMAT(1,2)=1.0/(Dx(1)**2)
     DO ifDIM=2,fDIM(1)-1
      DxMAT(ifDIM,ifDIM-1)=1.0/(Dx(ifDIM)**2);DxMAT(ifDIM,ifDIM)=-2.0/(Dx(ifDIM)**2);DxMAT(ifDIM,ifDIM+1)=1.0/(Dx(ifDIM)**2)
     END DO
     DxMAT(fDIM(1),fDIM(1)-1)=1.0/(Dx(fDIM(1))**2);DxMAT(fDIM(1),fDIM(1))=-2.0/(Dx(fDIM(1))**2)
    ELSE IF(FDMORDER.EQ.4) THEN
     DxMAT=0.0
     DxMAT(1,1)=-30.0/(12.0*Dx(1)**2);
     DxMAT(1,2)=16.0/(12.0*Dx(1)**2);DxMAT(1,3)=-1.0/(12.0*Dx(1)**2)
     DxMAT(2,1)=16.0/(12.0*Dx(2)**2);
     DxMAT(2,2)=-30.0/(12.0*Dx(2)**2);
     DxMAT(2,3)=16.0/(12.0*Dx(1)**2);DxMAT(2,4)=-1.0/(12.0*Dx(1)**2)
     DO ifDIM=2,fDIM(1)-2
      DxMAT(ifDIM,ifDIM-2)=-1.0/(12.0*Dx(ifDIM)**2);DxMAT(ifDIM,ifDIM-1)=16.0/(12.0*Dx(ifDIM)**2);
      DxMAT(ifDIM,ifDIM)=-30.0/(12.0*Dx(ifDIM)**2);
      DxMAT(ifDIM,ifDIM+1)=16.0/(12.0*Dx(ifDIM)**2);DxMAT(ifDIM,ifDIM+2)=-1.0/(12.0*Dx(ifDIM)**2)
     END DO
     DxMAT(fDIM(1)-1,fDIM(1)-3)=-1.0/(12.0*Dx(fDIM(1)-1)**2);DxMAT(fDIM(1)-1,fDIM(1)-2)=16.0/(12.0*Dx(fDIM(1)-1)**2);
     DxMAT(fDIM(1)-1,fDIM(1)-1)=-30.0/(12.0*Dx(fDIM(1)-1)**2);
     DxMAT(fDIM(1)-1,fDIM(1))=16.0/(12.0*Dx(fDIM(1)-1)**2)
     DxMAT(fDIM(1),fDIM(1)-2)=-1.0/(12.0*Dx(fDIM(1))**2);DxMAT(fDIM(1),fDIM(1)-1)=16.0/(12.0*Dx(fDIM(1))**2);
     DxMAT(fDIM(1),fDIM(1))=-30.0/(12.0*Dx(fDIM(1))**2)
    END IF

    IF(ALLOCATED(KRON1)) DEALLOCATE(KRON1)
    ALLOCATE(KRON1(fDIM(1)*fDIM(2),fDIM(1)*fDIM(2)))
    CALL KRON(IDMT,DxMAT,KRON1)
    IF(ALLOCATED(DxMAT)) DEALLOCATE(DxMAT)
 
    IF(ALLOCATED(Dy)) DEALLOCATE(Dy)
    ALLOCATE(Dy(fDIM(2)))
    Dy(1:fDIM(2)-1)=LY2D(1,2:fDIM(2))-LY2D(1,1:fDIM(2)-1);Dy(fDIM(2))=Dy(fDIM(2)-1)
    IF(ALLOCATED(DyMAT)) DEALLOCATE(DyMAT)
    ALLOCATE(DyMAT(fDIM(2),fDIM(2)))

    IF(FDMORDER.EQ.2) THEN
     DyMAT=0.0
     DyMAT(1,1)=-2.0/(Dy(1)**2);DyMAT(1,2)=1.0/(Dy(1)**2)
     DO ifDIM=2,fDIM(2)-1
      DyMAT(ifDIM,ifDIM-1)=1.0/(Dy(ifDIM)**2);DyMAT(ifDIM,ifDIM)=-2.0/(Dy(ifDIM)**2);DyMAT(ifDIM,ifDIM+1)=1.0/(Dy(ifDIM)**2)
     END DO
     DyMAT(fDIM(2),fDIM(2)-1)=1.0/(Dy(fDIM(2))**2);DyMAT(fDIM(2),fDIM(2))=-2.0/(Dy(fDIM(2))**2)
    ELSE IF(FDMORDER.EQ.4) THEN
     DyMAT=0.0d0
     DyMAT(1,1)=-30.0/(12.0*Dy(1)**2);
     DyMAT(1,2)=16.0/(12.0*Dy(1)**2);DyMAT(1,3)=-1.0/(12.0*Dy(1)**2)
     DyMAT(2,1)=16.0/(12.0*Dy(2)**2);
     DyMAT(2,2)=-30.0/(12.0d0*Dy(2)**2);
     DyMAT(2,3)=16.0/(12.0*Dy(1)**2);DyMAT(2,4)=-1.0/(12.0*Dy(1)**2)
     DO ifDIM=2,fDIM(2)-2
      DyMAT(ifDIM,ifDIM-2)=-1.0/(12.0*Dy(ifDIM)**2);DyMAT(ifDIM,ifDIM-1)=16.0/(12.0*Dy(ifDIM)**2);
      DyMAT(ifDIM,ifDIM)=-30.0/(12.0*Dy(ifDIM)**2);
      DyMAT(ifDIM,ifDIM+1)=16.0/(12.0*Dy(ifDIM)**2);DyMAT(ifDIM,ifDIM+2)=-1.0/(12.0*Dy(ifDIM)**2)
     END DO
     DyMAT(fDIM(2)-1,fDIM(2)-3)=-1.0/(12.0*Dy(fDIM(2)-1)**2);DyMAT(fDIM(2)-1,fDIM(2)-2)=16.0/(12.0*Dy(fDIM(2)-1)**2);
     DyMAT(fDIM(2)-1,fDIM(2)-1)=-30.0/(12.0*Dy(fDIM(2)-1)**2);
     DyMAT(fDIM(2)-1,fDIM(2))=16.0/(12.0*Dy(fDIM(2)-1)**2)
     DyMAT(fDIM(2),fDIM(2)-2)=-1.0/(12.0*Dy(fDIM(2))**2);DyMAT(fDIM(2),fDIM(2)-1)=16.0/(12.0*Dy(fDIM(2))**2);
     DyMAT(fDIM(2),fDIM(2))=-30.0/(12.0*Dy(fDIM(2))**2)
    END IF
 
    IF(ALLOCATED(KRON2)) DEALLOCATE(KRON2)
    ALLOCATE(KRON2(fDIM(1)*fDIM(2),fDIM(1)*fDIM(2)))
    CALL KRON(DyMAT,IDMT,KRON2)
    IF(ALLOCATED(DyMAT)) DEALLOCATE(DyMAT)
    IF(ALLOCATED(IDMT)) DEALLOCATE(IDMT)
 
    IF(ALLOCATED(invLPLC)) DEALLOCATE(invLPLC)
    ALLOCATE(invLPLC(fDIM(1)*fDIM(2),fDIM(1)*fDIM(2)))
    invLPLC=KRON1+KRON2
    IF(ALLOCATED(KRON1)) DEALLOCATE(KRON1)
    IF(ALLOCATED(KRON2)) DEALLOCATE(KRON2)
    CALL MATINV(invLPLC)

    FDMACCESSID=.FALSE.
   END IF

   IF(ALLOCATED(f1D)) DEALLOCATE(f1D)
   ALLOCATE(f1D(fDIM(1)*fDIM(2)))
   IF(ALLOCATED(Df1D)) DEALLOCATE(Df1D)
   ALLOCATE(Df1D(fDIM(1)*fDIM(2)))
   f1D=RESHAPE(f,(/fDIM(1)*fDIM(2)/))
   Df1D=MATMUL(invLPLC,f1D)
   lintLPLCf=RESHAPE(Df1D,(/fDIM(1),fDIM(2)/))
   XYFDMISCHEME=.FALSE.
   YZFDMISCHEME=.FALSE.
   XZFDMISCHEME=.FALSE.
  ELSE IF(PSMISCHEME(fldID).OR.((XYDIR.AND.XYPSMISCHEME).OR.(YZDIR.AND.YZPSMISCHEME).OR.(XZDIR.AND.XZPSMISCHEME))) THEN
   IF(PSMACCESSID) THEN
    IF( PSMISCHEME(fldID)) PRINT*, " PSMISCHEME("//CHAR(48+fldID)//")"
    IF(XPSMISCHEME(fldID)) PRINT*, "XPSMISCHEME("//CHAR(48+fldID)//")"
    IF(YPSMISCHEME(fldID)) PRINT*, "YPSMISCHEME("//CHAR(48+fldID)//")"
    IF(ZPSMISCHEME(fldID)) PRINT*, "ZPSMISCHEME("//CHAR(48+fldID)//")"
    PSMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(kf).EQV..FALSE.)     ALLOCATE(kf(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(likx).EQV..FALSE.)   ALLOCATE(likx(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(liky).EQV..FALSE.)   ALLOCATE(liky(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(llplc).EQV..FALSE.)  ALLOCATE(llplc(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(kLPLCf).EQV..FALSE.) ALLOCATE(kLPLCf(fDIM(1)/2+1,fDIM(2)))
   CALL KGRIDBUILDER(LX2D,likx)
   CALL KGRIDBUILDER(LY2D,liky)
   CALL FFTW(f,kf)
   CALL intLPLCf(kf,likx,liky,kLPLCf,1,fldID,CSPACE)
   CALL iFFTW(kLPLCf,lintLPLCf)
   XYPSMISCHEME=.FALSE.
   YZPSMISCHEME=.FALSE.
   XZPSMISCHEME=.FALSE.
  END IF

  XYDIR=.FALSE.
  YZDIR=.FALSE.
  XZDIR=.FALSE.
! XYCSMSCHEME=.FALSE.
! YZCSMSCHEME=.FALSE.
! XZCSMSCHEME=.FALSE.

  RETURN
 END SUBROUTINE r4r4r4intLPLCf2D

 SUBROUTINE r8r4c8intLPLCf2DNONE(f,LX2D,LY2D,klintLPLCf)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:)
  COMPLEX(8), INTENT(OUT)          :: klintLPLCf(:,:)

  CALL intLPLCf(f,LX2D,LY2D,klintLPLCf,1,"xy")

  RETURN
 END SUBROUTINE r8r4c8intLPLCf2DNONE

 SUBROUTINE r8r4c8intLPLCf2D1INT(f,LX2D,LY2D,klintLPLCf,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:)
  COMPLEX(8), INTENT(OUT)          :: klintLPLCf(:,:)
  INTEGER(4), INTENT(IN)           :: fldID

  CALL intLPLCf(f,LX2D,LY2D,klintLPLCf,fldID,"xy")

  RETURN
 END SUBROUTINE r8r4c8intLPLCf2D1INT

 SUBROUTINE r8r4c8intLPLCf2D1CHR(f,LX2D,LY2D,klintLPLCf,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:)
  COMPLEX(8), INTENT(OUT)          :: klintLPLCf(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL intLPLCf(f,LX2D,LY2D,klintLPLCf,1,CSPACE)

  RETURN
 END SUBROUTINE r8r4c8intLPLCf2D1CHR

 SUBROUTINE r8r4c8intLPLCf2D(f,LX2D,LY2D,klintLPLCf,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)           :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)           :: f(:,:)
  REAL(8), ALLOCATABLE          :: rlintLPLCf(:,:)
  COMPLEX(8), INTENT(OUT)       :: klintLPLCf(:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:),liky(:,:)
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE
  INTEGER(4), INTENT(IN)        :: fldID
  INTEGER(4)                    :: fDIMS(2)

  fDIMS=SHAPE(f)
  
  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2)))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2)))
  IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(fDIMS(1)/2+1,fDIMS(2)))

  CALL KGRIDBUILDER(LX2D,likx)
  CALL KGRIDBUILDER(LY2D,liky)
  CALL FFTW(f,kf)
  CALL intLPLCf(kf,likx,liky,klintLPLCf,fldID,CSPACE)

  RETURN
 END SUBROUTINE r8r4c8intLPLCf2D

 SUBROUTINE r8r8c8intLPLCf2DNONE(f,LX2D,LY2D,klintLPLCf)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:)
  COMPLEX(8), INTENT(OUT)          :: klintLPLCf(:,:)

  CALL intLPLCf(f,LX2D,LY2D,klintLPLCf,1,"xy")

  RETURN
 END SUBROUTINE r8r8c8intLPLCf2DNONE

 SUBROUTINE r8r8c8intLPLCf2D1INT(f,LX2D,LY2D,klintLPLCf,fldID)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:)
  COMPLEX(8), INTENT(OUT)          :: klintLPLCf(:,:)
  INTEGER(4), INTENT(IN)           :: fldID

  CALL intLPLCf(f,LX2D,LY2D,klintLPLCf,fldID,"xy")

  RETURN
 END SUBROUTINE r8r8c8intLPLCf2D1INT

 SUBROUTINE r8r8c8intLPLCf2D1CHR(f,LX2D,LY2D,klintLPLCf,CSPACE)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:)
  COMPLEX(8), INTENT(OUT)          :: klintLPLCf(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL intLPLCf(f,LX2D,LY2D,klintLPLCf,1,CSPACE)

  RETURN
 END SUBROUTINE r8r8c8intLPLCf2D1CHR

 SUBROUTINE r8r8c8intLPLCf2D(f,LX2D,LY2D,klintLPLCf,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8), INTENT(IN)           :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)           :: f(:,:)
  REAL(8), ALLOCATABLE          :: rlintLPLCf(:,:)
  COMPLEX(8), INTENT(OUT)       :: klintLPLCf(:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:),liky(:,:)
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE
  INTEGER(4), INTENT(IN)        :: fldID
  INTEGER(4)                    :: fDIMS(2)

  fDIMS=SHAPE(f)
  
  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2)))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2)))
  IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(fDIMS(1)/2+1,fDIMS(2)))

  CALL KGRIDBUILDER(LX2D,likx)
  CALL KGRIDBUILDER(LY2D,liky)
  CALL FFTW(f,kf)
  CALL intLPLCf(kf,likx,liky,klintLPLCf,fldID,CSPACE)

  RETURN
 END SUBROUTINE r8r8c8intLPLCf2D

 SUBROUTINE r8r4r8intLPLCf2DNONE(f,LX2D,LY2D,lintLPLCf)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:)
  REAL(8), INTENT(OUT)             :: lintLPLCf(:,:)

  CALL intLPLCf(f,LX2D,LY2D,lintLPLCf,1,"xy")

  RETURN
 END SUBROUTINE r8r4r8intLPLCf2DNONE

 SUBROUTINE r8r4r8intLPLCf2D1INT(f,LX2D,LY2D,lintLPLCf,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:)
  REAL(8), INTENT(OUT)             :: lintLPLCf(:,:)
  INTEGER(4), INTENT(IN)           :: fldID

  CALL intLPLCf(f,LX2D,LY2D,lintLPLCf,fldID,"xy")

  RETURN
 END SUBROUTINE r8r4r8intLPLCf2D1INT

 SUBROUTINE r8r4r8intLPLCf2D1CHR(f,LX2D,LY2D,lintLPLCf,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:)
  REAL(8), INTENT(OUT)             :: lintLPLCf(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL intLPLCf(f,LX2D,LY2D,lintLPLCf,1,CSPACE)

  RETURN
 END SUBROUTINE r8r4r8intLPLCf2D1CHR

 SUBROUTINE r8r4r8intLPLCf2D(f,LX2D,LY2D,lintLPLCf,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: f(:,:)
  REAL(8), INTENT(OUT)             :: lintLPLCf(:,:)
  REAL(4), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(4), ALLOCATABLE             :: Dx(:),Dy(:)
  REAL(8), ALLOCATABLE             :: f1D(:),Df1D(:)
  REAL(8), ALLOCATABLE             :: IDMT(:,:)
  REAL(8), ALLOCATABLE             :: KRON1(:,:),KRON2(:,:)
  REAL(8), ALLOCATABLE             :: DxMAT(:,:),DyMAT(:,:)
  REAL(8), ALLOCATABLE             :: LPLC2D(:,:)
  REAL(8), ALLOCATABLE             :: tf(:,:)
  REAL(8), ALLOCATABLE             :: llplc(:,:)
  COMPLEX(8), ALLOCATABLE          :: likx(:,:),liky(:,:)
  COMPLEX(8), ALLOCATABLE          :: kf(:,:),kLPLCf(:,:)
  INTEGER(4)                       :: fDIM(2),ifDIM,ifDIM1,ifDIM2
  INTEGER(4), INTENT(IN)           :: fldID
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
  CHARACTER(LEN=1)                 :: CSPACE1,CSPACE2
  LOGICAL,    SAVE                 :: FDMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: PSMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: CSMACCESSID=.TRUE.
  LOGICAL                          :: XYDIR=.FALSE.
  LOGICAL                          :: YZDIR=.FALSE.
  LOGICAL                          :: XZDIR=.FALSE.
  LOGICAL                          :: XYFDMISCHEME=.FALSE.
  LOGICAL                          :: YZFDMISCHEME=.FALSE.
  LOGICAL                          :: XZFDMISCHEME=.FALSE.
  LOGICAL                          :: XYPSMISCHEME=.FALSE.
  LOGICAL                          :: YZPSMISCHEME=.FALSE.
  LOGICAL                          :: XZPSMISCHEME=.FALSE.
  LOGICAL                          :: XYCSMISCHEME=.FALSE.
  LOGICAL                          :: YZCSMISCHEME=.FALSE.
  LOGICAL                          :: XZCSMISCHEME=.FALSE.

  fDIM=SHAPE(f)

  IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, intLPLCf: NUMBER OF CURRENT SPACES ARE NOT ENOUGH!"
   STOP
  ELSE IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, intLPLCf: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, intLPLCf: NUMBER OF CURRENT SPACES ARE TOO MANY!"
   STOP
  END IF

  IF((CSPACE1.EQ."x".AND.CSPACE1.EQ."X").AND.(CSPACE2.EQ."y".AND.CSPACE2.EQ."Y")) THEN
   XYDIR=.TRUE.
  ELSE IF((CSPACE1.EQ."y".AND.CSPACE1.EQ."Y").AND.(CSPACE2.EQ."z".AND.CSPACE2.EQ."Z")) THEN
   YZDIR=.TRUE.
  ELSE IF((CSPACE1.EQ."x".AND.CSPACE1.EQ."X").AND.(CSPACE2.EQ."z".AND.CSPACE2.EQ."Z")) THEN
   XZDIR=.TRUE.
  END IF

  IF(XFDMISCHEME(fldID).AND.YFDMISCHEME(fldID)) THEN
   XYFDMISCHEME=.TRUE.
  ELSE IF(YFDMISCHEME(fldID).AND.ZFDMISCHEME(fldID)) THEN
   YZFDMISCHEME=.TRUE.
  ELSE IF(XFDMISCHEME(fldID).AND.ZFDMISCHEME(fldID)) THEN
   XZFDMISCHEME=.TRUE.
  ELSE IF(XPSMISCHEME(fldID).AND.YPSMISCHEME(fldID)) THEN
   XYPSMISCHEME=.TRUE.
  ELSE IF(YPSMISCHEME(fldID).AND.ZPSMISCHEME(fldID)) THEN
   YZPSMISCHEME=.TRUE.
  ELSE IF(XPSMISCHEME(fldID).AND.ZPSMISCHEME(fldID)) THEN
   XZPSMISCHEME=.TRUE.
  ELSE IF(XCSMISCHEME(fldID).AND.YCSMISCHEME(fldID)) THEN
   XYCSMISCHEME=.TRUE.
  ELSE IF(YCSMISCHEME(fldID).AND.ZCSMISCHEME(fldID)) THEN
   YZCSMISCHEME=.TRUE.
  ELSE IF(XCSMISCHEME(fldID).AND.ZCSMISCHEME(fldID)) THEN
   XZCSMISCHEME=.TRUE.
  END IF

  IF(FDMISCHEME(fldID).OR.((XYDIR.AND.XYFDMISCHEME).OR.(YZDIR.AND.YZFDMISCHEME).OR.(XZDIR.AND.XZFDMISCHEME))) THEN
   IF(FDMACCESSID) THEN
    IF( FDMISCHEME(fldID)) PRINT*, " FDMISCHEME("//CHAR(48+fldID)//")"
    IF(XFDMISCHEME(fldID)) PRINT*, "XFDMISCHEME("//CHAR(48+fldID)//")"
    IF(YFDMISCHEME(fldID)) PRINT*, "YFDMISCHEME("//CHAR(48+fldID)//")"
    IF(ZFDMISCHEME(fldID)) PRINT*, "ZFDMISCHEME("//CHAR(48+fldID)//")"
    IF(ALLOCATED(IDMT)) DEALLOCATE(IDMT)
    ALLOCATE(IDMT(fDIM(1),fDIM(2)))
    CALL IDMAT(IDMT)
 
    IF(ALLOCATED(Dx)) DEALLOCATE(Dx)
    ALLOCATE(Dx(fDIM(1)))
    Dx(1:fDIM(1)-1)=LX2D(2:fDIM(1),1)-LX2D(1:fDIM(1)-1,1);Dx(fDIM(1))=Dx(fDIM(1)-1)
    IF(ALLOCATED(DxMAT)) DEALLOCATE(DxMAT)
    ALLOCATE(DxMAT(fDIM(1),fDIM(1)))
 
    IF(FDMORDER.EQ.2) THEN
     DxMAT=0.0
     DxMAT(1,1)=-2.0/(Dx(1)**2);DxMAT(1,2)=1.0/(Dx(1)**2)
     DO ifDIM=2,fDIM(1)-1
      DxMAT(ifDIM,ifDIM-1)=1.0/(Dx(ifDIM)**2);DxMAT(ifDIM,ifDIM)=-2.0/(Dx(ifDIM)**2);DxMAT(ifDIM,ifDIM+1)=1.0/(Dx(ifDIM)**2)
     END DO
     DxMAT(fDIM(1),fDIM(1)-1)=1.0/(Dx(fDIM(1))**2);DxMAT(fDIM(1),fDIM(1))=-2.0/(Dx(fDIM(1))**2)
    ELSE IF(FDMORDER.EQ.4) THEN
     DxMAT=0.0
     DxMAT(1,1)=-30.0/(12.0*Dx(1)**2);
     DxMAT(1,2)=16.0/(12.0*Dx(1)**2);DxMAT(1,3)=-1.0/(12.0*Dx(1)**2)
     DxMAT(2,1)=16.0/(12.0*Dx(2)**2);
     DxMAT(2,2)=-30.0/(12.0*Dx(2)**2);
     DxMAT(2,3)=16.0/(12.0*Dx(1)**2);DxMAT(2,4)=-1.0/(12.0*Dx(1)**2)
     DO ifDIM=2,fDIM(1)-2
      DxMAT(ifDIM,ifDIM-2)=-1.0/(12.0*Dx(ifDIM)**2);DxMAT(ifDIM,ifDIM-1)=16.0/(12.0*Dx(ifDIM)**2);
      DxMAT(ifDIM,ifDIM)=-30.0/(12.0*Dx(ifDIM)**2);
      DxMAT(ifDIM,ifDIM+1)=16.0/(12.0*Dx(ifDIM)**2);DxMAT(ifDIM,ifDIM+2)=-1.0/(12.0*Dx(ifDIM)**2)
     END DO
     DxMAT(fDIM(1)-1,fDIM(1)-3)=-1.0/(12.0*Dx(fDIM(1)-1)**2);DxMAT(fDIM(1)-1,fDIM(1)-2)=16.0/(12.0*Dx(fDIM(1)-1)**2);
     DxMAT(fDIM(1)-1,fDIM(1)-1)=-30.0/(12.0*Dx(fDIM(1)-1)**2);
     DxMAT(fDIM(1)-1,fDIM(1))=16.0/(12.0*Dx(fDIM(1)-1)**2)
     DxMAT(fDIM(1),fDIM(1)-2)=-1.0/(12.0*Dx(fDIM(1))**2);DxMAT(fDIM(1),fDIM(1)-1)=16.0/(12.0*Dx(fDIM(1))**2);
     DxMAT(fDIM(1),fDIM(1))=-30.0/(12.0*Dx(fDIM(1))**2)
    END IF

    IF(ALLOCATED(KRON1)) DEALLOCATE(KRON1)
    ALLOCATE(KRON1(fDIM(1)*fDIM(2),fDIM(1)*fDIM(2)))
    CALL KRON(IDMT,DxMAT,KRON1)
    IF(ALLOCATED(DxMAT)) DEALLOCATE(DxMAT)
 
    IF(ALLOCATED(Dy)) DEALLOCATE(Dy)
    ALLOCATE(Dy(fDIM(2)))
    Dy(1:fDIM(2)-1)=LY2D(1,2:fDIM(2))-LY2D(1,1:fDIM(2)-1);Dy(fDIM(2))=Dy(fDIM(2)-1)
    IF(ALLOCATED(DyMAT)) DEALLOCATE(DyMAT)
    ALLOCATE(DyMAT(fDIM(2),fDIM(2)))

    IF(FDMORDER.EQ.2) THEN
     DyMAT=0.0
     DyMAT(1,1)=-2.0/(Dy(1)**2);DyMAT(1,2)=1.0/(Dy(1)**2)
     DO ifDIM=2,fDIM(2)-1
      DyMAT(ifDIM,ifDIM-1)=1.0/(Dy(ifDIM)**2);DyMAT(ifDIM,ifDIM)=-2.0/(Dy(ifDIM)**2);DyMAT(ifDIM,ifDIM+1)=1.0/(Dy(ifDIM)**2)
     END DO
     DyMAT(fDIM(2),fDIM(2)-1)=1.0/(Dy(fDIM(2))**2);DyMAT(fDIM(2),fDIM(2))=-2.0/(Dy(fDIM(2))**2)
    ELSE IF(FDMORDER.EQ.4) THEN
     DyMAT=0.0d0
     DyMAT(1,1)=-30.0/(12.0*Dy(1)**2);
     DyMAT(1,2)=16.0/(12.0*Dy(1)**2);DyMAT(1,3)=-1.0/(12.0*Dy(1)**2)
     DyMAT(2,1)=16.0/(12.0*Dy(2)**2);
     DyMAT(2,2)=-30.0/(12.0d0*Dy(2)**2);
     DyMAT(2,3)=16.0/(12.0*Dy(1)**2);DyMAT(2,4)=-1.0/(12.0*Dy(1)**2)
     DO ifDIM=2,fDIM(2)-2
      DyMAT(ifDIM,ifDIM-2)=-1.0/(12.0*Dy(ifDIM)**2);DyMAT(ifDIM,ifDIM-1)=16.0/(12.0*Dy(ifDIM)**2);
      DyMAT(ifDIM,ifDIM)=-30.0/(12.0*Dy(ifDIM)**2);
      DyMAT(ifDIM,ifDIM+1)=16.0/(12.0*Dy(ifDIM)**2);DyMAT(ifDIM,ifDIM+2)=-1.0/(12.0*Dy(ifDIM)**2)
     END DO
     DyMAT(fDIM(2)-1,fDIM(2)-3)=-1.0/(12.0*Dy(fDIM(2)-1)**2);DyMAT(fDIM(2)-1,fDIM(2)-2)=16.0/(12.0*Dy(fDIM(2)-1)**2);
     DyMAT(fDIM(2)-1,fDIM(2)-1)=-30.0/(12.0*Dy(fDIM(2)-1)**2);
     DyMAT(fDIM(2)-1,fDIM(2))=16.0/(12.0*Dy(fDIM(2)-1)**2)
     DyMAT(fDIM(2),fDIM(2)-2)=-1.0/(12.0*Dy(fDIM(2))**2);DyMAT(fDIM(2),fDIM(2)-1)=16.0/(12.0*Dy(fDIM(2))**2);
     DyMAT(fDIM(2),fDIM(2))=-30.0/(12.0*Dy(fDIM(2))**2)
    END IF
 
    IF(ALLOCATED(KRON2)) DEALLOCATE(KRON2)
    ALLOCATE(KRON2(fDIM(1)*fDIM(2),fDIM(1)*fDIM(2)))
    CALL KRON(DyMAT,IDMT,KRON2)
    IF(ALLOCATED(DyMAT)) DEALLOCATE(DyMAT)
    IF(ALLOCATED(IDMT)) DEALLOCATE(IDMT)
 
    IF(ALLOCATED(invLPLC)) DEALLOCATE(invLPLC)
    ALLOCATE(invLPLC(fDIM(1)*fDIM(2),fDIM(1)*fDIM(2)))
    invLPLC=KRON1+KRON2
    IF(ALLOCATED(KRON1)) DEALLOCATE(KRON1)
    IF(ALLOCATED(KRON2)) DEALLOCATE(KRON2)
    CALL MATINV(invLPLC)

    FDMACCESSID=.FALSE.
   END IF

   IF(ALLOCATED(f1D)) DEALLOCATE(f1D)
   ALLOCATE(f1D(fDIM(1)*fDIM(2)))
   IF(ALLOCATED(Df1D)) DEALLOCATE(Df1D)
   ALLOCATE(Df1D(fDIM(1)*fDIM(2)))
   f1D=RESHAPE(f,(/fDIM(1)*fDIM(2)/))
   Df1D=MATMUL(invLPLC,f1D)
   lintLPLCf=RESHAPE(Df1D,(/fDIM(1),fDIM(2)/))
   XYFDMISCHEME=.FALSE.
   YZFDMISCHEME=.FALSE.
   XZFDMISCHEME=.FALSE.
  ELSE IF(PSMISCHEME(fldID).OR.((XYDIR.AND.XYPSMISCHEME).OR.(YZDIR.AND.YZPSMISCHEME).OR.(XZDIR.AND.XZPSMISCHEME))) THEN
   IF(PSMACCESSID) THEN
    IF( PSMISCHEME(fldID)) PRINT*, " PSMISCHEME("//CHAR(48+fldID)//")"
    IF(XPSMISCHEME(fldID)) PRINT*, "XPSMISCHEME("//CHAR(48+fldID)//")"
    IF(YPSMISCHEME(fldID)) PRINT*, "YPSMISCHEME("//CHAR(48+fldID)//")"
    IF(ZPSMISCHEME(fldID)) PRINT*, "ZPSMISCHEME("//CHAR(48+fldID)//")"
    PSMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(kf).EQV..FALSE.)     ALLOCATE(kf(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(likx).EQV..FALSE.)   ALLOCATE(likx(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(liky).EQV..FALSE.)   ALLOCATE(liky(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(llplc).EQV..FALSE.)  ALLOCATE(llplc(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(kLPLCf).EQV..FALSE.) ALLOCATE(kLPLCf(fDIM(1)/2+1,fDIM(2)))
   CALL KGRIDBUILDER(LX2D,likx)
   CALL KGRIDBUILDER(LY2D,liky)
   CALL FFTW(f,kf)
   CALL intLPLCf(kf,likx,liky,kLPLCf,1,fldID,CSPACE)
   CALL iFFTW(kLPLCf,lintLPLCf)
   XYPSMISCHEME=.FALSE.
   YZPSMISCHEME=.FALSE.
   XZPSMISCHEME=.FALSE.
  END IF

  XYDIR=.FALSE.
  YZDIR=.FALSE.
  XZDIR=.FALSE.
! XYCSMSCHEME=.FALSE.
! YZCSMSCHEME=.FALSE.
! XZCSMSCHEME=.FALSE.

  RETURN
 END SUBROUTINE r8r4r8intLPLCf2D

 SUBROUTINE r8r8r8intLPLCf2DNONE(f,LX2D,LY2D,lintLPLCf)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:)
  REAL(8), INTENT(OUT)             :: lintLPLCf(:,:)

  CALL intLPLCf(f,LX2D,LY2D,lintLPLCf,1,"xy")

  RETURN
 END SUBROUTINE r8r8r8intLPLCf2DNONE

 SUBROUTINE r8r8r8intLPLCf2D1INT(f,LX2D,LY2D,lintLPLCf,fldID)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:)
  REAL(8), INTENT(OUT)             :: lintLPLCf(:,:)
  INTEGER(4), INTENT(IN)           :: fldID

  CALL intLPLCf(f,LX2D,LY2D,lintLPLCf,fldID,"xy")

  RETURN
 END SUBROUTINE r8r8r8intLPLCf2D1INT

 SUBROUTINE r8r8r8intLPLCf2D1CHR(f,LX2D,LY2D,lintLPLCf,CSPACE)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:)
  REAL(8), INTENT(OUT)             :: lintLPLCf(:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL intLPLCf(f,LX2D,LY2D,lintLPLCf,1,CSPACE)

  RETURN
 END SUBROUTINE r8r8r8intLPLCf2D1CHR

 SUBROUTINE r8r8r8intLPLCf2D(f,LX2D,LY2D,lintLPLCf,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX2D(:,:),LY2D(:,:)
  REAL(8), INTENT(IN)              :: f(:,:)
  REAL(8), INTENT(OUT)             :: lintLPLCf(:,:)
  REAL(4), ALLOCATABLE             :: Dx(:),Dy(:)
  REAL(8), ALLOCATABLE             :: f1D(:),Df1D(:)
  REAL(8), ALLOCATABLE             :: IDMT(:,:)
  REAL(8), ALLOCATABLE             :: KRON1(:,:),KRON2(:,:)
  REAL(8), ALLOCATABLE             :: DxMAT(:,:),DyMAT(:,:)
  REAL(8), ALLOCATABLE             :: LPLC2D(:,:)
  REAL(8), ALLOCATABLE             :: tf(:,:)
  REAL(8), ALLOCATABLE             :: llplc(:,:)
  COMPLEX(8), ALLOCATABLE          :: likx(:,:),liky(:,:)
  COMPLEX(8), ALLOCATABLE          :: kf(:,:),kLPLCf(:,:)
  INTEGER(4)                       :: fDIM(2),ifDIM,ifDIM1,ifDIM2
  INTEGER(4), INTENT(IN)           :: fldID
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE
  CHARACTER(LEN=1)                 :: CSPACE1,CSPACE2
  LOGICAL,    SAVE                 :: FDMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: PSMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: CSMACCESSID=.TRUE.
  LOGICAL                          :: XYDIR=.FALSE.
  LOGICAL                          :: YZDIR=.FALSE.
  LOGICAL                          :: XZDIR=.FALSE.
  LOGICAL                          :: XYFDMISCHEME=.FALSE.
  LOGICAL                          :: YZFDMISCHEME=.FALSE.
  LOGICAL                          :: XZFDMISCHEME=.FALSE.
  LOGICAL                          :: XYPSMISCHEME=.FALSE.
  LOGICAL                          :: YZPSMISCHEME=.FALSE.
  LOGICAL                          :: XZPSMISCHEME=.FALSE.
  LOGICAL                          :: XYCSMISCHEME=.FALSE.
  LOGICAL                          :: YZCSMISCHEME=.FALSE.
  LOGICAL                          :: XZCSMISCHEME=.FALSE.

  fDIM=SHAPE(f)

  IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, intLPLCf: NUMBER OF CURRENT SPACES ARE NOT ENOUGH!"
   STOP
  ELSE IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, intLPLCf: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, intLPLCf: NUMBER OF CURRENT SPACES ARE TOO MANY!"
   STOP
  END IF

  IF((CSPACE1.EQ."x".AND.CSPACE1.EQ."X").AND.(CSPACE2.EQ."y".AND.CSPACE2.EQ."Y")) THEN
   XYDIR=.TRUE.
  ELSE IF((CSPACE1.EQ."y".AND.CSPACE1.EQ."Y").AND.(CSPACE2.EQ."z".AND.CSPACE2.EQ."Z")) THEN
   YZDIR=.TRUE.
  ELSE IF((CSPACE1.EQ."x".AND.CSPACE1.EQ."X").AND.(CSPACE2.EQ."z".AND.CSPACE2.EQ."Z")) THEN
   XZDIR=.TRUE.
  END IF

  IF(XFDMISCHEME(fldID).AND.YFDMISCHEME(fldID)) THEN
   XYFDMISCHEME=.TRUE.
  ELSE IF(YFDMISCHEME(fldID).AND.ZFDMISCHEME(fldID)) THEN
   YZFDMISCHEME=.TRUE.
  ELSE IF(XFDMISCHEME(fldID).AND.ZFDMISCHEME(fldID)) THEN
   XZFDMISCHEME=.TRUE.
  ELSE IF(XPSMISCHEME(fldID).AND.YPSMISCHEME(fldID)) THEN
   XYPSMISCHEME=.TRUE.
  ELSE IF(YPSMISCHEME(fldID).AND.ZPSMISCHEME(fldID)) THEN
   YZPSMISCHEME=.TRUE.
  ELSE IF(XPSMISCHEME(fldID).AND.ZPSMISCHEME(fldID)) THEN
   XZPSMISCHEME=.TRUE.
  ELSE IF(XCSMISCHEME(fldID).AND.YCSMISCHEME(fldID)) THEN
   XYCSMISCHEME=.TRUE.
  ELSE IF(YCSMISCHEME(fldID).AND.ZCSMISCHEME(fldID)) THEN
   YZCSMISCHEME=.TRUE.
  ELSE IF(XCSMISCHEME(fldID).AND.ZCSMISCHEME(fldID)) THEN
   XZCSMISCHEME=.TRUE.
  END IF

  IF(FDMISCHEME(fldID).OR.((XYDIR.AND.XYFDMISCHEME).OR.(YZDIR.AND.YZFDMISCHEME).OR.(XZDIR.AND.XZFDMISCHEME))) THEN
   IF(FDMACCESSID) THEN
    IF( FDMISCHEME(fldID)) PRINT*, " FDMISCHEME("//CHAR(48+fldID)//")"
    IF(XFDMISCHEME(fldID)) PRINT*, "XFDMISCHEME("//CHAR(48+fldID)//")"
    IF(YFDMISCHEME(fldID)) PRINT*, "YFDMISCHEME("//CHAR(48+fldID)//")"
    IF(ZFDMISCHEME(fldID)) PRINT*, "ZFDMISCHEME("//CHAR(48+fldID)//")"
    IF(ALLOCATED(IDMT)) DEALLOCATE(IDMT)
    ALLOCATE(IDMT(fDIM(1),fDIM(2)))
    CALL IDMAT(IDMT)
 
    IF(ALLOCATED(Dx)) DEALLOCATE(Dx)
    ALLOCATE(Dx(fDIM(1)))
    Dx(1:fDIM(1)-1)=LX2D(2:fDIM(1),1)-LX2D(1:fDIM(1)-1,1);Dx(fDIM(1))=Dx(fDIM(1)-1)
    IF(ALLOCATED(DxMAT)) DEALLOCATE(DxMAT)
    ALLOCATE(DxMAT(fDIM(1),fDIM(1)))
 
    IF(FDMORDER.EQ.2) THEN
     DxMAT=0.0
     DxMAT(1,1)=-2.0/(Dx(1)**2);DxMAT(1,2)=1.0/(Dx(1)**2)
     DO ifDIM=2,fDIM(1)-1
      DxMAT(ifDIM,ifDIM-1)=1.0/(Dx(ifDIM)**2);DxMAT(ifDIM,ifDIM)=-2.0/(Dx(ifDIM)**2);DxMAT(ifDIM,ifDIM+1)=1.0/(Dx(ifDIM)**2)
     END DO
     DxMAT(fDIM(1),fDIM(1)-1)=1.0/(Dx(fDIM(1))**2);DxMAT(fDIM(1),fDIM(1))=-2.0/(Dx(fDIM(1))**2)
    ELSE IF(FDMORDER.EQ.4) THEN
     DxMAT=0.0
     DxMAT(1,1)=-30.0/(12.0*Dx(1)**2);
     DxMAT(1,2)=16.0/(12.0*Dx(1)**2);DxMAT(1,3)=-1.0/(12.0*Dx(1)**2)
     DxMAT(2,1)=16.0/(12.0*Dx(2)**2);
     DxMAT(2,2)=-30.0/(12.0*Dx(2)**2);
     DxMAT(2,3)=16.0/(12.0*Dx(1)**2);DxMAT(2,4)=-1.0/(12.0*Dx(1)**2)
     DO ifDIM=2,fDIM(1)-2
      DxMAT(ifDIM,ifDIM-2)=-1.0/(12.0*Dx(ifDIM)**2);DxMAT(ifDIM,ifDIM-1)=16.0/(12.0*Dx(ifDIM)**2);
      DxMAT(ifDIM,ifDIM)=-30.0/(12.0*Dx(ifDIM)**2);
      DxMAT(ifDIM,ifDIM+1)=16.0/(12.0*Dx(ifDIM)**2);DxMAT(ifDIM,ifDIM+2)=-1.0/(12.0*Dx(ifDIM)**2)
     END DO
     DxMAT(fDIM(1)-1,fDIM(1)-3)=-1.0/(12.0*Dx(fDIM(1)-1)**2);DxMAT(fDIM(1)-1,fDIM(1)-2)=16.0/(12.0*Dx(fDIM(1)-1)**2);
     DxMAT(fDIM(1)-1,fDIM(1)-1)=-30.0/(12.0*Dx(fDIM(1)-1)**2);
     DxMAT(fDIM(1)-1,fDIM(1))=16.0/(12.0*Dx(fDIM(1)-1)**2)
     DxMAT(fDIM(1),fDIM(1)-2)=-1.0/(12.0*Dx(fDIM(1))**2);DxMAT(fDIM(1),fDIM(1)-1)=16.0/(12.0*Dx(fDIM(1))**2);
     DxMAT(fDIM(1),fDIM(1))=-30.0/(12.0*Dx(fDIM(1))**2)
    END IF

    IF(ALLOCATED(KRON1)) DEALLOCATE(KRON1)
    ALLOCATE(KRON1(fDIM(1)*fDIM(2),fDIM(1)*fDIM(2)))
    CALL KRON(IDMT,DxMAT,KRON1)
    IF(ALLOCATED(DxMAT)) DEALLOCATE(DxMAT)
 
    IF(ALLOCATED(Dy)) DEALLOCATE(Dy)
    ALLOCATE(Dy(fDIM(2)))
    Dy(1:fDIM(2)-1)=LY2D(1,2:fDIM(2))-LY2D(1,1:fDIM(2)-1);Dy(fDIM(2))=Dy(fDIM(2)-1)
    IF(ALLOCATED(DyMAT)) DEALLOCATE(DyMAT)
    ALLOCATE(DyMAT(fDIM(2),fDIM(2)))

    IF(FDMORDER.EQ.2) THEN
     DyMAT=0.0
     DyMAT(1,1)=-2.0/(Dy(1)**2);DyMAT(1,2)=1.0/(Dy(1)**2)
     DO ifDIM=2,fDIM(2)-1
      DyMAT(ifDIM,ifDIM-1)=1.0/(Dy(ifDIM)**2);DyMAT(ifDIM,ifDIM)=-2.0/(Dy(ifDIM)**2);DyMAT(ifDIM,ifDIM+1)=1.0/(Dy(ifDIM)**2)
     END DO
     DyMAT(fDIM(2),fDIM(2)-1)=1.0/(Dy(fDIM(2))**2);DyMAT(fDIM(2),fDIM(2))=-2.0/(Dy(fDIM(2))**2)
    ELSE IF(FDMORDER.EQ.4) THEN
     DyMAT=0.0d0
     DyMAT(1,1)=-30.0/(12.0*Dy(1)**2);
     DyMAT(1,2)=16.0/(12.0*Dy(1)**2);DyMAT(1,3)=-1.0/(12.0*Dy(1)**2)
     DyMAT(2,1)=16.0/(12.0*Dy(2)**2);
     DyMAT(2,2)=-30.0/(12.0d0*Dy(2)**2);
     DyMAT(2,3)=16.0/(12.0*Dy(1)**2);DyMAT(2,4)=-1.0/(12.0*Dy(1)**2)
     DO ifDIM=2,fDIM(2)-2
      DyMAT(ifDIM,ifDIM-2)=-1.0/(12.0*Dy(ifDIM)**2);DyMAT(ifDIM,ifDIM-1)=16.0/(12.0*Dy(ifDIM)**2);
      DyMAT(ifDIM,ifDIM)=-30.0/(12.0*Dy(ifDIM)**2);
      DyMAT(ifDIM,ifDIM+1)=16.0/(12.0*Dy(ifDIM)**2);DyMAT(ifDIM,ifDIM+2)=-1.0/(12.0*Dy(ifDIM)**2)
     END DO
     DyMAT(fDIM(2)-1,fDIM(2)-3)=-1.0/(12.0*Dy(fDIM(2)-1)**2);DyMAT(fDIM(2)-1,fDIM(2)-2)=16.0/(12.0*Dy(fDIM(2)-1)**2);
     DyMAT(fDIM(2)-1,fDIM(2)-1)=-30.0/(12.0*Dy(fDIM(2)-1)**2);
     DyMAT(fDIM(2)-1,fDIM(2))=16.0/(12.0*Dy(fDIM(2)-1)**2)
     DyMAT(fDIM(2),fDIM(2)-2)=-1.0/(12.0*Dy(fDIM(2))**2);DyMAT(fDIM(2),fDIM(2)-1)=16.0/(12.0*Dy(fDIM(2))**2);
     DyMAT(fDIM(2),fDIM(2))=-30.0/(12.0*Dy(fDIM(2))**2)
    END IF
 
    IF(ALLOCATED(KRON2)) DEALLOCATE(KRON2)
    ALLOCATE(KRON2(fDIM(1)*fDIM(2),fDIM(1)*fDIM(2)))
    CALL KRON(DyMAT,IDMT,KRON2)
    IF(ALLOCATED(DyMAT)) DEALLOCATE(DyMAT)
    IF(ALLOCATED(IDMT)) DEALLOCATE(IDMT)
 
    IF(ALLOCATED(invLPLC)) DEALLOCATE(invLPLC)
    ALLOCATE(invLPLC(fDIM(1)*fDIM(2),fDIM(1)*fDIM(2)))
    invLPLC=KRON1+KRON2
    IF(ALLOCATED(KRON1)) DEALLOCATE(KRON1)
    IF(ALLOCATED(KRON2)) DEALLOCATE(KRON2)
    CALL MATINV(invLPLC)

    FDMACCESSID=.FALSE.
   END IF

   IF(ALLOCATED(f1D)) DEALLOCATE(f1D)
   ALLOCATE(f1D(fDIM(1)*fDIM(2)))
   IF(ALLOCATED(Df1D)) DEALLOCATE(Df1D)
   ALLOCATE(Df1D(fDIM(1)*fDIM(2)))
   f1D=RESHAPE(f,(/fDIM(1)*fDIM(2)/))
   Df1D=MATMUL(invLPLC,f1D)
   lintLPLCf=RESHAPE(Df1D,(/fDIM(1),fDIM(2)/))
   XYFDMISCHEME=.FALSE.
   YZFDMISCHEME=.FALSE.
   XZFDMISCHEME=.FALSE.
  ELSE IF(PSMISCHEME(fldID).OR.((XYDIR.AND.XYPSMISCHEME).OR.(YZDIR.AND.YZPSMISCHEME).OR.(XZDIR.AND.XZPSMISCHEME))) THEN
   IF(PSMACCESSID) THEN
    IF( PSMISCHEME(fldID)) PRINT*, " PSMISCHEME("//CHAR(48+fldID)//")"
    IF(XPSMISCHEME(fldID)) PRINT*, "XPSMISCHEME("//CHAR(48+fldID)//")"
    IF(YPSMISCHEME(fldID)) PRINT*, "YPSMISCHEME("//CHAR(48+fldID)//")"
    IF(ZPSMISCHEME(fldID)) PRINT*, "ZPSMISCHEME("//CHAR(48+fldID)//")"
    PSMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(kf).EQV..FALSE.)     ALLOCATE(kf(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(likx).EQV..FALSE.)   ALLOCATE(likx(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(liky).EQV..FALSE.)   ALLOCATE(liky(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(llplc).EQV..FALSE.)  ALLOCATE(llplc(fDIM(1)/2+1,fDIM(2)))
   IF(ALLOCATED(kLPLCf).EQV..FALSE.) ALLOCATE(kLPLCf(fDIM(1)/2+1,fDIM(2)))
   CALL KGRIDBUILDER(LX2D,likx)
   CALL KGRIDBUILDER(LY2D,liky)
   CALL FFTW(f,kf)
   CALL intLPLCf(kf,likx,liky,kLPLCf,1,fldID,CSPACE)
   CALL iFFTW(kLPLCf,lintLPLCf)
   XYPSMISCHEME=.FALSE.
   YZPSMISCHEME=.FALSE.
   XZPSMISCHEME=.FALSE.
  END IF

  XYDIR=.FALSE.
  YZDIR=.FALSE.
  XZDIR=.FALSE.
! XYCSMSCHEME=.FALSE.
! YZCSMSCHEME=.FALSE.
! XZCSMSCHEME=.FALSE.

  RETURN
 END SUBROUTINE r8r8r8intLPLCf2D

 SUBROUTINE c8c8c8intLPLCf3DNONE(kf,likx,liky,kLPLCf,DORDER)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)  :: likx(:,:,:),liky(:,:,:)
  COMPLEX(8),       INTENT(IN)  :: kf(:,:,:)
  COMPLEX(8),       INTENT(OUT) :: kLPLCf(:,:,:)
  INTEGER(4),       INTENT(IN)  :: DORDER

  CALL intLPLCf(kf,likx,liky,kLPLCf,DORDER,1,"xy")

  RETURN
 END SUBROUTINE c8c8c8intLPLCf3DNONE

 SUBROUTINE c8c8c8intLPLCf3D1INT(kf,likx,liky,kLPLCf,DORDER,fldID)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)  :: likx(:,:,:),liky(:,:,:)
  COMPLEX(8),       INTENT(IN)  :: kf(:,:,:)
  COMPLEX(8),       INTENT(OUT) :: kLPLCf(:,:,:)
  INTEGER(4),       INTENT(IN)  :: DORDER,fldID

  CALL intLPLCf(kf,likx,liky,kLPLCf,DORDER,fldID,"xy")

  RETURN
 END SUBROUTINE c8c8c8intLPLCf3D1INT

 SUBROUTINE c8c8c8intLPLCf3D1CHR(kf,likx,liky,kLPLCf,DORDER,CSPACE)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)  :: likx(:,:,:),liky(:,:,:)
  COMPLEX(8),       INTENT(IN)  :: kf(:,:,:)
  COMPLEX(8),       INTENT(OUT) :: kLPLCf(:,:,:)
  INTEGER(4),       INTENT(IN)  :: DORDER
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE

  CALL intLPLCf(kf,likx,liky,kLPLCf,DORDER,1,CSPACE)

  RETURN
 END SUBROUTINE c8c8c8intLPLCf3D1CHR

 SUBROUTINE c8c8c8intLPLCf3D(kf,likx,liky,kLPLCf,DORDER,fldID,CSPACE)
  IMPLICIT NONE
  COMPLEX(8),       INTENT(IN)  :: likx(:,:,:),liky(:,:,:)
  COMPLEX(8),       INTENT(IN)  :: kf(:,:,:)
  COMPLEX(8),       INTENT(OUT) :: kLPLCf(:,:,:)
  INTEGER(4),       INTENT(IN)  :: DORDER,fldID
  INTEGER(4)                    :: IORDER,ifDIM1,ifDIM2,ifDIM3
  INTEGER(4)                    :: kfDIMS(3)
  REAL(8),          ALLOCATABLE :: llplc(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE
  CHARACTER(LEN=1)              :: CSPACE1,CSPACE2,CSPACE3

  IF(LEN(CSPACE).EQ.3) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   CSPACE3=CSPACE(3:3)
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, intLPLCf: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
   IF(CSPACE1.EQ.CSPACE3) THEN
    PRINT*, "ERROR, intLPLCf: (CSPACE1 = CSPACE3) IS NOT ALLOWED"
    STOP
   END IF
   IF(CSPACE2.EQ.CSPACE3) THEN
    PRINT*, "ERROR, intLPLCf: (CSPACE2 = CSPACE3) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).LT.3) THEN
   PRINT*, "ERROR, intLPLCf: NUMBER OF CURRENT SPACES ARE NOT ENOUGH!"
   STOP
  ELSE IF(LEN(CSPACE).GT.3) THEN
   PRINT*, "ERROR, intLPLCf: NUMBER OF CURRENT SPACES ARE TOO MANY!"
   STOP
  END IF

  kfDIMS=SHAPE(kf)
  ALLOCATE(llplc(kfDIMS(1),kfDIMS(2),kfDIMS(3)))
  llplc=REAL(likx*likx+liky*liky,8)

  kLPLCf=kf
  DO IORDER=1,DORDER
   DO ifDIM1=1,kfDIMS(1)
    DO ifDIM2=1,kfDIMS(2)
     DO ifDIM3=1,kfDIMS(3)
      IF(llplc(ifDIM1,ifDIM2,ifDIM3).EQ.0.0d0) THEN
       kLPLCf(ifDIM1,ifDIM2,ifDIM3)=CMPLX(0.0d0,0.0d0)
      ELSE
       kLPLCf(ifDIM1,ifDIM2,ifDIM3)=kLPLCf(ifDIM1,ifDIM2,ifDIM3)/llplc(ifDIM1,ifDIM2,ifDIM3)
      END IF
     END DO
    END DO
   END DO
  END DO

  RETURN
 END SUBROUTINE c8c8c8intLPLCf3D

 SUBROUTINE r4r4c8intLPLCf3DNONE(f,LX3D,LY3D,klintLPLCf)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(4), INTENT(IN)              :: f(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: klintLPLCf(:,:,:)

  CALL intLPLCf(f,LX3D,LY3D,klintLPLCf,1,"xy")

  RETURN
 END SUBROUTINE r4r4c8intLPLCf3DNONE

 SUBROUTINE r4r4c8intLPLCf3D1INT(f,LX3D,LY3D,klintLPLCf,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(4), INTENT(IN)              :: f(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: klintLPLCf(:,:,:)
  INTEGER(4), INTENT(IN)           :: fldID

  CALL intLPLCf(f,LX3D,LY3D,klintLPLCf,fldID,"xy")

  RETURN
 END SUBROUTINE r4r4c8intLPLCf3D1INT

 SUBROUTINE r4r4c8intLPLCf3D1CHR(f,LX3D,LY3D,klintLPLCf,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(4), INTENT(IN)              :: f(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: klintLPLCf(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL intLPLCf(f,LX3D,LY3D,klintLPLCf,1,CSPACE)

  RETURN
 END SUBROUTINE r4r4c8intLPLCf3D1CHR

 SUBROUTINE r4r4c8intLPLCf3D(f,LX3D,LY3D,klintLPLCf,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)           :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(4), INTENT(IN)           :: f(:,:,:)
  REAL(4), ALLOCATABLE          :: rlintLPLCf(:,:,:)
  COMPLEX(8), INTENT(OUT)       :: klintLPLCf(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:,:),liky(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE
  INTEGER(4), INTENT(IN)        :: fldID
  INTEGER(4)                    :: fDIMS(3)

  fDIMS=SHAPE(f)

  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))

  CALL KGRIDBUILDER(LX3D,likx)
  CALL KGRIDBUILDER(LY3D,liky)
  CALL FFTW(f,kf)
  CALL intLPLCf(kf,likx,liky,klintLPLCf,fldID,CSPACE)

  RETURN
 END SUBROUTINE r4r4c8intLPLCf3D

 SUBROUTINE r4r4r4intLPLCf3DNONE(f,LX3D,LY3D,lintLPLCf)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(4), INTENT(IN)              :: f(:,:,:)
  REAL(4), INTENT(OUT)             :: lintLPLCf(:,:,:)

  CALL intLPLCf(f,LX3D,LY3D,lintLPLCf,1,"xy")

  RETURN
 END SUBROUTINE r4r4r4intLPLCf3DNONE

 SUBROUTINE r4r4r4intLPLCf3D1INT(f,LX3D,LY3D,lintLPLCf,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(4), INTENT(IN)              :: f(:,:,:)
  REAL(4), INTENT(OUT)             :: lintLPLCf(:,:,:)
  INTEGER(4), INTENT(IN)           :: fldID
  
  CALL intLPLCf(f,LX3D,LY3D,lintLPLCf,fldID,"xy")

  RETURN
 END SUBROUTINE r4r4r4intLPLCf3D1INT

 SUBROUTINE r4r4r4intLPLCf3D1CHR(f,LX3D,LY3D,lintLPLCf,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(4), INTENT(IN)              :: f(:,:,:)
  REAL(4), INTENT(OUT)             :: lintLPLCf(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL intLPLCf(f,LX3D,LY3D,lintLPLCf,1,CSPACE)

  RETURN
 END SUBROUTINE r4r4r4intLPLCf3D1CHR

 SUBROUTINE r4r4r4intLPLCf3D(f,LX3D,LY3D,lintLPLCf,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)     :: f(:,:,:)
  REAL(4), INTENT(OUT)    :: lintLPLCf(:,:,:)
  REAL(4), INTENT(IN)     :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(4), ALLOCATABLE    :: tf(:,:,:)
  REAL(8), ALLOCATABLE    :: llplc(:,:,:)
  COMPLEX(8), ALLOCATABLE :: likx(:,:,:),liky(:,:,:)
  COMPLEX(8), ALLOCATABLE :: kf(:,:,:),kLPLCf(:,:,:)
  INTEGER(4)              :: fDIM(3),ifDIM1,ifDIM2,ifDIM3
  INTEGER(4)              :: DxDIR,DyDIR
  INTEGER(4), INTENT(IN)  :: fldID
  CHARACTER(LEN=*), INTENT(IN) :: CSPACE
  CHARACTER(LEN=1)             :: CSPACE1,CSPACE2
  LOGICAL,    SAVE                 :: FDMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: PSMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: CSMACCESSID=.TRUE.
  LOGICAL                 :: XYDIR=.FALSE.
  LOGICAL                 :: YZDIR=.FALSE.
  LOGICAL                 :: XZDIR=.FALSE.
  LOGICAL                 :: XYFDMISCHEME=.FALSE.
  LOGICAL                 :: YZFDMISCHEME=.FALSE.
  LOGICAL                 :: XZFDMISCHEME=.FALSE.
  LOGICAL                 :: XYPSMISCHEME=.FALSE.
  LOGICAL                 :: YZPSMISCHEME=.FALSE.
  LOGICAL                 :: XZPSMISCHEME=.FALSE.
  LOGICAL                 :: XYCSMISCHEME=.FALSE.
  LOGICAL                 :: YZCSMISCHEME=.FALSE.
  LOGICAL                 :: XZCSMISCHEME=.FALSE.

  fDIM=SHAPE(f)

  IF(fDIM(1).EQ.1) THEN
   DxDIR=2;DyDIR=3
  ELSE IF(fDIM(2).EQ.1) THEN
   DxDIR=1;DyDIR=3
  ELSE IF(fDIM(3).EQ.1) THEN
   DxDIR=1;DyDIR=2
  ELSE
   DxDIR=1
   DO ifDIM2=1,fDIM(2)
    IF(LX3D(1,ifDIM2,1).NE.LX3D(1,1,1)) THEN
     DxDIR=2
     EXIT
    END IF
   END DO
   DO ifDIM3=1,fDIM(3)
    IF(LX3D(1,1,ifDIM3).NE.LX3D(1,1,1)) THEN
     DxDIR=3
     EXIT
    END IF
   END DO
   DyDIR=1
   DO ifDIM2=1,fDIM(2)
    IF(LY3D(1,ifDIM2,1).NE.LY3D(1,1,1)) THEN
     DyDIR=2
     EXIT
    END IF
   END DO
   DO ifDIM3=1,fDIM(3)
    IF(LY3D(1,1,ifDIM3).NE.LY3D(1,1,1)) THEN
     DyDIR=3
     EXIT
    END IF
   END DO
  END IF

  IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, intLPLCf: NUMBER OF CURRENT SPACES ARE NOT ENOUGH!"
   STOP
  ELSE IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, intLPLCf: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, intLPLCf: NUMBER OF CURRENT SPACES ARE TOO MANY!"
   STOP
  END IF

  IF((CSPACE1.EQ."x".AND.CSPACE1.EQ."X").AND.(CSPACE2.EQ."y".AND.CSPACE2.EQ."Y")) THEN
   XYDIR=.TRUE.
  ELSE IF((CSPACE1.EQ."y".AND.CSPACE1.EQ."Y").AND.(CSPACE2.EQ."z".AND.CSPACE2.EQ."Z")) THEN
   YZDIR=.TRUE.
  ELSE IF((CSPACE1.EQ."x".AND.CSPACE1.EQ."X").AND.(CSPACE2.EQ."z".AND.CSPACE2.EQ."Z")) THEN
   XZDIR=.TRUE.
  END IF

  IF(XFDMISCHEME(fldID).AND.YFDMISCHEME(fldID)) THEN
   XYFDMISCHEME=.TRUE.
  ELSE IF(YFDMISCHEME(fldID).AND.ZFDMISCHEME(fldID)) THEN
   YZFDMISCHEME=.TRUE.
  ELSE IF(XFDMISCHEME(fldID).AND.ZFDMISCHEME(fldID)) THEN
   XZFDMISCHEME=.TRUE.
  ELSE IF(XPSMISCHEME(fldID).AND.YPSMISCHEME(fldID)) THEN
   XYPSMISCHEME=.TRUE.
  ELSE IF(YPSMISCHEME(fldID).AND.ZPSMISCHEME(fldID)) THEN
   YZPSMISCHEME=.TRUE.
  ELSE IF(XPSMISCHEME(fldID).AND.ZPSMISCHEME(fldID)) THEN
   XZPSMISCHEME=.TRUE.
  ELSE IF(XCSMISCHEME(fldID).AND.YCSMISCHEME(fldID)) THEN
   XYCSMISCHEME=.TRUE.
  ELSE IF(YCSMISCHEME(fldID).AND.ZCSMISCHEME(fldID)) THEN
   YZCSMISCHEME=.TRUE.
  ELSE IF(XCSMISCHEME(fldID).AND.ZCSMISCHEME(fldID)) THEN
   XZCSMISCHEME=.TRUE.
  END IF

  IF(PSMISCHEME(fldID).OR.((XYDIR.AND.XYPSMISCHEME).OR.(YZDIR.AND.YZPSMISCHEME).OR.(XZDIR.AND.XZPSMISCHEME))) THEN
   IF(PSMACCESSID) THEN
    IF( PSMISCHEME(fldID)) PRINT*, " PSMISCHEME("//CHAR(48+fldID)//")"
    IF(XPSMISCHEME(fldID)) PRINT*, "XPSMISCHEME("//CHAR(48+fldID)//")"
    IF(YPSMISCHEME(fldID)) PRINT*, "YPSMISCHEME("//CHAR(48+fldID)//")"
    IF(ZPSMISCHEME(fldID)) PRINT*, "ZPSMISCHEME("//CHAR(48+fldID)//")"
    PSMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(kf).EQV..FALSE.)     ALLOCATE(kf(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(likx).EQV..FALSE.)   ALLOCATE(likx(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(liky).EQV..FALSE.)   ALLOCATE(liky(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(llplc).EQV..FALSE.)  ALLOCATE(llplc(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(kLPLCf).EQV..FALSE.) ALLOCATE(kLPLCf(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   CALL KGRIDBUILDER(LX3D,likx)
   CALL KGRIDBUILDER(LY3D,liky)
   CALL FFTW(f,kf)
   CALL intLPLCf(kf,likx,liky,kLPLCf,1,fldID,CSPACE)
   CALL iFFTW(kLPLCf,lintLPLCf)
   XYPSMISCHEME=.FALSE.
   YZPSMISCHEME=.FALSE.
   XZPSMISCHEME=.FALSE.
  ELSE
   IF(DxDIR.EQ.1.AND.DyDIR.EQ.2) THEN
    DO ifDIM3=1,fDIM(3)
     CALL intLPLCf(f(:,:,ifDIM3),LX3D(:,:,ifDIM3),LY3D(:,:,ifDIM3),lintLPLCf(:,:,ifDIM3),fldID,CSPACE)
    END DO
   ELSE IF(DxDIR.EQ.1.AND.DyDIR.EQ.3) THEN
    DO ifDIM2=1,fDIM(2)
     CALL intLPLCf(f(:,ifDIM2,:),LX3D(:,ifDIM2,:),LY3D(:,ifDIM2,:),lintLPLCf(:,ifDIM2,:),fldID,CSPACE)
    END DO
   ELSE IF(DxDIR.EQ.2.AND.DyDIR.EQ.3) THEN
    DO ifDIM1=1,fDIM(1)
     CALL intLPLCf(f(ifDIM1,:,:),LX3D(ifDIM1,:,:),LY3D(ifDIM1,:,:),lintLPLCf(ifDIM1,:,:),fldID,CSPACE)
    END DO
   END IF
   XYFDMISCHEME=.FALSE.
   YZFDMISCHEME=.FALSE.
   XZFDMISCHEME=.FALSE.
  END IF

  XYDIR=.FALSE.
  YZDIR=.FALSE.
  XZDIR=.FALSE.
! XYCSMSCHEME=.FALSE.
! YZCSMSCHEME=.FALSE.
! XZCSMSCHEME=.FALSE.

  RETURN
 END SUBROUTINE r4r4r4intLPLCf3D

 SUBROUTINE r8r4c8intLPLCf3DNONE(f,LX3D,LY3D,klintLPLCf)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: klintLPLCf(:,:,:)
   
  CALL intLPLCf(f,LX3D,LY3D,klintLPLCf,1,"xy")
   
  RETURN
 END SUBROUTINE r8r4c8intLPLCf3DNONE
   
 SUBROUTINE r8r4c8intLPLCf3D1INT(f,LX3D,LY3D,klintLPLCf,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: klintLPLCf(:,:,:)
  INTEGER(4), INTENT(IN)           :: fldID
    
  CALL intLPLCf(f,LX3D,LY3D,klintLPLCf,fldID,"xy")
   
  RETURN
 END SUBROUTINE r8r4c8intLPLCf3D1INT
   
 SUBROUTINE r8r4c8intLPLCf3D1CHR(f,LX3D,LY3D,klintLPLCf,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: klintLPLCf(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL intLPLCf(f,LX3D,LY3D,klintLPLCf,1,CSPACE)

  RETURN
 END SUBROUTINE r8r4c8intLPLCf3D1CHR
  
 SUBROUTINE r8r4c8intLPLCf3D(f,LX3D,LY3D,klintLPLCf,fldID,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)           :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)           :: f(:,:,:)
  REAL(8), ALLOCATABLE          :: rlintLPLCf(:,:,:)
  COMPLEX(8), INTENT(OUT)       :: klintLPLCf(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:,:),liky(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE
  INTEGER(4), INTENT(IN)        :: fldID
  INTEGER(4)                    :: fDIMS(3)

  fDIMS=SHAPE(f)

  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))

  CALL KGRIDBUILDER(LX3D,likx)
  CALL KGRIDBUILDER(LY3D,liky)
  CALL FFTW(f,kf)
  CALL intLPLCf(kf,likx,liky,klintLPLCf,fldID,CSPACE)

  RETURN
 END SUBROUTINE r8r4c8intLPLCf3D

 SUBROUTINE r8r8c8intLPLCf3DNONE(f,LX3D,LY3D,klintLPLCf)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: klintLPLCf(:,:,:)
   
  CALL intLPLCf(f,LX3D,LY3D,klintLPLCf,1,"xy")
   
  RETURN
 END SUBROUTINE r8r8c8intLPLCf3DNONE
   
 SUBROUTINE r8r8c8intLPLCf3D1INT(f,LX3D,LY3D,klintLPLCf,fldID)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: klintLPLCf(:,:,:)
  INTEGER(4), INTENT(IN)           :: fldID
    
  CALL intLPLCf(f,LX3D,LY3D,klintLPLCf,fldID,"xy")
   
  RETURN
 END SUBROUTINE r8r8c8intLPLCf3D1INT
   
 SUBROUTINE r8r8c8intLPLCf3D1CHR(f,LX3D,LY3D,klintLPLCf,CSPACE)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:)
  COMPLEX(8), INTENT(OUT)          :: klintLPLCf(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL intLPLCf(f,LX3D,LY3D,klintLPLCf,1,CSPACE)

  RETURN
 END SUBROUTINE r8r8c8intLPLCf3D1CHR
  
 SUBROUTINE r8r8c8intLPLCf3D(f,LX3D,LY3D,klintLPLCf,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8), INTENT(IN)           :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)           :: f(:,:,:)
  REAL(8), ALLOCATABLE          :: rlintLPLCf(:,:,:)
  COMPLEX(8), INTENT(OUT)       :: klintLPLCf(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: kf(:,:,:)
  COMPLEX(8),       ALLOCATABLE :: likx(:,:,:),liky(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)  :: CSPACE
  INTEGER(4), INTENT(IN)        :: fldID
  INTEGER(4)                    :: fDIMS(3)

  fDIMS=SHAPE(f)

  IF(ALLOCATED(kf).EQV..FALSE.)   ALLOCATE(kf(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(likx).EQV..FALSE.) ALLOCATE(likx(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))
  IF(ALLOCATED(liky).EQV..FALSE.) ALLOCATE(liky(fDIMS(1)/2+1,fDIMS(2),fDIMS(3)))

  CALL KGRIDBUILDER(LX3D,likx)
  CALL KGRIDBUILDER(LY3D,liky)
  CALL FFTW(f,kf)
  CALL intLPLCf(kf,likx,liky,klintLPLCf,fldID,CSPACE)

  RETURN
 END SUBROUTINE r8r8c8intLPLCf3D

 SUBROUTINE r8r4r8intLPLCf3DNONE(f,LX3D,LY3D,lintLPLCf)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:)
  REAL(8), INTENT(OUT)             :: lintLPLCf(:,:,:)

  CALL intLPLCf(f,LX3D,LY3D,lintLPLCf,1,"xy")

  RETURN
 END SUBROUTINE r8r4r8intLPLCf3DNONE
  
 SUBROUTINE r8r4r8intLPLCf3D1INT(f,LX3D,LY3D,lintLPLCf,fldID)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:)
  REAL(8), INTENT(OUT)             :: lintLPLCf(:,:,:)
  INTEGER(4), INTENT(IN)           :: fldID
  
  CALL intLPLCf(f,LX3D,LY3D,lintLPLCf,fldID,"xy")

  RETURN
 END SUBROUTINE r8r4r8intLPLCf3D1INT

 SUBROUTINE r8r4r8intLPLCf3D1CHR(f,LX3D,LY3D,lintLPLCf,CSPACE)
  IMPLICIT NONE
  REAL(4), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:)
  REAL(8), INTENT(OUT)             :: lintLPLCf(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL intLPLCf(f,LX3D,LY3D,lintLPLCf,1,CSPACE)

  RETURN
 END SUBROUTINE r8r4r8intLPLCf3D1CHR

 SUBROUTINE r8r4r8intLPLCf3D(f,LX3D,LY3D,lintLPLCf,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8), INTENT(IN)     :: f(:,:,:)
  REAL(8), INTENT(OUT)    :: lintLPLCf(:,:,:)
  REAL(4), INTENT(IN)     :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), ALLOCATABLE    :: tf(:,:,:)
  REAL(8), ALLOCATABLE    :: llplc(:,:,:)
  COMPLEX(8), ALLOCATABLE :: likx(:,:,:),liky(:,:,:)
  COMPLEX(8), ALLOCATABLE :: kf(:,:,:),kLPLCf(:,:,:)
  INTEGER(4)              :: fDIM(3),ifDIM1,ifDIM2,ifDIM3
  INTEGER(4), INTENT(IN)  :: fldID
  CHARACTER(LEN=*), INTENT(IN) :: CSPACE
  CHARACTER(LEN=1)             :: CSPACE1,CSPACE2
  LOGICAL,    SAVE                 :: FDMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: PSMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: CSMACCESSID=.TRUE.
  INTEGER(4)              :: DxDIR,DyDIR
  LOGICAL                 :: XYDIR=.FALSE.
  LOGICAL                 :: YZDIR=.FALSE.
  LOGICAL                 :: XZDIR=.FALSE.
  LOGICAL                 :: XYFDMISCHEME=.FALSE.
  LOGICAL                 :: YZFDMISCHEME=.FALSE.
  LOGICAL                 :: XZFDMISCHEME=.FALSE.
  LOGICAL                 :: XYPSMISCHEME=.FALSE.
  LOGICAL                 :: YZPSMISCHEME=.FALSE.
  LOGICAL                 :: XZPSMISCHEME=.FALSE.
  LOGICAL                 :: XYCSMISCHEME=.FALSE.
  LOGICAL                 :: YZCSMISCHEME=.FALSE.
  LOGICAL                 :: XZCSMISCHEME=.FALSE.

  fDIM=SHAPE(f)

  IF(fDIM(1).EQ.1) THEN
   DxDIR=2;DyDIR=3
  ELSE IF(fDIM(2).EQ.1) THEN
   DxDIR=1;DyDIR=3
  ELSE IF(fDIM(3).EQ.1) THEN
   DxDIR=1;DyDIR=2
  ELSE
   DxDIR=1
   DO ifDIM2=1,fDIM(2)
    IF(LX3D(1,ifDIM2,1).NE.LX3D(1,1,1)) THEN
     DxDIR=2
     EXIT
    END IF
   END DO
   DO ifDIM3=1,fDIM(3)
    IF(LX3D(1,1,ifDIM3).NE.LX3D(1,1,1)) THEN
     DxDIR=3
     EXIT
    END IF
   END DO
   DyDIR=1
   DO ifDIM2=1,fDIM(2)
    IF(LY3D(1,ifDIM2,1).NE.LY3D(1,1,1)) THEN
     DyDIR=2
     EXIT
    END IF
   END DO
   DO ifDIM3=1,fDIM(3)
    IF(LY3D(1,1,ifDIM3).NE.LY3D(1,1,1)) THEN
     DyDIR=3
     EXIT
    END IF
   END DO
  END IF

  IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, intLPLCf: NUMBER OF CURRENT SPACES ARE NOT ENOUGH!"
   STOP
  ELSE IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, intLPLCf: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, intLPLCf: NUMBER OF CURRENT SPACES ARE TOO MANY!"
   STOP
  END IF

  IF((CSPACE1.EQ."x".AND.CSPACE1.EQ."X").AND.(CSPACE2.EQ."y".AND.CSPACE2.EQ."Y")) THEN
   XYDIR=.TRUE.
  ELSE IF((CSPACE1.EQ."y".AND.CSPACE1.EQ."Y").AND.(CSPACE2.EQ."z".AND.CSPACE2.EQ."Z")) THEN
   YZDIR=.TRUE.
  ELSE IF((CSPACE1.EQ."x".AND.CSPACE1.EQ."X").AND.(CSPACE2.EQ."z".AND.CSPACE2.EQ."Z")) THEN
   XZDIR=.TRUE.
  END IF

  IF(XFDMISCHEME(fldID).AND.YFDMISCHEME(fldID)) THEN
   XYFDMISCHEME=.TRUE.
  ELSE IF(YFDMISCHEME(fldID).AND.ZFDMISCHEME(fldID)) THEN
   YZFDMISCHEME=.TRUE.
  ELSE IF(XFDMISCHEME(fldID).AND.ZFDMISCHEME(fldID)) THEN
   XZFDMISCHEME=.TRUE.
  ELSE IF(XPSMISCHEME(fldID).AND.YPSMISCHEME(fldID)) THEN
   XYPSMISCHEME=.TRUE.
  ELSE IF(YPSMISCHEME(fldID).AND.ZPSMISCHEME(fldID)) THEN
   YZPSMISCHEME=.TRUE.
  ELSE IF(XPSMISCHEME(fldID).AND.ZPSMISCHEME(fldID)) THEN
   XZPSMISCHEME=.TRUE.
  ELSE IF(XCSMISCHEME(fldID).AND.YCSMISCHEME(fldID)) THEN
   XYCSMISCHEME=.TRUE.
  ELSE IF(YCSMISCHEME(fldID).AND.ZCSMISCHEME(fldID)) THEN
   YZCSMISCHEME=.TRUE.
  ELSE IF(XCSMISCHEME(fldID).AND.ZCSMISCHEME(fldID)) THEN
   XZCSMISCHEME=.TRUE.
  END IF

  IF(PSMISCHEME(fldID).OR.((XYDIR.AND.XYPSMISCHEME).OR.(YZDIR.AND.YZPSMISCHEME).OR.(XZDIR.AND.XZPSMISCHEME))) THEN
   IF(PSMACCESSID) THEN
    IF( PSMISCHEME(fldID)) PRINT*, " PSMISCHEME("//CHAR(48+fldID)//")"
    IF(XPSMISCHEME(fldID)) PRINT*, "XPSMISCHEME("//CHAR(48+fldID)//")"
    IF(YPSMISCHEME(fldID)) PRINT*, "YPSMISCHEME("//CHAR(48+fldID)//")"
    IF(ZPSMISCHEME(fldID)) PRINT*, "ZPSMISCHEME("//CHAR(48+fldID)//")"
    PSMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(kf).EQV..FALSE.)     ALLOCATE(kf(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(likx).EQV..FALSE.)   ALLOCATE(likx(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(liky).EQV..FALSE.)   ALLOCATE(liky(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(llplc).EQV..FALSE.)  ALLOCATE(llplc(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(kLPLCf).EQV..FALSE.) ALLOCATE(kLPLCf(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   CALL KGRIDBUILDER(LX3D,likx)
   CALL KGRIDBUILDER(LY3D,liky)
   CALL FFTW(f,kf)
   CALL intLPLCf(kf,likx,liky,kLPLCf,1,fldID,CSPACE)
   CALL iFFTW(kLPLCf,lintLPLCf)
   XYPSMISCHEME=.FALSE.
   YZPSMISCHEME=.FALSE.
   XZPSMISCHEME=.FALSE.
  ELSE
   IF(DxDIR.EQ.1.AND.DyDIR.EQ.2) THEN
    DO ifDIM3=1,fDIM(3)
     CALL intLPLCf(f(:,:,ifDIM3),LX3D(:,:,ifDIM3),LY3D(:,:,ifDIM3),lintLPLCf(:,:,ifDIM3),fldID,CSPACE)
    END DO
   ELSE IF(DxDIR.EQ.1.AND.DyDIR.EQ.3) THEN
    DO ifDIM2=1,fDIM(2)
     CALL intLPLCf(f(:,ifDIM2,:),LX3D(:,ifDIM2,:),LY3D(:,ifDIM2,:),lintLPLCf(:,ifDIM2,:),fldID,CSPACE)
    END DO
   ELSE IF(DxDIR.EQ.2.AND.DyDIR.EQ.3) THEN
    DO ifDIM1=1,fDIM(1)
     CALL intLPLCf(f(ifDIM1,:,:),LX3D(ifDIM1,:,:),LY3D(ifDIM1,:,:),lintLPLCf(ifDIM1,:,:),fldID,CSPACE)
    END DO
   END IF
   XYFDMISCHEME=.FALSE.
   YZFDMISCHEME=.FALSE.
   XZFDMISCHEME=.FALSE.
  END IF

  XYDIR=.FALSE.
  YZDIR=.FALSE.
  XZDIR=.FALSE.
! XYCSMSCHEME=.FALSE.
! YZCSMSCHEME=.FALSE.
! XZCSMSCHEME=.FALSE.

  RETURN
 END SUBROUTINE r8r4r8intLPLCf3D

 SUBROUTINE r8r8r8intLPLCf3DNONE(f,LX3D,LY3D,lintLPLCf)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:)
  REAL(8), INTENT(OUT)             :: lintLPLCf(:,:,:)

  CALL intLPLCf(f,LX3D,LY3D,lintLPLCf,1,"xy")

  RETURN
 END SUBROUTINE r8r8r8intLPLCf3DNONE
  
 SUBROUTINE r8r8r8intLPLCf3D1INT(f,LX3D,LY3D,lintLPLCf,fldID)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:)
  REAL(8), INTENT(OUT)             :: lintLPLCf(:,:,:)
  INTEGER(4), INTENT(IN)           :: fldID
  
  CALL intLPLCf(f,LX3D,LY3D,lintLPLCf,fldID,"xy")

  RETURN
 END SUBROUTINE r8r8r8intLPLCf3D1INT

 SUBROUTINE r8r8r8intLPLCf3D1CHR(f,LX3D,LY3D,lintLPLCf,CSPACE)
  IMPLICIT NONE
  REAL(8), INTENT(IN)              :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)              :: f(:,:,:)
  REAL(8), INTENT(OUT)             :: lintLPLCf(:,:,:)
  CHARACTER(LEN=*), INTENT(IN)     :: CSPACE

  CALL intLPLCf(f,LX3D,LY3D,lintLPLCf,1,CSPACE)

  RETURN
 END SUBROUTINE r8r8r8intLPLCf3D1CHR

 SUBROUTINE r8r8r8intLPLCf3D(f,LX3D,LY3D,lintLPLCf,fldID,CSPACE)
  IMPLICIT NONE
  REAL(8), INTENT(IN)     :: LX3D(:,:,:),LY3D(:,:,:)
  REAL(8), INTENT(IN)     :: f(:,:,:)
  REAL(8), INTENT(OUT)    :: lintLPLCf(:,:,:)
  REAL(8), ALLOCATABLE    :: tf(:,:,:)
  REAL(8), ALLOCATABLE    :: llplc(:,:,:)
  COMPLEX(8), ALLOCATABLE :: likx(:,:,:),liky(:,:,:)
  COMPLEX(8), ALLOCATABLE :: kf(:,:,:),kLPLCf(:,:,:)
  INTEGER(4)              :: fDIM(3),ifDIM1,ifDIM2,ifDIM3
  INTEGER(4), INTENT(IN)  :: fldID
  CHARACTER(LEN=*), INTENT(IN) :: CSPACE
  CHARACTER(LEN=1)             :: CSPACE1,CSPACE2
  LOGICAL,    SAVE                 :: FDMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: PSMACCESSID=.TRUE.
  LOGICAL,    SAVE                 :: CSMACCESSID=.TRUE.
  INTEGER(4)              :: DxDIR,DyDIR
  LOGICAL                 :: XYDIR=.FALSE.
  LOGICAL                 :: YZDIR=.FALSE.
  LOGICAL                 :: XZDIR=.FALSE.
  LOGICAL                 :: XYFDMISCHEME=.FALSE.
  LOGICAL                 :: YZFDMISCHEME=.FALSE.
  LOGICAL                 :: XZFDMISCHEME=.FALSE.
  LOGICAL                 :: XYPSMISCHEME=.FALSE.
  LOGICAL                 :: YZPSMISCHEME=.FALSE.
  LOGICAL                 :: XZPSMISCHEME=.FALSE.
  LOGICAL                 :: XYCSMISCHEME=.FALSE.
  LOGICAL                 :: YZCSMISCHEME=.FALSE.
  LOGICAL                 :: XZCSMISCHEME=.FALSE.

  fDIM=SHAPE(f)

  IF(fDIM(1).EQ.1) THEN
   DxDIR=2;DyDIR=3
  ELSE IF(fDIM(2).EQ.1) THEN
   DxDIR=1;DyDIR=3
  ELSE IF(fDIM(3).EQ.1) THEN
   DxDIR=1;DyDIR=2
  ELSE
   DxDIR=1
   DO ifDIM2=1,fDIM(2)
    IF(LX3D(1,ifDIM2,1).NE.LX3D(1,1,1)) THEN
     DxDIR=2
     EXIT
    END IF
   END DO
   DO ifDIM3=1,fDIM(3)
    IF(LX3D(1,1,ifDIM3).NE.LX3D(1,1,1)) THEN
     DxDIR=3
     EXIT
    END IF
   END DO
   DyDIR=1
   DO ifDIM2=1,fDIM(2)
    IF(LY3D(1,ifDIM2,1).NE.LY3D(1,1,1)) THEN
     DyDIR=2
     EXIT
    END IF
   END DO
   DO ifDIM3=1,fDIM(3)
    IF(LY3D(1,1,ifDIM3).NE.LY3D(1,1,1)) THEN
     DyDIR=3
     EXIT
    END IF
   END DO
  END IF

  IF(LEN(CSPACE).LT.2) THEN
   PRINT*, "ERROR, intLPLCf: NUMBER OF CURRENT SPACES ARE NOT ENOUGH!"
   STOP
  ELSE IF(LEN(CSPACE).EQ.2) THEN
   CSPACE1=CSPACE(1:1)
   CSPACE2=CSPACE(2:2)
   IF(CSPACE1.EQ.CSPACE2) THEN
    PRINT*, "ERROR, intLPLCf: (CSPACE1 = CSPACE2) IS NOT ALLOWED"
    STOP
   END IF
  ELSE IF(LEN(CSPACE).GT.2) THEN
   PRINT*, "ERROR, intLPLCf: NUMBER OF CURRENT SPACES ARE TOO MANY!"
   STOP
  END IF

  IF((CSPACE1.EQ."x".AND.CSPACE1.EQ."X").AND.(CSPACE2.EQ."y".AND.CSPACE2.EQ."Y")) THEN
   XYDIR=.TRUE.
  ELSE IF((CSPACE1.EQ."y".AND.CSPACE1.EQ."Y").AND.(CSPACE2.EQ."z".AND.CSPACE2.EQ."Z")) THEN
   YZDIR=.TRUE.
  ELSE IF((CSPACE1.EQ."x".AND.CSPACE1.EQ."X").AND.(CSPACE2.EQ."z".AND.CSPACE2.EQ."Z")) THEN
   XZDIR=.TRUE.
  END IF

  IF(XFDMISCHEME(fldID).AND.YFDMISCHEME(fldID)) THEN
   XYFDMISCHEME=.TRUE.
  ELSE IF(YFDMISCHEME(fldID).AND.ZFDMISCHEME(fldID)) THEN
   YZFDMISCHEME=.TRUE.
  ELSE IF(XFDMISCHEME(fldID).AND.ZFDMISCHEME(fldID)) THEN
   XZFDMISCHEME=.TRUE.
  ELSE IF(XPSMISCHEME(fldID).AND.YPSMISCHEME(fldID)) THEN
   XYPSMISCHEME=.TRUE.
  ELSE IF(YPSMISCHEME(fldID).AND.ZPSMISCHEME(fldID)) THEN
   YZPSMISCHEME=.TRUE.
  ELSE IF(XPSMISCHEME(fldID).AND.ZPSMISCHEME(fldID)) THEN
   XZPSMISCHEME=.TRUE.
  ELSE IF(XCSMISCHEME(fldID).AND.YCSMISCHEME(fldID)) THEN
   XYCSMISCHEME=.TRUE.
  ELSE IF(YCSMISCHEME(fldID).AND.ZCSMISCHEME(fldID)) THEN
   YZCSMISCHEME=.TRUE.
  ELSE IF(XCSMISCHEME(fldID).AND.ZCSMISCHEME(fldID)) THEN
   XZCSMISCHEME=.TRUE.
  END IF

  IF(PSMISCHEME(fldID).OR.((XYDIR.AND.XYPSMISCHEME).OR.(YZDIR.AND.YZPSMISCHEME).OR.(XZDIR.AND.XZPSMISCHEME))) THEN
   IF(PSMACCESSID) THEN
    IF( PSMISCHEME(fldID)) PRINT*, " PSMISCHEME("//CHAR(48+fldID)//")"
    IF(XPSMISCHEME(fldID)) PRINT*, "XPSMISCHEME("//CHAR(48+fldID)//")"
    IF(YPSMISCHEME(fldID)) PRINT*, "YPSMISCHEME("//CHAR(48+fldID)//")"
    IF(ZPSMISCHEME(fldID)) PRINT*, "ZPSMISCHEME("//CHAR(48+fldID)//")"
    PSMACCESSID=.FALSE.
   END IF
   IF(ALLOCATED(kf).EQV..FALSE.)     ALLOCATE(kf(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(likx).EQV..FALSE.)   ALLOCATE(likx(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(liky).EQV..FALSE.)   ALLOCATE(liky(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(llplc).EQV..FALSE.)  ALLOCATE(llplc(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   IF(ALLOCATED(kLPLCf).EQV..FALSE.) ALLOCATE(kLPLCf(fDIM(1)/2+1,fDIM(2),fDIM(3)))
   CALL KGRIDBUILDER(LX3D,likx)
   CALL KGRIDBUILDER(LY3D,liky)
   CALL FFTW(f,kf)
   CALL intLPLCf(kf,likx,liky,kLPLCf,1,fldID,CSPACE)
   CALL iFFTW(kLPLCf,lintLPLCf)
   XYPSMISCHEME=.FALSE.
   YZPSMISCHEME=.FALSE.
   XZPSMISCHEME=.FALSE.
  ELSE
   IF(DxDIR.EQ.1.AND.DyDIR.EQ.2) THEN
    DO ifDIM3=1,fDIM(3)
     CALL intLPLCf(f(:,:,ifDIM3),LX3D(:,:,ifDIM3),LY3D(:,:,ifDIM3),lintLPLCf(:,:,ifDIM3),fldID,CSPACE)
    END DO
   ELSE IF(DxDIR.EQ.1.AND.DyDIR.EQ.3) THEN
    DO ifDIM2=1,fDIM(2)
     CALL intLPLCf(f(:,ifDIM2,:),LX3D(:,ifDIM2,:),LY3D(:,ifDIM2,:),lintLPLCf(:,ifDIM2,:),fldID,CSPACE)
    END DO
   ELSE IF(DxDIR.EQ.2.AND.DyDIR.EQ.3) THEN
    DO ifDIM1=1,fDIM(1)
     CALL intLPLCf(f(ifDIM1,:,:),LX3D(ifDIM1,:,:),LY3D(ifDIM1,:,:),lintLPLCf(ifDIM1,:,:),fldID,CSPACE)
    END DO
   END IF
   XYFDMISCHEME=.FALSE.
   YZFDMISCHEME=.FALSE.
   XZFDMISCHEME=.FALSE.
  END IF

  XYDIR=.FALSE.
  YZDIR=.FALSE.
  XZDIR=.FALSE.
! XYCSMSCHEME=.FALSE.
! YZCSMSCHEME=.FALSE.
! XZCSMSCHEME=.FALSE.

  RETURN
 END SUBROUTINE r8r8r8intLPLCf3D




!**********************************************************************
!********************** FOURIER TRANSFORMATIONS ***********************
!**********************************************************************
 SUBROUTINE PSFFTWSET(DIM1,DIM2,DIM3)
  USE OMP_LIB
  IMPLICIT NONE
  include "fftw3.f"
  INTEGER(4), INTENT(IN)           :: DIM1
  INTEGER(4), INTENT(IN), OPTIONAL :: DIM2, DIM3
  INTEGER(4)                       :: FERROR
  INTEGER(4)                       :: reDIM1,reDIM2,reDIM3
  INTEGER(4)                       :: keDIM1,keDIM2,keDIM3

  CALL DFFTW_INIT_THREADS(FERROR)
  IF(FERROR.EQ.0) CALL DFFTW_PLAN_WITH_NTHREADS(omp_get_max_threads()/2)
 
  rPSfDIM1=DIM1
  kPSfDIM1=rPSfDIM1/2+1

  rePSfDIM1=rPSfDIM1+(rPSfDIM1-1)/3
  kePSfDIM1=kPSfDIM1+(kPSfDIM1-1)/3

  IF(PRESENT(DIM2)) THEN
   rPSfDIM2=DIM2
   kPSfDIM2=rPSfDIM2

   rePSfDIM2=rPSfDIM2+(rPSfDIM2-1)/3
   kePSfDIM2=kPSfDIM2+(kPSfDIM2-1)/3
  END IF

  IF(PRESENT(DIM3)) THEN
   rPSfDIM3=DIM3
   kPSfDIM3=rPSfDIM3

   rePSfDIM3=rPSfDIM3+(rPSfDIM3-1)/3
   kePSfDIM3=kPSfDIM3+(kPSfDIM3-1)/3
  END IF

  IF(PRESENT(DIM3)) THEN
!**************** NORMAL ARRAYS ********************
   CALL DFFTW_DESTROY_PLAN( PSFFTWPLAN3D)
   CALL DFFTW_DESTROY_PLAN(iPSFFTWPLAN3D)
   IF(ALLOCATED(rPSFFTWfn3D).EQV..TRUE.) THEN
    DEALLOCATE(rPSFFTWfn3D)
    ALLOCATE(rPSFFTWfn3D(rPSfDIM1,rPSfDIM2,rPSfDIM3))
   ELSE
    ALLOCATE(rPSFFTWfn3D(rPSfDIM1,rPSfDIM2,rPSfDIM3))
   END IF
   IF(ALLOCATED(kPSFFTWfn3D).EQV..TRUE.) THEN
    DEALLOCATE(kPSFFTWfn3D)
    ALLOCATE(kPSFFTWfn3D(kPSfDIM1,kPSfDIM2,kPSfDIM3))
   ELSE
    ALLOCATE(kPSFFTWfn3D(kPSfDIM1,kPSfDIM2,kPSfDIM3))
   END IF
   CALL DFFTW_PLAN_DFT_R2C_3D( PSFFTWPLAN3D,rPSfDIM1,rPSfDIM2,rPSfDIM3,rPSFFTWfn3D,kPSFFTWfn3D,FFTW_ESTIMATE,FFTW_UNALIGNED)
   CALL DFFTW_PLAN_DFT_C2R_3D(iPSFFTWPLAN3D,rPSfDIM1,rPSfDIM2,rPSfDIM3,kPSFFTWfn3D,rPSFFTWfn3D,FFTW_ESTIMATE,FFTW_UNALIGNED)
!**************** EXTENDED ARRAYS ********************
   CALL DFFTW_DESTROY_PLAN( ePSFFTWPLAN3D)
   CALL DFFTW_DESTROY_PLAN(iePSFFTWPLAN3D)
   IF(ALLOCATED(rePSFFTWfn3D).EQV..TRUE.) THEN
    DEALLOCATE(rePSFFTWfn3D)
    ALLOCATE(rePSFFTWfn3D(rePSfDIM1,rePSfDIM2,rePSfDIM3))
   ELSE
    ALLOCATE(rePSFFTWfn3D(rePSfDIM1,rePSfDIM2,rePSfDIM3))
   END IF
   IF(ALLOCATED(kePSFFTWfn3D).EQV..TRUE.) THEN
    DEALLOCATE(kePSFFTWfn3D)
    ALLOCATE(kePSFFTWfn3D(kePSfDIM1,kePSfDIM2,kePSfDIM3))
   ELSE
    ALLOCATE(kePSFFTWfn3D(kePSfDIM1,kePSfDIM2,kePSfDIM3))
   END IF
   CALL DFFTW_PLAN_DFT_R2C_3D( ePSFFTWPLAN3D,rePSfDIM1,rePSfDIM2,rePSfDIM3,rePSFFTWfn3D,kePSFFTWfn3D,FFTW_ESTIMATE,FFTW_UNALIGNED)
   CALL DFFTW_PLAN_DFT_C2R_3D(iePSFFTWPLAN3D,rePSfDIM1,rePSfDIM2,rePSfDIM3,kePSFFTWfn3D,rePSFFTWfn3D,FFTW_ESTIMATE,FFTW_UNALIGNED)
  ELSE IF(PRESENT(DIM2)) THEN
!**************** NORMAL ARRAYS ********************
   CALL DFFTW_DESTROY_PLAN( PSFFTWPLAN2D)
   CALL DFFTW_DESTROY_PLAN(iPSFFTWPLAN2D)
   IF(ALLOCATED(rPSFFTWfn2D).EQV..TRUE.) THEN
    DEALLOCATE(rPSFFTWfn2D)
    ALLOCATE(rPSFFTWfn2D(rPSfDIM1,rPSfDIM2))
   ELSE
    ALLOCATE(rPSFFTWfn2D(rPSfDIM1,rPSfDIM2))
   END IF
   IF(ALLOCATED(kPSFFTWfn2D).EQV..TRUE.) THEN
    DEALLOCATE(kPSFFTWfn2D)
    ALLOCATE(kPSFFTWfn2D(kPSfDIM1,kPSfDIM2))
   ELSE
    ALLOCATE(kPSFFTWfn2D(kPSfDIM1,kPSfDIM2))
   END IF
   CALL DFFTW_PLAN_DFT_R2C_2D( PSFFTWPLAN2D,rPSfDIM1,rPSfDIM2,rPSFFTWfn2D,kPSFFTWfn2D,FFTW_ESTIMATE,FFTW_UNALIGNED)
   CALL DFFTW_PLAN_DFT_C2R_2D(iPSFFTWPLAN2D,rPSfDIM1,rPSfDIM2,kPSFFTWfn2D,rPSFFTWfn2D,FFTW_ESTIMATE,FFTW_UNALIGNED)
!**************** EXTENDED ARRAYS ********************
   CALL DFFTW_DESTROY_PLAN( ePSFFTWPLAN2D)
   CALL DFFTW_DESTROY_PLAN(iePSFFTWPLAN2D)
   IF(ALLOCATED(rePSFFTWfn2D).EQV..TRUE.) THEN
    DEALLOCATE(rePSFFTWfn2D)
    ALLOCATE(rePSFFTWfn2D(rePSfDIM1,rePSfDIM2))
   ELSE
    ALLOCATE(rePSFFTWfn2D(rePSfDIM1,rePSfDIM2))
   END IF
   IF(ALLOCATED(kePSFFTWfn2D).EQV..TRUE.) THEN
    DEALLOCATE(kePSFFTWfn2D)
    ALLOCATE(kePSFFTWfn2D(kePSfDIM1,kePSfDIM2))
   ELSE
    ALLOCATE(kePSFFTWfn2D(kePSfDIM1,kePSfDIM2))
   END IF
   CALL DFFTW_PLAN_DFT_R2C_2D( ePSFFTWPLAN2D,rePSfDIM1,rePSfDIM2,rePSFFTWfn2D,kePSFFTWfn2D,FFTW_ESTIMATE,FFTW_UNALIGNED)
   CALL DFFTW_PLAN_DFT_C2R_2D(iePSFFTWPLAN2D,rePSfDIM1,rePSfDIM2,kePSFFTWfn2D,rePSFFTWfn2D,FFTW_ESTIMATE,FFTW_UNALIGNED)
  ELSE
!**************** NORMAL ARRAYS ********************
   CALL DFFTW_DESTROY_PLAN( PSFFTWPLAN1D)
   CALL DFFTW_DESTROY_PLAN(iPSFFTWPLAN1D)
   IF(ALLOCATED(rPSFFTWfn1D).EQV..TRUE.) THEN
    DEALLOCATE(rPSFFTWfn1D)
    ALLOCATE(rPSFFTWfn1D(rPSfDIM1))
   ELSE
    ALLOCATE(rPSFFTWfn1D(rPSfDIM1))
   END IF
   IF(ALLOCATED(kPSFFTWfn1D).EQV..TRUE.) THEN
    DEALLOCATE(kPSFFTWfn1D)
    ALLOCATE(kPSFFTWfn1D(kPSfDIM1))
   ELSE
    ALLOCATE(kPSFFTWfn1D(kPSfDIM1))
   END IF
   CALL DFFTW_PLAN_DFT_R2C_1D( PSFFTWPLAN1D,rPSfDIM1,rPSFFTWfn1D,kPSFFTWfn1D,FFTW_ESTIMATE,FFTW_UNALIGNED)
   CALL DFFTW_PLAN_DFT_C2R_1D(iPSFFTWPLAN1D,rPSfDIM1,kPSFFTWfn1D,rPSFFTWfn1D,FFTW_ESTIMATE,FFTW_UNALIGNED)
!**************** EXTENDED ARRAYS ********************
   CALL DFFTW_DESTROY_PLAN( ePSFFTWPLAN1D)
   CALL DFFTW_DESTROY_PLAN(iePSFFTWPLAN1D)
   IF(ALLOCATED(rePSFFTWfn1D).EQV..TRUE.) THEN
    DEALLOCATE(rePSFFTWfn1D)
    ALLOCATE(rePSFFTWfn1D(rePSfDIM1))
   ELSE
    ALLOCATE(rePSFFTWfn1D(rePSfDIM1))
   END IF
   IF(ALLOCATED(kePSFFTWfn1D).EQV..TRUE.) THEN
    DEALLOCATE(kePSFFTWfn1D)
    ALLOCATE(kePSFFTWfn1D(kePSfDIM1))
   ELSE
    ALLOCATE(kePSFFTWfn1D(kePSfDIM1))
   END IF
   CALL DFFTW_PLAN_DFT_R2C_1D( ePSFFTWPLAN1D,rePSfDIM1,rePSFFTWfn1D,kePSFFTWfn1D,FFTW_ESTIMATE,FFTW_UNALIGNED)
   CALL DFFTW_PLAN_DFT_C2R_1D(iePSFFTWPLAN1D,rePSfDIM1,kePSFFTWfn1D,rePSFFTWfn1D,FFTW_ESTIMATE,FFTW_UNALIGNED)
  END IF

  RETURN
 END SUBROUTINE PSFFTWSET

 SUBROUTINE CSFFTWSET(DIM1,DIM2,DIM3)
  USE OMP_LIB
  IMPLICIT NONE
  include "fftw3.f"
  INTEGER(4), INTENT(IN)           :: DIM1
  INTEGER(4), INTENT(IN), OPTIONAL :: DIM2, DIM3
  INTEGER(4)                       :: FERROR
  INTEGER(4)                       :: rDIM1,rDIM2,rDIM3
  INTEGER(4)                       :: kDIM1,kDIM2,kDIM3
  INTEGER(4)                       :: reDIM1,reDIM2,reDIM3
  INTEGER(4)                       :: keDIM1,keDIM2,keDIM3

  CALL DFFTW_INIT_THREADS(FERROR)
  IF(FERROR.EQ.0) CALL DFFTW_PLAN_WITH_NTHREADS(omp_get_max_threads()/2)
 
  rCSfDIM1=2*(DIM1-1)
  kCSfDIM1=rCSfDIM1/2+1

  reCSfDIM1=rCSfDIM1+(rCSfDIM1-1)/3
  keCSfDIM1=kCSfDIM1+(kCSfDIM1-1)/3

  IF(PRESENT(DIM2)) THEN
   rCSfDIM2=2*(DIM2-1)
   kCSfDIM2=rCSfDIM2

   reCSfDIM2=rCSfDIM2+(rCSfDIM2-1)/3
   keCSfDIM2=kCSfDIM2+(kCSfDIM2-1)/3
  END IF

  IF(PRESENT(DIM3)) THEN
   rCSfDIM3=2*(DIM3-1)
   kCSfDIM3=rCSfDIM3

   reCSfDIM3=rCSfDIM3+(rCSfDIM3-1)/3
   keCSfDIM3=kCSfDIM3+(kCSfDIM3-1)/3
  END IF


  IF(PRESENT(DIM3)) THEN
!**************** NORMAL ARRAYS ********************
   CALL DFFTW_DESTROY_PLAN( CSFFTWPLAN3D)
   CALL DFFTW_DESTROY_PLAN(iCSFFTWPLAN3D)
   IF(ALLOCATED(rCSFFTWfn3D).EQV..TRUE.) THEN
    DEALLOCATE(rCSFFTWfn3D)
    ALLOCATE(rCSFFTWfn3D(rCSfDIM1,rCSfDIM2,rCSfDIM3))
   ELSE
    ALLOCATE(rCSFFTWfn3D(rCSfDIM1,rCSfDIM2,rCSfDIM3))
   END IF
   IF(ALLOCATED(kCSFFTWfn3D).EQV..TRUE.) THEN
    DEALLOCATE(kCSFFTWfn3D)
    ALLOCATE(kCSFFTWfn3D(kCSfDIM1,kCSfDIM2,kCSfDIM3))
   ELSE
    ALLOCATE(kCSFFTWfn3D(kCSfDIM1,kCSfDIM2,kCSfDIM3))
   END IF
   CALL DFFTW_PLAN_DFT_R2C_3D( CSFFTWPLAN3D,rCSfDIM1,rCSfDIM2,rCSfDIM3,rCSFFTWfn3D,kCSFFTWfn3D,FFTW_ESTIMATE,FFTW_UNALIGNED)
   CALL DFFTW_PLAN_DFT_C2R_3D(iCSFFTWPLAN3D,rCSfDIM1,rCSfDIM2,rCSfDIM3,kCSFFTWfn3D,rCSFFTWfn3D,FFTW_ESTIMATE,FFTW_UNALIGNED)
!**************** EXTENDED ARRAYS ********************
   CALL DFFTW_DESTROY_PLAN( eCSFFTWPLAN3D)
   CALL DFFTW_DESTROY_PLAN(ieCSFFTWPLAN3D)
   IF(ALLOCATED(reCSFFTWfn3D).EQV..TRUE.) THEN
    DEALLOCATE(reCSFFTWfn3D)
    ALLOCATE(reCSFFTWfn3D(reCSfDIM1,reCSfDIM2,reCSfDIM3))
   ELSE
    ALLOCATE(reCSFFTWfn3D(reCSfDIM1,reCSfDIM2,reCSfDIM3))
   END IF
   IF(ALLOCATED(keCSFFTWfn3D).EQV..TRUE.) THEN
    DEALLOCATE(keCSFFTWfn3D)
    ALLOCATE(keCSFFTWfn3D(keCSfDIM1,keCSfDIM2,keCSfDIM3))
   ELSE
    ALLOCATE(keCSFFTWfn3D(keCSfDIM1,keCSfDIM2,keCSfDIM3))
   END IF
   CALL DFFTW_PLAN_DFT_R2C_3D( eCSFFTWPLAN3D,reCSfDIM1,reCSfDIM2,reCSfDIM3,reCSFFTWfn3D,keCSFFTWfn3D,FFTW_ESTIMATE,FFTW_UNALIGNED)
   CALL DFFTW_PLAN_DFT_C2R_3D(ieCSFFTWPLAN3D,reCSfDIM1,reCSfDIM2,reCSfDIM3,keCSFFTWfn3D,reCSFFTWfn3D,FFTW_ESTIMATE,FFTW_UNALIGNED)
  ELSE IF(PRESENT(DIM2)) THEN
!**************** NORMAL ARRAYS ********************
   CALL DFFTW_DESTROY_PLAN( CSFFTWPLAN2D)
   CALL DFFTW_DESTROY_PLAN(iCSFFTWPLAN2D)
   IF(ALLOCATED(rCSFFTWfn2D).EQV..TRUE.) THEN
    DEALLOCATE(rCSFFTWfn2D)
    ALLOCATE(rCSFFTWfn2D(rCSfDIM1,rCSfDIM2))
   ELSE
    ALLOCATE(rCSFFTWfn2D(rCSfDIM1,rCSfDIM2))
   END IF
   IF(ALLOCATED(kCSFFTWfn2D).EQV..TRUE.) THEN
    DEALLOCATE(kCSFFTWfn2D)
    ALLOCATE(kCSFFTWfn2D(kCSfDIM1,kCSfDIM2))
   ELSE
    ALLOCATE(kCSFFTWfn2D(kCSfDIM1,kCSfDIM2))
   END IF
   CALL DFFTW_PLAN_DFT_R2C_2D( CSFFTWPLAN2D,rCSfDIM1,rCSfDIM2,rCSFFTWfn2D,kCSFFTWfn2D,FFTW_ESTIMATE,FFTW_UNALIGNED)
   CALL DFFTW_PLAN_DFT_C2R_2D(iCSFFTWPLAN2D,rCSfDIM1,rCSfDIM2,kCSFFTWfn2D,rCSFFTWfn2D,FFTW_ESTIMATE,FFTW_UNALIGNED)
!**************** EXTENDED ARRAYS ********************
   CALL DFFTW_DESTROY_PLAN( eCSFFTWPLAN2D)
   CALL DFFTW_DESTROY_PLAN(ieCSFFTWPLAN2D)
   IF(ALLOCATED(reCSFFTWfn2D).EQV..TRUE.) THEN
    DEALLOCATE(reCSFFTWfn2D)
    ALLOCATE(reCSFFTWfn2D(reCSfDIM1,reCSfDIM2))
   ELSE
    ALLOCATE(reCSFFTWfn2D(reCSfDIM1,reCSfDIM2))
   END IF
   IF(ALLOCATED(keCSFFTWfn2D).EQV..TRUE.) THEN
    DEALLOCATE(keCSFFTWfn2D)
    ALLOCATE(keCSFFTWfn2D(keCSfDIM1,keCSfDIM2))
   ELSE
    ALLOCATE(keCSFFTWfn2D(keCSfDIM1,keCSfDIM2))
   END IF
   CALL DFFTW_PLAN_DFT_R2C_2D( eCSFFTWPLAN2D,reCSfDIM1,reCSfDIM2,reCSFFTWfn2D,keCSFFTWfn2D,FFTW_ESTIMATE,FFTW_UNALIGNED)
   CALL DFFTW_PLAN_DFT_C2R_2D(ieCSFFTWPLAN2D,reCSfDIM1,reCSfDIM2,keCSFFTWfn2D,reCSFFTWfn2D,FFTW_ESTIMATE,FFTW_UNALIGNED)
  ELSE
!**************** NORMAL ARRAYS ********************
   CALL DFFTW_DESTROY_PLAN( CSFFTWPLAN1D)
   CALL DFFTW_DESTROY_PLAN(iCSFFTWPLAN1D)
   IF(ALLOCATED(rCSFFTWfn1D).EQV..TRUE.) THEN
    DEALLOCATE(rCSFFTWfn1D)
    ALLOCATE(rCSFFTWfn1D(rCSfDIM1))
   ELSE
    ALLOCATE(rCSFFTWfn1D(rCSfDIM1))
   END IF
   IF(ALLOCATED(kCSFFTWfn1D).EQV..TRUE.) THEN
    DEALLOCATE(kCSFFTWfn1D)
    ALLOCATE(kCSFFTWfn1D(kCSfDIM1))
   ELSE
    ALLOCATE(kCSFFTWfn1D(kCSfDIM1))
   END IF
   CALL DFFTW_PLAN_DFT_R2C_1D( CSFFTWPLAN1D,rCSfDIM1,rCSFFTWfn1D,kCSFFTWfn1D,FFTW_ESTIMATE,FFTW_UNALIGNED)
   CALL DFFTW_PLAN_DFT_C2R_1D(iCSFFTWPLAN1D,rCSfDIM1,kCSFFTWfn1D,rCSFFTWfn1D,FFTW_ESTIMATE,FFTW_UNALIGNED)
!**************** EXTENDED ARRAYS ********************
   CALL DFFTW_DESTROY_PLAN( eCSFFTWPLAN1D)
   CALL DFFTW_DESTROY_PLAN(ieCSFFTWPLAN1D)
   IF(ALLOCATED(reCSFFTWfn1D).EQV..TRUE.) THEN
    DEALLOCATE(reCSFFTWfn1D)
    ALLOCATE(reCSFFTWfn1D(reCSfDIM1))
   ELSE
    ALLOCATE(reCSFFTWfn1D(reCSfDIM1))
   END IF
   IF(ALLOCATED(keCSFFTWfn1D).EQV..TRUE.) THEN
    DEALLOCATE(keCSFFTWfn1D)
    ALLOCATE(keCSFFTWfn1D(keCSfDIM1))
   ELSE
    ALLOCATE(keCSFFTWfn1D(keCSfDIM1))
   END IF
   CALL DFFTW_PLAN_DFT_R2C_1D( eCSFFTWPLAN1D,reCSfDIM1,reCSFFTWfn1D,keCSFFTWfn1D,FFTW_ESTIMATE,FFTW_UNALIGNED)
   CALL DFFTW_PLAN_DFT_C2R_1D(ieCSFFTWPLAN1D,reCSfDIM1,keCSFFTWfn1D,reCSFFTWfn1D,FFTW_ESTIMATE,FFTW_UNALIGNED)
  END IF

  RETURN
 END SUBROUTINE CSFFTWSET



 SUBROUTINE r8c8FFTW1D(Rfn,Kfn)
  IMPLICIT NONE
  include "fftw3.f"
  REAL(8),    INTENT(IN)              :: Rfn(:)
  COMPLEX(8), INTENT(OUT)             :: Kfn(:)
  INTEGER(4)                          :: RfnMATDIMS

  RfnMATDIMS=SIZE(Rfn)

  IF(RfnMATDIMS.EQ.rPSfDIM1.OR.RfnMATDIMS.EQ.rePSfDIM1) THEN
   IF(RfnMATDIMS.EQ.rPSfDIM1) THEN
    rPSFFTWfn1D=1.0d0*Rfn
    CALL DFFTW_EXECUTE_DFT_R2C(PSFFTWPLAN1D,rPSFFTWfn1D,kPSFFTWfn1D)
    Kfn=kPSFFTWfn1D
   ELSE IF(RfnMATDIMS.EQ.rePSfDIM1) THEN
    rePSFFTWfn1D=1.0d0*Rfn
    CALL DFFTW_EXECUTE_DFT_R2C(ePSFFTWPLAN1D,rePSFFTWfn1D,kePSFFTWfn1D)
    Kfn=kePSFFTWfn1D
   END IF
  ELSE IF(RfnMATDIMS.EQ.rCSfDIM1.OR.RfnMATDIMS.EQ.reCSfDIM1) THEN
   IF(RfnMATDIMS.EQ.rCSfDIM1) THEN
    rCSFFTWfn1D=1.0d0*Rfn
    CALL DFFTW_EXECUTE_DFT_R2C(CSFFTWPLAN1D,rCSFFTWfn1D,kCSFFTWfn1D)
    Kfn=kCSFFTWfn1D
   ELSE IF(RfnMATDIMS.EQ.reCSfDIM1) THEN
    reCSFFTWfn1D=1.0d0*Rfn
    CALL DFFTW_EXECUTE_DFT_R2C(eCSFFTWPLAN1D,reCSFFTWfn1D,keCSFFTWfn1D)
    Kfn=keCSFFTWfn1D
   END IF
  ELSE
   CALL PSFFTWSET(RfnMATDIMS)
   CALL CSFFTWSET(RfnMATDIMS)
   IF(RfnMATDIMS.EQ.rPSfDIM1.OR.RfnMATDIMS.EQ.rePSfDIM1) THEN
    IF(RfnMATDIMS.EQ.rPSfDIM1) THEN
     rPSFFTWfn1D=1.0d0*Rfn
     CALL DFFTW_EXECUTE_DFT_R2C(PSFFTWPLAN1D,rPSFFTWfn1D,kPSFFTWfn1D)
     Kfn=kPSFFTWfn1D
    ELSE IF(RfnMATDIMS.EQ.rePSfDIM1) THEN
     rePSFFTWfn1D=1.0d0*Rfn
     CALL DFFTW_EXECUTE_DFT_R2C(ePSFFTWPLAN1D,rePSFFTWfn1D,kePSFFTWfn1D)
     Kfn=kePSFFTWfn1D
    END IF
   ELSE IF(RfnMATDIMS.EQ.rCSfDIM1.OR.RfnMATDIMS.EQ.reCSfDIM1) THEN
    IF(RfnMATDIMS.EQ.rCSfDIM1) THEN
     rCSFFTWfn1D=1.0d0*Rfn
     CALL DFFTW_EXECUTE_DFT_R2C(CSFFTWPLAN1D,rCSFFTWfn1D,kCSFFTWfn1D)
     Kfn=kCSFFTWfn1D
    ELSE IF(RfnMATDIMS.EQ.reCSfDIM1) THEN
     reCSFFTWfn1D=1.0d0*Rfn
     CALL DFFTW_EXECUTE_DFT_R2C(eCSFFTWPLAN1D,reCSFFTWfn1D,keCSFFTWfn1D)
     Kfn=keCSFFTWfn1D
    END IF
   END IF
  END IF

  RETURN
 END SUBROUTINE r8c8FFTW1D

 SUBROUTINE r4c8FFTW1D(Rfn,Kfn)
  IMPLICIT NONE
  include "fftw3.f"
  REAL(4),    INTENT(IN)              :: Rfn(:)
  COMPLEX(8), INTENT(OUT)             :: Kfn(:)
  INTEGER(4)                          :: RfnMATDIMS

  RfnMATDIMS=SIZE(Rfn)

  IF(RfnMATDIMS.EQ.rPSfDIM1.OR.RfnMATDIMS.EQ.rePSfDIM1) THEN
   IF(RfnMATDIMS.EQ.rPSfDIM1) THEN
    rPSFFTWfn1D=1.0d0*Rfn
    CALL DFFTW_EXECUTE_DFT_R2C(PSFFTWPLAN1D,rPSFFTWfn1D,kPSFFTWfn1D)
    Kfn=kPSFFTWfn1D
   ELSE IF(RfnMATDIMS.EQ.rePSfDIM1) THEN
    rePSFFTWfn1D=1.0d0*Rfn
    CALL DFFTW_EXECUTE_DFT_R2C(ePSFFTWPLAN1D,rePSFFTWfn1D,kePSFFTWfn1D)
    Kfn=kePSFFTWfn1D
   END IF
  ELSE IF(RfnMATDIMS.EQ.rCSfDIM1.OR.RfnMATDIMS.EQ.reCSfDIM1) THEN
   IF(RfnMATDIMS.EQ.rCSfDIM1) THEN
    rCSFFTWfn1D=1.0d0*Rfn
    CALL DFFTW_EXECUTE_DFT_R2C(CSFFTWPLAN1D,rCSFFTWfn1D,kCSFFTWfn1D)
    Kfn=kCSFFTWfn1D
   ELSE IF(RfnMATDIMS.EQ.reCSfDIM1) THEN
    reCSFFTWfn1D=1.0d0*Rfn
    CALL DFFTW_EXECUTE_DFT_R2C(eCSFFTWPLAN1D,reCSFFTWfn1D,keCSFFTWfn1D)
    Kfn=keCSFFTWfn1D
   END IF
  ELSE
   CALL PSFFTWSET(RfnMATDIMS)
   CALL CSFFTWSET(RfnMATDIMS)
   IF(RfnMATDIMS.EQ.rPSfDIM1.OR.RfnMATDIMS.EQ.rePSfDIM1) THEN
    IF(RfnMATDIMS.EQ.rPSfDIM1) THEN
     rPSFFTWfn1D=1.0d0*Rfn
     CALL DFFTW_EXECUTE_DFT_R2C(PSFFTWPLAN1D,rPSFFTWfn1D,kPSFFTWfn1D)
     Kfn=kPSFFTWfn1D
    ELSE IF(RfnMATDIMS.EQ.rePSfDIM1) THEN
     rePSFFTWfn1D=1.0d0*Rfn
     CALL DFFTW_EXECUTE_DFT_R2C(ePSFFTWPLAN1D,rePSFFTWfn1D,kePSFFTWfn1D)
     Kfn=kePSFFTWfn1D
    END IF
   ELSE IF(RfnMATDIMS.EQ.rCSfDIM1.OR.RfnMATDIMS.EQ.reCSfDIM1) THEN
    IF(RfnMATDIMS.EQ.rCSfDIM1) THEN
     rCSFFTWfn1D=1.0d0*Rfn
     CALL DFFTW_EXECUTE_DFT_R2C(CSFFTWPLAN1D,rCSFFTWfn1D,kCSFFTWfn1D)
     Kfn=kCSFFTWfn1D
    ELSE IF(RfnMATDIMS.EQ.reCSfDIM1) THEN
     reCSFFTWfn1D=1.0d0*Rfn
     CALL DFFTW_EXECUTE_DFT_R2C(eCSFFTWPLAN1D,reCSFFTWfn1D,keCSFFTWfn1D)
     Kfn=keCSFFTWfn1D
    END IF
   END IF
  END IF

  RETURN
 END SUBROUTINE r4c8FFTW1D


 SUBROUTINE c8r8iFFTW1D(Kfn,Rfn)
  IMPLICIT NONE
  include "fftw3.f"
  REAL(8),    INTENT(OUT)             :: Rfn(:)
  COMPLEX(8), INTENT(IN)              :: Kfn(:)
  INTEGER(4)                          :: RfnMATDIMS

  RfnMATDIMS=SIZE(Rfn)

  IF(RfnMATDIMS.EQ.rPSfDIM1.OR.RfnMATDIMS.EQ.rePSfDIM1) THEN
   IF(RfnMATDIMS.EQ.rPSfDIM1) THEN
    kPSFFTWfn1D=Kfn
    CALL DFFTW_EXECUTE_DFT_C2R(iPSFFTWPLAN1D,kPSFFTWfn1D,rPSFFTWfn1D)
    Rfn=rPSFFTWfn1D/REAL(RfnMATDIMS,8)
   ELSE IF(RfnMATDIMS.EQ.rePSfDIM1) THEN
    kePSFFTWfn1D=Kfn
    CALL DFFTW_EXECUTE_DFT_C2R(iePSFFTWPLAN1D,kePSFFTWfn1D,rePSFFTWfn1D)
    Rfn=rePSFFTWfn1D/REAL(RfnMATDIMS,8)
   END IF
  ELSE IF(RfnMATDIMS.EQ.rCSfDIM1.OR.RfnMATDIMS.EQ.reCSfDIM1) THEN
   IF(RfnMATDIMS.EQ.rCSfDIM1) THEN
    kCSFFTWfn1D=Kfn
    CALL DFFTW_EXECUTE_DFT_C2R(iCSFFTWPLAN1D,kCSFFTWfn1D,rCSFFTWfn1D)
    Rfn=rCSFFTWfn1D/REAL(RfnMATDIMS,8)
   ELSE IF(RfnMATDIMS.EQ.reCSfDIM1) THEN
    keCSFFTWfn1D=Kfn
    CALL DFFTW_EXECUTE_DFT_C2R(ieCSFFTWPLAN1D,keCSFFTWfn1D,reCSFFTWfn1D)
    Rfn=reCSFFTWfn1D/REAL(RfnMATDIMS,8)
   END IF
  ELSE
   CALL PSFFTWSET(RfnMATDIMS)
   CALL CSFFTWSET(RfnMATDIMS)
   IF(RfnMATDIMS.EQ.rPSfDIM1.OR.RfnMATDIMS.EQ.rePSfDIM1) THEN
    IF(RfnMATDIMS.EQ.rPSfDIM1) THEN
     kPSFFTWfn1D=Kfn
     CALL DFFTW_EXECUTE_DFT_C2R(iPSFFTWPLAN1D,kPSFFTWfn1D,rPSFFTWfn1D)
     Rfn=rPSFFTWfn1D/REAL(RfnMATDIMS,8)
    ELSE IF(RfnMATDIMS.EQ.rePSfDIM1) THEN
     kePSFFTWfn1D=Kfn
     CALL DFFTW_EXECUTE_DFT_C2R(iePSFFTWPLAN1D,kePSFFTWfn1D,rePSFFTWfn1D)
     Rfn=rePSFFTWfn1D/REAL(RfnMATDIMS,8)
    END IF
   ELSE IF(RfnMATDIMS.EQ.rCSfDIM1.OR.RfnMATDIMS.EQ.reCSfDIM1) THEN
    IF(RfnMATDIMS.EQ.rCSfDIM1) THEN
     kCSFFTWfn1D=Kfn
     CALL DFFTW_EXECUTE_DFT_C2R(iCSFFTWPLAN1D,kCSFFTWfn1D,rCSFFTWfn1D)
     Rfn=rCSFFTWfn1D/REAL(RfnMATDIMS,8)
    ELSE IF(RfnMATDIMS.EQ.reCSfDIM1) THEN
     keCSFFTWfn1D=Kfn
     CALL DFFTW_EXECUTE_DFT_C2R(ieCSFFTWPLAN1D,keCSFFTWfn1D,reCSFFTWfn1D)
     Rfn=reCSFFTWfn1D/REAL(RfnMATDIMS,8)
    END IF
   END IF
  END IF

  RETURN
 END SUBROUTINE c8r8iFFTW1D

 SUBROUTINE c8r4iFFTW1D(Kfn,Rfn)
  IMPLICIT NONE
  include "fftw3.f"
  REAL(4),    INTENT(OUT)             :: Rfn(:)
  COMPLEX(8), INTENT(IN)              :: Kfn(:)
  INTEGER(4)                          :: iD1
  INTEGER(4)                          :: RfnMATDIMS

  RfnMATDIMS=SIZE(Rfn)

  IF(RfnMATDIMS.EQ.rPSfDIM1.OR.RfnMATDIMS.EQ.rePSfDIM1) THEN
   IF(RfnMATDIMS.EQ.rPSfDIM1) THEN
    kPSFFTWfn1D=Kfn
    CALL DFFTW_EXECUTE_DFT_C2R(iPSFFTWPLAN1D,kPSFFTWfn1D,rPSFFTWfn1D)
    DO iD1=1,SIZE(Rfn)
     Rfn(iD1)=REAL(rPSFFTWfn1D(iD1)/REAL(RfnMATDIMS,8),4)
    END DO
   ELSE IF(RfnMATDIMS.EQ.rePSfDIM1) THEN
    kePSFFTWfn1D=Kfn
    CALL DFFTW_EXECUTE_DFT_C2R(iePSFFTWPLAN1D,kePSFFTWfn1D,rePSFFTWfn1D)
    DO iD1=1,SIZE(Rfn)
     Rfn(iD1)=REAL(rePSFFTWfn1D(iD1)/REAL(RfnMATDIMS,8),4)
    END DO
   END IF
  ELSE IF(RfnMATDIMS.EQ.rCSfDIM1.OR.RfnMATDIMS.EQ.reCSfDIM1) THEN
   IF(RfnMATDIMS.EQ.rCSfDIM1) THEN
    kCSFFTWfn1D=Kfn
    CALL DFFTW_EXECUTE_DFT_C2R(iCSFFTWPLAN1D,kCSFFTWfn1D,rCSFFTWfn1D)
    DO iD1=1,SIZE(Rfn)
     Rfn(iD1)=REAL(rCSFFTWfn1D(iD1)/REAL(RfnMATDIMS,8),4)
    END DO
   ELSE IF(RfnMATDIMS.EQ.reCSfDIM1) THEN
    keCSFFTWfn1D=Kfn
    CALL DFFTW_EXECUTE_DFT_C2R(ieCSFFTWPLAN1D,keCSFFTWfn1D,reCSFFTWfn1D)
    DO iD1=1,SIZE(Rfn)
     Rfn(iD1)=REAL(reCSFFTWfn1D(iD1)/REAL(RfnMATDIMS,8),4)
    END DO
   END IF
  ELSE
   CALL PSFFTWSET(RfnMATDIMS)
   CALL CSFFTWSET(RfnMATDIMS)
   IF(RfnMATDIMS.EQ.rPSfDIM1.OR.RfnMATDIMS.EQ.rePSfDIM1) THEN
    IF(RfnMATDIMS.EQ.rPSfDIM1) THEN
     kPSFFTWfn1D=Kfn
     CALL DFFTW_EXECUTE_DFT_C2R(iPSFFTWPLAN1D,kPSFFTWfn1D,rPSFFTWfn1D)
     DO iD1=1,SIZE(Rfn)
      Rfn(iD1)=REAL(rPSFFTWfn1D(iD1)/REAL(RfnMATDIMS,8),4)
     END DO
    ELSE IF(RfnMATDIMS.EQ.rePSfDIM1) THEN
     kePSFFTWfn1D=Kfn
     CALL DFFTW_EXECUTE_DFT_C2R(iePSFFTWPLAN1D,kePSFFTWfn1D,rePSFFTWfn1D)
     DO iD1=1,SIZE(Rfn)
      Rfn(iD1)=REAL(rePSFFTWfn1D(iD1)/REAL(RfnMATDIMS,8),4)
     END DO
    END IF
   ELSE IF(RfnMATDIMS.EQ.rCSfDIM1.OR.RfnMATDIMS.EQ.reCSfDIM1) THEN
    IF(RfnMATDIMS.EQ.rCSfDIM1) THEN
     kCSFFTWfn1D=Kfn
     CALL DFFTW_EXECUTE_DFT_C2R(iCSFFTWPLAN1D,kCSFFTWfn1D,rCSFFTWfn1D)
     DO iD1=1,SIZE(Rfn)
      Rfn(iD1)=REAL(rCSFFTWfn1D(iD1)/REAL(RfnMATDIMS,8),4)
     END DO
    ELSE IF(RfnMATDIMS.EQ.reCSfDIM1) THEN
     keCSFFTWfn1D=Kfn
     CALL DFFTW_EXECUTE_DFT_C2R(ieCSFFTWPLAN1D,keCSFFTWfn1D,reCSFFTWfn1D)
     DO iD1=1,SIZE(Rfn)
      Rfn(iD1)=REAL(reCSFFTWfn1D(iD1)/REAL(RfnMATDIMS,8),4)
     END DO
    END IF
   END IF
  END IF

  RETURN
 END SUBROUTINE c8r4iFFTW1D


 SUBROUTINE r8c8FFTW2D(Rfn,Kfn)
  IMPLICIT NONE
  include "fftw3.f"
  REAL(8),    INTENT(IN)              :: Rfn(:,:)
  COMPLEX(8), INTENT(OUT)             :: Kfn(:,:)
  INTEGER(4)                          :: RfnMATDIMS(2)

  RfnMATDIMS=SHAPE(Rfn)

  IF(RfnMATDIMS(1).EQ.rPSfDIM1.OR.RfnMATDIMS(1).EQ.rePSfDIM1) THEN
   IF(RfnMATDIMS(1).EQ.rPSfDIM1) THEN
    rPSFFTWfn2D=1.0d0*Rfn
    CALL DFFTW_EXECUTE_DFT_R2C(PSFFTWPLAN2D,rPSFFTWfn2D,kPSFFTWfn2D)
    Kfn=kPSFFTWfn2D
   ELSE IF(RfnMATDIMS(1).EQ.rePSfDIM1) THEN
    rePSFFTWfn2D=1.0d0*Rfn
    CALL DFFTW_EXECUTE_DFT_R2C(ePSFFTWPLAN2D,rePSFFTWfn2D,kePSFFTWfn2D)
    Kfn=kePSFFTWfn2D
   END IF
  ELSE IF(RfnMATDIMS(1).EQ.rCSfDIM1.OR.RfnMATDIMS(1).EQ.reCSfDIM1) THEN
   IF(RfnMATDIMS(1).EQ.rCSfDIM1) THEN
    rCSFFTWfn2D=1.0d0*Rfn
    CALL DFFTW_EXECUTE_DFT_R2C(CSFFTWPLAN2D,rCSFFTWfn2D,kCSFFTWfn2D)
    Kfn=kCSFFTWfn2D
   ELSE IF(RfnMATDIMS(1).EQ.reCSfDIM1) THEN
    reCSFFTWfn2D=1.0d0*Rfn
    CALL DFFTW_EXECUTE_DFT_R2C(eCSFFTWPLAN2D,reCSFFTWfn2D,keCSFFTWfn2D)
    Kfn=keCSFFTWfn2D
   END IF
  ELSE
   CALL PSFFTWSET(RfnMATDIMS(1),RfnMATDIMS(2))
   CALL CSFFTWSET(RfnMATDIMS(1),RfnMATDIMS(2))
   IF(RfnMATDIMS(1).EQ.rPSfDIM1.OR.RfnMATDIMS(1).EQ.rePSfDIM1) THEN
    IF(RfnMATDIMS(1).EQ.rPSfDIM1) THEN
     rPSFFTWfn2D=1.0d0*Rfn
     CALL DFFTW_EXECUTE_DFT_R2C(PSFFTWPLAN2D,rPSFFTWfn2D,kPSFFTWfn2D)
     Kfn=kPSFFTWfn2D
    ELSE IF(RfnMATDIMS(1).EQ.rePSfDIM1) THEN
     rePSFFTWfn2D=1.0d0*Rfn
     CALL DFFTW_EXECUTE_DFT_R2C(ePSFFTWPLAN2D,rePSFFTWfn2D,kePSFFTWfn2D)
     Kfn=kePSFFTWfn2D
    END IF
   ELSE IF(RfnMATDIMS(1).EQ.rCSfDIM1.OR.RfnMATDIMS(1).EQ.reCSfDIM1) THEN
    IF(RfnMATDIMS(1).EQ.rCSfDIM1) THEN
     rCSFFTWfn2D=1.0d0*Rfn
     CALL DFFTW_EXECUTE_DFT_R2C(CSFFTWPLAN2D,rCSFFTWfn2D,kCSFFTWfn2D)
     Kfn=kCSFFTWfn2D
    ELSE IF(RfnMATDIMS(1).EQ.reCSfDIM1) THEN
     reCSFFTWfn2D=1.0d0*Rfn
     CALL DFFTW_EXECUTE_DFT_R2C(eCSFFTWPLAN2D,reCSFFTWfn2D,keCSFFTWfn2D)
     Kfn=keCSFFTWfn2D
    END IF
   END IF
  END IF

  RETURN
 END SUBROUTINE r8c8FFTW2D

 SUBROUTINE r4c8FFTW2D(Rfn,Kfn)
  IMPLICIT NONE
  include "fftw3.f"
  REAL(4),    INTENT(IN)              :: Rfn(:,:)
  COMPLEX(8), INTENT(OUT)             :: Kfn(:,:)
  INTEGER(4)                          :: RfnMATDIMS(2)

  RfnMATDIMS=SHAPE(Rfn)

  IF(RfnMATDIMS(1).EQ.rPSfDIM1.OR.RfnMATDIMS(1).EQ.rePSfDIM1) THEN
   IF(RfnMATDIMS(1).EQ.rPSfDIM1) THEN
    rPSFFTWfn2D=1.0d0*Rfn
    CALL DFFTW_EXECUTE_DFT_R2C(PSFFTWPLAN2D,rPSFFTWfn2D,kPSFFTWfn2D)
    Kfn=kPSFFTWfn2D
   ELSE IF(RfnMATDIMS(1).EQ.rePSfDIM1) THEN
    rePSFFTWfn2D=1.0d0*Rfn
    CALL DFFTW_EXECUTE_DFT_R2C(ePSFFTWPLAN2D,rePSFFTWfn2D,kePSFFTWfn2D)
    Kfn=kePSFFTWfn2D
   END IF
  ELSE IF(RfnMATDIMS(1).EQ.rCSfDIM1.OR.RfnMATDIMS(1).EQ.reCSfDIM1) THEN
   IF(RfnMATDIMS(1).EQ.rCSfDIM1) THEN
    rCSFFTWfn2D=1.0d0*Rfn
    CALL DFFTW_EXECUTE_DFT_R2C(CSFFTWPLAN2D,rCSFFTWfn2D,kCSFFTWfn2D)
    Kfn=kCSFFTWfn2D
   ELSE IF(RfnMATDIMS(1).EQ.reCSfDIM1) THEN
    reCSFFTWfn2D=1.0d0*Rfn
    CALL DFFTW_EXECUTE_DFT_R2C(eCSFFTWPLAN2D,reCSFFTWfn2D,keCSFFTWfn2D)
    Kfn=keCSFFTWfn2D
   END IF
  ELSE
   CALL PSFFTWSET(RfnMATDIMS(1),RfnMATDIMS(2))
   CALL CSFFTWSET(RfnMATDIMS(1),RfnMATDIMS(2))
   IF(RfnMATDIMS(1).EQ.rPSfDIM1.OR.RfnMATDIMS(1).EQ.rePSfDIM1) THEN
    IF(RfnMATDIMS(1).EQ.rPSfDIM1) THEN
     rPSFFTWfn2D=1.0d0*Rfn
     CALL DFFTW_EXECUTE_DFT_R2C(PSFFTWPLAN2D,rPSFFTWfn2D,kPSFFTWfn2D)
     Kfn=kPSFFTWfn2D
    ELSE IF(RfnMATDIMS(1).EQ.rePSfDIM1) THEN
     rePSFFTWfn2D=1.0d0*Rfn
     CALL DFFTW_EXECUTE_DFT_R2C(ePSFFTWPLAN2D,rePSFFTWfn2D,kePSFFTWfn2D)
     Kfn=kePSFFTWfn2D
    END IF
   ELSE IF(RfnMATDIMS(1).EQ.rCSfDIM1.OR.RfnMATDIMS(1).EQ.reCSfDIM1) THEN
    IF(RfnMATDIMS(1).EQ.rCSfDIM1) THEN
     rCSFFTWfn2D=1.0d0*Rfn
     CALL DFFTW_EXECUTE_DFT_R2C(CSFFTWPLAN2D,rCSFFTWfn2D,kCSFFTWfn2D)
     Kfn=kCSFFTWfn2D
    ELSE IF(RfnMATDIMS(1).EQ.reCSfDIM1) THEN
     reCSFFTWfn2D=1.0d0*Rfn
     CALL DFFTW_EXECUTE_DFT_R2C(eCSFFTWPLAN2D,reCSFFTWfn2D,keCSFFTWfn2D)
     Kfn=keCSFFTWfn2D
    END IF
   END IF
  END IF

  RETURN
 END SUBROUTINE r4c8FFTW2D


 SUBROUTINE c8r8iFFTW2D(Kfn,Rfn)
  IMPLICIT NONE
  include "fftw3.f"
  REAL(8),    INTENT(OUT)             :: Rfn(:,:)
  COMPLEX(8), INTENT(IN)              :: Kfn(:,:)
  INTEGER(4)                          :: RfnMATDIMS(2)

  RfnMATDIMS=SHAPE(Rfn)

  IF(RfnMATDIMS(1).EQ.rPSfDIM1.OR.RfnMATDIMS(1).EQ.rePSfDIM1) THEN
   IF(RfnMATDIMS(1).EQ.rPSfDIM1) THEN
    kPSFFTWfn2D=Kfn
    CALL DFFTW_EXECUTE_DFT_C2R(iPSFFTWPLAN2D,kPSFFTWfn2D,rPSFFTWfn2D)
    Rfn=rPSFFTWfn2D/REAL(RfnMATDIMS(1)*RfnMATDIMS(2),8)
   ELSE IF(RfnMATDIMS(1).EQ.rePSfDIM1) THEN
    kePSFFTWfn2D=Kfn
    CALL DFFTW_EXECUTE_DFT_C2R(iePSFFTWPLAN2D,kePSFFTWfn2D,rePSFFTWfn2D)
    Rfn=rePSFFTWfn2D/REAL(RfnMATDIMS(1)*RfnMATDIMS(2),8)
   END IF
  ELSE IF(RfnMATDIMS(1).EQ.rCSfDIM1.OR.RfnMATDIMS(1).EQ.reCSfDIM1) THEN
   IF(RfnMATDIMS(1).EQ.rCSfDIM1) THEN
    kCSFFTWfn2D=Kfn
    CALL DFFTW_EXECUTE_DFT_C2R(iCSFFTWPLAN2D,kCSFFTWfn2D,rCSFFTWfn2D)
    Rfn=rCSFFTWfn2D/REAL(RfnMATDIMS(1)*RfnMATDIMS(2),8)
   ELSE IF(RfnMATDIMS(1).EQ.reCSfDIM1) THEN
    keCSFFTWfn2D=Kfn
    CALL DFFTW_EXECUTE_DFT_C2R(ieCSFFTWPLAN2D,keCSFFTWfn2D,reCSFFTWfn2D)
    Rfn=reCSFFTWfn2D/REAL(RfnMATDIMS(1)*RfnMATDIMS(2),8)
   END IF
  ELSE
   CALL PSFFTWSET(RfnMATDIMS(1),RfnMATDIMS(2))
   CALL CSFFTWSET(RfnMATDIMS(1),RfnMATDIMS(2))
   IF(RfnMATDIMS(1).EQ.rPSfDIM1.OR.RfnMATDIMS(1).EQ.rePSfDIM1) THEN
    IF(RfnMATDIMS(1).EQ.rPSfDIM1) THEN
     kPSFFTWfn2D=Kfn
     CALL DFFTW_EXECUTE_DFT_C2R(iPSFFTWPLAN2D,kPSFFTWfn2D,rPSFFTWfn2D)
     Rfn=rPSFFTWfn2D/REAL(RfnMATDIMS(1)*RfnMATDIMS(2),8)
    ELSE IF(RfnMATDIMS(1).EQ.rePSfDIM1) THEN
     kePSFFTWfn2D=Kfn
     CALL DFFTW_EXECUTE_DFT_C2R(iePSFFTWPLAN2D,kePSFFTWfn2D,rePSFFTWfn2D)
     Rfn=rePSFFTWfn2D/REAL(RfnMATDIMS(1)*RfnMATDIMS(2),8)
    END IF
   ELSE IF(RfnMATDIMS(1).EQ.rCSfDIM1.OR.RfnMATDIMS(1).EQ.reCSfDIM1) THEN
    IF(RfnMATDIMS(1).EQ.rCSfDIM1) THEN
     kCSFFTWfn2D=Kfn
     CALL DFFTW_EXECUTE_DFT_C2R(iCSFFTWPLAN2D,kCSFFTWfn2D,rCSFFTWfn2D)
     Rfn=rCSFFTWfn2D/REAL(RfnMATDIMS(1)*RfnMATDIMS(2),8)
    ELSE IF(RfnMATDIMS(1).EQ.reCSfDIM1) THEN
     keCSFFTWfn2D=Kfn
     CALL DFFTW_EXECUTE_DFT_C2R(ieCSFFTWPLAN2D,keCSFFTWfn2D,reCSFFTWfn2D)
     Rfn=reCSFFTWfn2D/REAL(RfnMATDIMS(1)*RfnMATDIMS(2),8)
    END IF
   END IF
  END IF

  RETURN
 END SUBROUTINE c8r8iFFTW2D

 SUBROUTINE c8r4iFFTW2D(Kfn,Rfn)
  IMPLICIT NONE
  include "fftw3.f"
  REAL(4),    INTENT(OUT)             :: Rfn(:,:)
  COMPLEX(8), INTENT(IN)              :: Kfn(:,:)
  INTEGER(4)                          :: iD1,iD2
  INTEGER(4)                          :: RfnMATDIMS(2)

  RfnMATDIMS=SHAPE(Rfn)

  IF(RfnMATDIMS(1).EQ.rPSfDIM1.OR.RfnMATDIMS(1).EQ.rePSfDIM1) THEN
   IF(RfnMATDIMS(1).EQ.rPSfDIM1) THEN
    kPSFFTWfn2D=Kfn
    CALL DFFTW_EXECUTE_DFT_C2R(iPSFFTWPLAN1D,kPSFFTWfn1D,rPSFFTWfn1D)
    DO iD1=1,RfnMATDIMS(1)
     DO iD2=1,RfnMATDIMS(2)
      Rfn(iD1,iD2)=REAL(rPSFFTWfn2D(iD1,iD2)/REAL(RfnMATDIMS(1)*RfnMATDIMS(2),8),4)
     END DO
    END DO
   ELSE IF(RfnMATDIMS(1).EQ.rePSfDIM1) THEN
    kePSFFTWfn2D=Kfn
    CALL DFFTW_EXECUTE_DFT_C2R(iePSFFTWPLAN2D,kePSFFTWfn2D,rePSFFTWfn2D)
    DO iD1=1,RfnMATDIMS(1)
     DO iD2=1,RfnMATDIMS(2)
      Rfn(iD1,iD2)=REAL(rePSFFTWfn2D(iD1,iD2)/REAL(RfnMATDIMS(1)*RfnMATDIMS(2),8),4)
     END DO
    END DO
   END IF
  ELSE IF(RfnMATDIMS(1).EQ.rCSfDIM1.OR.RfnMATDIMS(1).EQ.reCSfDIM1) THEN
   IF(RfnMATDIMS(1).EQ.rCSfDIM1) THEN
    kCSFFTWfn2D=Kfn
    CALL DFFTW_EXECUTE_DFT_C2R(iCSFFTWPLAN2D,kCSFFTWfn2D,rCSFFTWfn2D)
    DO iD1=1,RfnMATDIMS(1)
     DO iD2=1,RfnMATDIMS(2)
      Rfn(iD1,iD2)=REAL(rCSFFTWfn2D(iD1,iD2)/REAL(RfnMATDIMS(1)*RfnMATDIMS(2),8),4)
     END DO
    END DO
   ELSE IF(RfnMATDIMS(1).EQ.reCSfDIM1) THEN
    keCSFFTWfn2D=Kfn
    CALL DFFTW_EXECUTE_DFT_C2R(ieCSFFTWPLAN2D,keCSFFTWfn2D,reCSFFTWfn2D)
    DO iD1=1,RfnMATDIMS(1)
     DO iD2=1,RfnMATDIMS(2)
      Rfn(iD1,iD2)=REAL(reCSFFTWfn2D(iD1,iD2)/REAL(RfnMATDIMS(1)*RfnMATDIMS(2),8),4)
     END DO
    END DO
   END IF
  ELSE
   CALL PSFFTWSET(RfnMATDIMS(1),RfnMATDIMS(2))
   CALL CSFFTWSET(RfnMATDIMS(1),RfnMATDIMS(2))
   IF(RfnMATDIMS(1).EQ.rPSfDIM1.OR.RfnMATDIMS(1).EQ.rePSfDIM1) THEN
    IF(RfnMATDIMS(1).EQ.rPSfDIM1) THEN
     kPSFFTWfn2D=Kfn
     CALL DFFTW_EXECUTE_DFT_C2R(iPSFFTWPLAN1D,kPSFFTWfn1D,rPSFFTWfn1D)
     DO iD1=1,RfnMATDIMS(1)
      DO iD2=1,RfnMATDIMS(2)
       Rfn(iD1,iD2)=REAL(rPSFFTWfn2D(iD1,iD2)/REAL(RfnMATDIMS(1)*RfnMATDIMS(2),8),4)
      END DO
     END DO
    ELSE IF(RfnMATDIMS(1).EQ.rePSfDIM1) THEN
     kePSFFTWfn2D=Kfn
     CALL DFFTW_EXECUTE_DFT_C2R(iePSFFTWPLAN2D,kePSFFTWfn2D,rePSFFTWfn2D)
     DO iD1=1,RfnMATDIMS(1)
      DO iD2=1,RfnMATDIMS(2)
       Rfn(iD1,iD2)=REAL(rePSFFTWfn2D(iD1,iD2)/REAL(RfnMATDIMS(1)*RfnMATDIMS(2),8),4)
      END DO
     END DO
    END IF
   ELSE IF(RfnMATDIMS(1).EQ.rCSfDIM1.OR.RfnMATDIMS(1).EQ.reCSfDIM1) THEN
    IF(RfnMATDIMS(1).EQ.rCSfDIM1) THEN
     kCSFFTWfn2D=Kfn
     CALL DFFTW_EXECUTE_DFT_C2R(iCSFFTWPLAN2D,kCSFFTWfn2D,rCSFFTWfn2D)
     DO iD1=1,RfnMATDIMS(1)
      DO iD2=1,RfnMATDIMS(2)
       Rfn(iD1,iD2)=REAL(rCSFFTWfn2D(iD1,iD2)/REAL(RfnMATDIMS(1)*RfnMATDIMS(2),8),4)
      END DO
     END DO
    ELSE IF(RfnMATDIMS(1).EQ.reCSfDIM1) THEN
     keCSFFTWfn2D=Kfn
     CALL DFFTW_EXECUTE_DFT_C2R(ieCSFFTWPLAN2D,keCSFFTWfn2D,reCSFFTWfn2D)
     DO iD1=1,RfnMATDIMS(1)
      DO iD2=1,RfnMATDIMS(2)
       Rfn(iD1,iD2)=REAL(reCSFFTWfn2D(iD1,iD2)/REAL(RfnMATDIMS(1)*RfnMATDIMS(2),8),4)
      END DO
     END DO
    END IF
   END IF
  END IF

  RETURN
 END SUBROUTINE c8r4iFFTW2D


 SUBROUTINE r8c8FFTW3D(Rfn,Kfn)
  IMPLICIT NONE
  include "fftw3.f"
  REAL(8),    INTENT(IN)              :: Rfn(:,:,:)
  COMPLEX(8), INTENT(OUT)             :: Kfn(:,:,:)
  INTEGER(4)                          :: RfnMATDIMS(3)

  RfnMATDIMS=SHAPE(Rfn)

  IF(RfnMATDIMS(1).EQ.rPSfDIM1.OR.RfnMATDIMS(1).EQ.rePSfDIM1) THEN
   IF(RfnMATDIMS(1).EQ.rPSfDIM1) THEN
    rPSFFTWfn3D=1.0d0*Rfn
    CALL DFFTW_EXECUTE_DFT_R2C(PSFFTWPLAN3D,rPSFFTWfn3D,kPSFFTWfn3D)
    Kfn=kPSFFTWfn3D
   ELSE IF(RfnMATDIMS(1).EQ.rePSfDIM1) THEN
    rePSFFTWfn3D=1.0d0*Rfn
    CALL DFFTW_EXECUTE_DFT_R2C(ePSFFTWPLAN3D,rePSFFTWfn3D,kePSFFTWfn3D)
    Kfn=kePSFFTWfn3D
   END IF
  ELSE IF(RfnMATDIMS(1).EQ.rCSfDIM1.OR.RfnMATDIMS(1).EQ.reCSfDIM1) THEN
   IF(RfnMATDIMS(1).EQ.rCSfDIM1) THEN
    rCSFFTWfn3D=1.0d0*Rfn
    CALL DFFTW_EXECUTE_DFT_R2C(CSFFTWPLAN3D,rCSFFTWfn3D,kCSFFTWfn3D)
    Kfn=kCSFFTWfn3D
   ELSE IF(RfnMATDIMS(1).EQ.reCSfDIM1) THEN
    reCSFFTWfn3D=1.0d0*Rfn
    CALL DFFTW_EXECUTE_DFT_R2C(eCSFFTWPLAN3D,reCSFFTWfn3D,keCSFFTWfn3D)
    Kfn=keCSFFTWfn3D
   END IF
  ELSE
   CALL PSFFTWSET(RfnMATDIMS(1),RfnMATDIMS(2),RfnMATDIMS(3))
   CALL CSFFTWSET(RfnMATDIMS(1),RfnMATDIMS(2),RfnMATDIMS(3))
   IF(RfnMATDIMS(1).EQ.rPSfDIM1.OR.RfnMATDIMS(1).EQ.rePSfDIM1) THEN
    IF(RfnMATDIMS(1).EQ.rPSfDIM1) THEN
     rPSFFTWfn3D=1.0d0*Rfn
     CALL DFFTW_EXECUTE_DFT_R2C(PSFFTWPLAN3D,rPSFFTWfn3D,kPSFFTWfn3D)
     Kfn=kPSFFTWfn3D
    ELSE IF(RfnMATDIMS(1).EQ.rePSfDIM1) THEN
     rePSFFTWfn3D=1.0d0*Rfn
     CALL DFFTW_EXECUTE_DFT_R2C(ePSFFTWPLAN3D,rePSFFTWfn3D,kePSFFTWfn3D)
     Kfn=kePSFFTWfn3D
    END IF
   ELSE IF(RfnMATDIMS(1).EQ.rCSfDIM1.OR.RfnMATDIMS(1).EQ.reCSfDIM1) THEN
    IF(RfnMATDIMS(1).EQ.rCSfDIM1) THEN
     rCSFFTWfn3D=1.0d0*Rfn
     CALL DFFTW_EXECUTE_DFT_R2C(CSFFTWPLAN3D,rCSFFTWfn3D,kCSFFTWfn3D)
     Kfn=kCSFFTWfn3D
    ELSE IF(RfnMATDIMS(1).EQ.reCSfDIM1) THEN
     reCSFFTWfn3D=1.0d0*Rfn
     CALL DFFTW_EXECUTE_DFT_R2C(eCSFFTWPLAN3D,reCSFFTWfn3D,keCSFFTWfn3D)
     Kfn=keCSFFTWfn3D
    END IF
   END IF
  END IF

  RETURN
 END SUBROUTINE r8c8FFTW3D

 SUBROUTINE r4c8FFTW3D(Rfn,Kfn)
  IMPLICIT NONE
  include "fftw3.f"
  REAL(4),    INTENT(IN)              :: Rfn(:,:,:)
  COMPLEX(8), INTENT(OUT)             :: Kfn(:,:,:)
  INTEGER(4)                          :: RfnMATDIMS(3)

  RfnMATDIMS=SHAPE(Rfn)

  IF(RfnMATDIMS(1).EQ.rPSfDIM1.OR.RfnMATDIMS(1).EQ.rePSfDIM1) THEN
   IF(RfnMATDIMS(1).EQ.rPSfDIM1) THEN
    rPSFFTWfn3D=1.0d0*Rfn
    CALL DFFTW_EXECUTE_DFT_R2C(PSFFTWPLAN3D,rPSFFTWfn3D,kPSFFTWfn3D)
    Kfn=kPSFFTWfn3D
   ELSE IF(RfnMATDIMS(1).EQ.rePSfDIM1) THEN
    rePSFFTWfn3D=1.0d0*Rfn
    CALL DFFTW_EXECUTE_DFT_R2C(ePSFFTWPLAN3D,rePSFFTWfn3D,kePSFFTWfn3D)
    Kfn=kePSFFTWfn3D
   END IF
  ELSE IF(RfnMATDIMS(1).EQ.rCSfDIM1.OR.RfnMATDIMS(1).EQ.reCSfDIM1) THEN
   IF(RfnMATDIMS(1).EQ.rCSfDIM1) THEN
    rCSFFTWfn3D=1.0d0*Rfn
    CALL DFFTW_EXECUTE_DFT_R2C(CSFFTWPLAN3D,rCSFFTWfn3D,kCSFFTWfn3D)
    Kfn=kCSFFTWfn3D
   ELSE IF(RfnMATDIMS(1).EQ.reCSfDIM1) THEN
    reCSFFTWfn3D=1.0d0*Rfn
    CALL DFFTW_EXECUTE_DFT_R2C(eCSFFTWPLAN3D,reCSFFTWfn3D,keCSFFTWfn3D)
    Kfn=keCSFFTWfn3D
   END IF
  ELSE
   CALL PSFFTWSET(RfnMATDIMS(1),RfnMATDIMS(2),RfnMATDIMS(3))
   CALL CSFFTWSET(RfnMATDIMS(1),RfnMATDIMS(2),RfnMATDIMS(3))
   IF(RfnMATDIMS(1).EQ.rPSfDIM1.OR.RfnMATDIMS(1).EQ.rePSfDIM1) THEN
    IF(RfnMATDIMS(1).EQ.rPSfDIM1) THEN
     rPSFFTWfn3D=1.0d0*Rfn
     CALL DFFTW_EXECUTE_DFT_R2C(PSFFTWPLAN3D,rPSFFTWfn3D,kPSFFTWfn3D)
     Kfn=kPSFFTWfn3D
    ELSE IF(RfnMATDIMS(1).EQ.rePSfDIM1) THEN
     rePSFFTWfn3D=1.0d0*Rfn
     CALL DFFTW_EXECUTE_DFT_R2C(ePSFFTWPLAN3D,rePSFFTWfn3D,kePSFFTWfn3D)
     Kfn=kePSFFTWfn3D
    END IF
   ELSE IF(RfnMATDIMS(1).EQ.rCSfDIM1.OR.RfnMATDIMS(1).EQ.reCSfDIM1) THEN
    IF(RfnMATDIMS(1).EQ.rCSfDIM1) THEN
     rCSFFTWfn3D=1.0d0*Rfn
     CALL DFFTW_EXECUTE_DFT_R2C(CSFFTWPLAN3D,rCSFFTWfn3D,kCSFFTWfn3D)
     Kfn=kCSFFTWfn3D
    ELSE IF(RfnMATDIMS(1).EQ.reCSfDIM1) THEN
     reCSFFTWfn3D=1.0d0*Rfn
     CALL DFFTW_EXECUTE_DFT_R2C(eCSFFTWPLAN3D,reCSFFTWfn3D,keCSFFTWfn3D)
     Kfn=keCSFFTWfn3D
    END IF
   END IF
  END IF

  RETURN
 END SUBROUTINE r4c8FFTW3D


 SUBROUTINE c8r8iFFTW3D(Kfn,Rfn)
  IMPLICIT NONE
  include "fftw3.f"
  REAL(8),    INTENT(OUT)             :: Rfn(:,:,:)
  COMPLEX(8), INTENT(IN)              :: Kfn(:,:,:)
  INTEGER(4)                          :: RfnMATDIMS(3)

  RfnMATDIMS=SHAPE(Rfn)

  IF(RfnMATDIMS(1).EQ.rPSfDIM1.OR.RfnMATDIMS(1).EQ.rePSfDIM1) THEN
   IF(RfnMATDIMS(1).EQ.rPSfDIM1) THEN
    kPSFFTWfn3D=Kfn
    CALL DFFTW_EXECUTE_DFT_C2R(iPSFFTWPLAN3D,kPSFFTWfn3D,rPSFFTWfn3D)
    Rfn=rPSFFTWfn3D/REAL(RfnMATDIMS(1)*RfnMATDIMS(2)*RfnMATDIMS(3))
   ELSE IF(RfnMATDIMS(1).EQ.rePSfDIM1) THEN
    kePSFFTWfn3D=Kfn
    CALL DFFTW_EXECUTE_DFT_C2R(iePSFFTWPLAN3D,kePSFFTWfn3D,rePSFFTWfn3D)
    Rfn=rePSFFTWfn3D/REAL(RfnMATDIMS(1)*RfnMATDIMS(2)*RfnMATDIMS(3))
   END IF
  ELSE IF(RfnMATDIMS(1).EQ.rCSfDIM1.OR.RfnMATDIMS(1).EQ.reCSfDIM1) THEN
   IF(RfnMATDIMS(1).EQ.rCSfDIM1) THEN
    kCSFFTWfn3D=Kfn
    CALL DFFTW_EXECUTE_DFT_C2R(iCSFFTWPLAN3D,kCSFFTWfn3D,rCSFFTWfn3D)
    Rfn=rCSFFTWfn3D/REAL(RfnMATDIMS(1)*RfnMATDIMS(2)*RfnMATDIMS(3))
   ELSE IF(RfnMATDIMS(1).EQ.reCSfDIM1) THEN
    keCSFFTWfn3D=Kfn
    CALL DFFTW_EXECUTE_DFT_C2R(ieCSFFTWPLAN3D,keCSFFTWfn3D,reCSFFTWfn3D)
    Rfn=reCSFFTWfn3D/REAL(RfnMATDIMS(1)*RfnMATDIMS(2)*RfnMATDIMS(3))
   END IF
  ELSE
   CALL PSFFTWSET(RfnMATDIMS(1),RfnMATDIMS(2),RfnMATDIMS(3))
   CALL CSFFTWSET(RfnMATDIMS(1),RfnMATDIMS(2),RfnMATDIMS(3))
   IF(RfnMATDIMS(1).EQ.rPSfDIM1.OR.RfnMATDIMS(1).EQ.rePSfDIM1) THEN
    IF(RfnMATDIMS(1).EQ.rPSfDIM1) THEN
     kPSFFTWfn3D=Kfn
     CALL DFFTW_EXECUTE_DFT_C2R(iPSFFTWPLAN3D,kPSFFTWfn3D,rPSFFTWfn3D)
     Rfn=rPSFFTWfn3D/REAL(RfnMATDIMS(1)*RfnMATDIMS(2)*RfnMATDIMS(3))
    ELSE IF(RfnMATDIMS(1).EQ.rePSfDIM1) THEN
     kePSFFTWfn3D=Kfn
     CALL DFFTW_EXECUTE_DFT_C2R(iePSFFTWPLAN3D,kePSFFTWfn3D,rePSFFTWfn3D)
     Rfn=rePSFFTWfn3D/REAL(RfnMATDIMS(1)*RfnMATDIMS(2)*RfnMATDIMS(3))
    END IF
   ELSE IF(RfnMATDIMS(1).EQ.rCSfDIM1.OR.RfnMATDIMS(1).EQ.reCSfDIM1) THEN
    IF(RfnMATDIMS(1).EQ.rCSfDIM1) THEN
     kCSFFTWfn3D=Kfn
     CALL DFFTW_EXECUTE_DFT_C2R(iCSFFTWPLAN3D,kCSFFTWfn3D,rCSFFTWfn3D)
     Rfn=rCSFFTWfn3D/REAL(RfnMATDIMS(1)*RfnMATDIMS(2)*RfnMATDIMS(3))
    ELSE IF(RfnMATDIMS(1).EQ.reCSfDIM1) THEN
     keCSFFTWfn3D=Kfn
     CALL DFFTW_EXECUTE_DFT_C2R(ieCSFFTWPLAN3D,keCSFFTWfn3D,reCSFFTWfn3D)
     Rfn=reCSFFTWfn3D/REAL(RfnMATDIMS(1)*RfnMATDIMS(2)*RfnMATDIMS(3))
    END IF
   END IF
  END IF

  RETURN
 END SUBROUTINE c8r8iFFTW3D

 SUBROUTINE c8r4iFFTW3D(Kfn,Rfn)
  IMPLICIT NONE
  include "fftw3.f"
  REAL(4),    INTENT(OUT)             :: Rfn(:,:,:)
  COMPLEX(8), INTENT(IN)              :: Kfn(:,:,:)
  INTEGER(4)                          :: iD1,iD2,iD3
  INTEGER(4)                          :: RfnMATDIMS(3)

  RfnMATDIMS=SHAPE(Rfn)

  IF(RfnMATDIMS(1).EQ.rPSfDIM1.OR.RfnMATDIMS(1).EQ.rePSfDIM1) THEN
   IF(RfnMATDIMS(1).EQ.rPSfDIM1) THEN
    kPSFFTWfn3D=Kfn
    CALL DFFTW_EXECUTE_DFT_C2R(iPSFFTWPLAN3D,kPSFFTWfn3D,rPSFFTWfn3D)
    DO iD1=1,RfnMATDIMS(1)
     DO iD2=1,RfnMATDIMS(2)
      DO iD3=1,RfnMATDIMS(3)
       Rfn(iD1,iD2,iD3)=REAL(rPSFFTWfn3D(iD1,iD2,iD3)/REAL(RfnMATDIMS(1)*RfnMATDIMS(2)*RfnMATDIMS(3)),4)
      END DO
     END DO
    END DO
   ELSE IF(RfnMATDIMS(1).EQ.rePSfDIM1) THEN
    kePSFFTWfn3D=Kfn
    CALL DFFTW_EXECUTE_DFT_C2R(iePSFFTWPLAN3D,kePSFFTWfn3D,rePSFFTWfn3D)
    DO iD1=1,RfnMATDIMS(1)
     DO iD2=1,RfnMATDIMS(2)
      DO iD3=1,RfnMATDIMS(3)
       Rfn(iD1,iD2,iD3)=REAL(rePSFFTWfn3D(iD1,iD2,iD3)/REAL(RfnMATDIMS(1)*RfnMATDIMS(2)*RfnMATDIMS(3)),4)
      END DO
     END DO
    END DO
   END IF
  ELSE IF(RfnMATDIMS(1).EQ.rCSfDIM1.OR.RfnMATDIMS(1).EQ.reCSfDIM1) THEN
   IF(RfnMATDIMS(1).EQ.rCSfDIM1) THEN
    kCSFFTWfn3D=Kfn
    CALL DFFTW_EXECUTE_DFT_C2R(iCSFFTWPLAN3D,kCSFFTWfn3D,rCSFFTWfn3D)
    DO iD1=1,RfnMATDIMS(1)
     DO iD2=1,RfnMATDIMS(2)
      DO iD3=1,RfnMATDIMS(3)
       Rfn(iD1,iD2,iD3)=REAL(rCSFFTWfn3D(iD1,iD2,iD3)/REAL(RfnMATDIMS(1)*RfnMATDIMS(2)*RfnMATDIMS(3)),4)
      END DO
     END DO
    END DO
   ELSE IF(RfnMATDIMS(1).EQ.reCSfDIM1) THEN
    keCSFFTWfn3D=Kfn
    CALL DFFTW_EXECUTE_DFT_C2R(ieCSFFTWPLAN3D,keCSFFTWfn3D,reCSFFTWfn3D)
    DO iD1=1,RfnMATDIMS(1)
     DO iD2=1,RfnMATDIMS(2)
      DO iD3=1,RfnMATDIMS(3)
       Rfn(iD1,iD2,iD3)=REAL(reCSFFTWfn3D(iD1,iD2,iD3)/REAL(RfnMATDIMS(1)*RfnMATDIMS(2)*RfnMATDIMS(3)),4)
      END DO
     END DO
    END DO
   END IF
  ELSE
   CALL PSFFTWSET(RfnMATDIMS(1),RfnMATDIMS(2),RfnMATDIMS(3))
   CALL CSFFTWSET(RfnMATDIMS(1),RfnMATDIMS(2),RfnMATDIMS(3))
   IF(RfnMATDIMS(1).EQ.rPSfDIM1.OR.RfnMATDIMS(1).EQ.rePSfDIM1) THEN
    IF(RfnMATDIMS(1).EQ.rPSfDIM1) THEN
     kPSFFTWfn3D=Kfn
     CALL DFFTW_EXECUTE_DFT_C2R(iPSFFTWPLAN3D,kPSFFTWfn3D,rPSFFTWfn3D)
     DO iD1=1,RfnMATDIMS(1)
      DO iD2=1,RfnMATDIMS(2)
       DO iD3=1,RfnMATDIMS(3)
        Rfn(iD1,iD2,iD3)=REAL(rPSFFTWfn3D(iD1,iD2,iD3)/REAL(RfnMATDIMS(1)*RfnMATDIMS(2)*RfnMATDIMS(3)),4)
       END DO
      END DO
     END DO
    ELSE IF(RfnMATDIMS(1).EQ.rePSfDIM1) THEN
     kePSFFTWfn3D=Kfn
     CALL DFFTW_EXECUTE_DFT_C2R(iePSFFTWPLAN3D,kePSFFTWfn3D,rePSFFTWfn3D)
     DO iD1=1,RfnMATDIMS(1)
      DO iD2=1,RfnMATDIMS(2)
       DO iD3=1,RfnMATDIMS(3)
        Rfn(iD1,iD2,iD3)=REAL(rePSFFTWfn3D(iD1,iD2,iD3)/REAL(RfnMATDIMS(1)*RfnMATDIMS(2)*RfnMATDIMS(3)),4)
       END DO
      END DO
     END DO
    END IF
   ELSE IF(RfnMATDIMS(1).EQ.rCSfDIM1.OR.RfnMATDIMS(1).EQ.reCSfDIM1) THEN
    IF(RfnMATDIMS(1).EQ.rCSfDIM1) THEN
     kCSFFTWfn3D=Kfn
     CALL DFFTW_EXECUTE_DFT_C2R(iCSFFTWPLAN3D,kCSFFTWfn3D,rCSFFTWfn3D)
     DO iD1=1,RfnMATDIMS(1)
      DO iD2=1,RfnMATDIMS(2)
       DO iD3=1,RfnMATDIMS(3)
        Rfn(iD1,iD2,iD3)=REAL(rCSFFTWfn3D(iD1,iD2,iD3)/REAL(RfnMATDIMS(1)*RfnMATDIMS(2)*RfnMATDIMS(3)),4)
       END DO
      END DO
     END DO
    ELSE IF(RfnMATDIMS(1).EQ.reCSfDIM1) THEN
     keCSFFTWfn3D=Kfn
     CALL DFFTW_EXECUTE_DFT_C2R(ieCSFFTWPLAN3D,keCSFFTWfn3D,reCSFFTWfn3D)
     DO iD1=1,RfnMATDIMS(1)
      DO iD2=1,RfnMATDIMS(2)
       DO iD3=1,RfnMATDIMS(3)
        Rfn(iD1,iD2,iD3)=REAL(reCSFFTWfn3D(iD1,iD2,iD3)/REAL(RfnMATDIMS(1)*RfnMATDIMS(2)*RfnMATDIMS(3)),4)
       END DO
      END DO
     END DO
    END IF
   END IF
  END IF

  RETURN
 END SUBROUTINE c8r4iFFTW3D

!****************************************************
!            DISCRETE COSINE TRANSFORM
!****************************************************

 SUBROUTINE CSDCTWSET(DIM1,DIM2,DIM3)
  USE OMP_LIB
  IMPLICIT NONE
  include "fftw3.f"
  INTEGER(4), INTENT(IN)           :: DIM1
  INTEGER(4), INTENT(IN), OPTIONAL :: DIM2, DIM3
  INTEGER(4)                       :: FERROR

  CALL DFFTW_INIT_THREADS(FERROR)
  IF(FERROR.EQ.0) CALL DFFTW_PLAN_WITH_NTHREADS(omp_get_max_threads()/2)
 
   rCSDCTWfDIM1=DIM1
  reCSDCTWfDIM1=DIM1+(DIM1-1)/3

  IF(PRESENT(DIM2)) THEN
    rCSDCTWfDIM2=DIM2
   reCSDCTWfDIM2=DIM2+(DIM2-1)/3
  END IF

  IF(PRESENT(DIM3)) THEN
    rCSDCTWfDIM3=DIM3
   reCSDCTWfDIM3=DIM3+(DIM3-1)/3
  END IF


  IF(PRESENT(DIM3)) THEN
!**************** NORMAL ARRAYS ********************
   CALL DFFTW_DESTROY_PLAN( CSDCTWPLAN3D)
   CALL DFFTW_DESTROY_PLAN(iCSDCTWPLAN3D)
   IF(ALLOCATED(rCSDCTWIfn3D).EQV..TRUE.) THEN
    DEALLOCATE(rCSDCTWIfn3D)
    ALLOCATE(rCSDCTWIfn3D(DIM1,DIM2,DIM3))
   ELSE
    ALLOCATE(rCSDCTWOfn3D(DIM1,DIM2,DIM3))
   END IF
   IF(ALLOCATED(rCSDCTWOfn3D).EQV..TRUE.) THEN
    DEALLOCATE(rCSDCTWOfn3D)
    ALLOCATE(rCSDCTWOfn3D(DIM1,DIM2,DIM3))
   ELSE
    ALLOCATE(rCSDCTWOfn3D(DIM1,DIM2,DIM3))
   END IF
   CALL DFFTW_PLAN_R2R_3D( CSDCTWPLAN3D,DIM1,DIM2,DIM3,rCSDCTWIfn3D,rCSDCTWOfn3D,FFTW_REDFT10,FFTW_REDFT10,FFTW_REDFT10,FFTW_ESTIMATE,FFTW_UNALIGNED)
   CALL DFFTW_PLAN_R2R_3D(iCSDCTWPLAN3D,DIM1,DIM2,DIM3,rCSDCTWIfn3D,rCSDCTWOfn3D,FFTW_REDFT01,FFTW_REDFT01,FFTW_REDFT01,FFTW_ESTIMATE,FFTW_UNALIGNED)
!**************** EXTENDED ARRAYS ********************
   CALL DFFTW_DESTROY_PLAN( eCSDCTWPLAN3D)
   CALL DFFTW_DESTROY_PLAN(ieCSDCTWPLAN3D)
   IF(ALLOCATED(reCSDCTWIfn3D).EQV..TRUE.) THEN
    DEALLOCATE(reCSDCTWIfn3D)
    ALLOCATE(reCSDCTWIfn3D(reCSDCTWfDIM1,reCSDCTWfDIM2,reCSDCTWfDIM3))
   ELSE
    ALLOCATE(reCSDCTWIfn3D(reCSDCTWfDIM1,reCSDCTWfDIM2,reCSDCTWfDIM3))
   END IF
   IF(ALLOCATED(reCSDCTWOfn3D).EQV..TRUE.) THEN
    DEALLOCATE(reCSDCTWOfn3D)
    ALLOCATE(reCSDCTWOfn3D(reCSDCTWfDIM1,reCSDCTWfDIM2,reCSDCTWfDIM3))
   ELSE
    ALLOCATE(reCSDCTWOfn3D(reCSDCTWfDIM1,reCSDCTWfDIM2,reCSDCTWfDIM3))
   END IF
   CALL DFFTW_PLAN_R2R_3D( eCSDCTWPLAN3D,reCSDCTWfDIM1,reCSDCTWfDIM2,reCSDCTWfDIM3,reCSDCTWIfn3D,reCSDCTWOfn3D,FFTW_REDFT10,FFTW_REDFT10,FFTW_REDFT10,FFTW_ESTIMATE,FFTW_UNALIGNED)
   CALL DFFTW_PLAN_R2R_3D(ieCSDCTWPLAN3D,reCSDCTWfDIM1,reCSDCTWfDIM2,reCSDCTWfDIM3,reCSDCTWIfn3D,reCSDCTWOfn3D,FFTW_REDFT01,FFTW_REDFT01,FFTW_REDFT01,FFTW_ESTIMATE,FFTW_UNALIGNED)
  ELSE IF(PRESENT(DIM2)) THEN
!**************** NORMAL ARRAYS ********************
   CALL DFFTW_DESTROY_PLAN( CSDCTWPLAN2D)
   CALL DFFTW_DESTROY_PLAN(iCSDCTWPLAN2D)
   IF(ALLOCATED(rCSDCTWIfn2D).EQV..TRUE.) THEN
    DEALLOCATE(rCSDCTWIfn2D)
    ALLOCATE(rCSDCTWIfn2D(DIM1,DIM2))
   ELSE
    ALLOCATE(rCSDCTWIfn2D(DIM1,DIM2))
   END IF
   IF(ALLOCATED(rCSDCTWOfn2D).EQV..TRUE.) THEN
    DEALLOCATE(rCSDCTWOfn2D)
    ALLOCATE(rCSDCTWOfn2D(DIM1,DIM2))
   ELSE
    ALLOCATE(rCSDCTWOfn2D(DIM1,DIM2))
   END IF
   CALL DFFTW_PLAN_R2R_2D( CSDCTWPLAN2D,DIM1,DIM2,rCSDCTWIfn2D,rCSDCTWOfn2D,FFTW_REDFT10,FFTW_REDFT10,FFTW_ESTIMATE,FFTW_UNALIGNED)
   CALL DFFTW_PLAN_R2R_2D(iCSDCTWPLAN2D,DIM1,DIM2,rCSDCTWIfn2D,rCSDCTWOfn2D,FFTW_REDFT01,FFTW_REDFT01,FFTW_ESTIMATE,FFTW_UNALIGNED)
!**************** EXTENDED ARRAYS ********************
   CALL DFFTW_DESTROY_PLAN( eCSDCTWPLAN2D)
   CALL DFFTW_DESTROY_PLAN(ieCSDCTWPLAN2D)
   IF(ALLOCATED(reCSDCTWIfn2D).EQV..TRUE.) THEN
    DEALLOCATE(reCSDCTWIfn2D)
    ALLOCATE(reCSDCTWIfn2D(reCSDCTWfDIM1,reCSDCTWfDIM2))
   ELSE
    ALLOCATE(reCSDCTWIfn2D(reCSDCTWfDIM1,reCSDCTWfDIM2))
   END IF
   IF(ALLOCATED(reCSDCTWOfn2D).EQV..TRUE.) THEN
    DEALLOCATE(reCSDCTWOfn2D)
    ALLOCATE(reCSDCTWOfn2D(reCSDCTWfDIM1,reCSDCTWfDIM2))
   ELSE
    ALLOCATE(reCSDCTWOfn2D(reCSDCTWfDIM1,reCSDCTWfDIM2))
   END IF
   CALL DFFTW_PLAN_R2R_2D( eCSDCTWPLAN2D,reCSDCTWfDIM1,reCSDCTWfDIM2,reCSDCTWIfn2D,reCSDCTWOfn2D,FFTW_REDFT10,FFTW_REDFT10,FFTW_ESTIMATE,FFTW_UNALIGNED)
   CALL DFFTW_PLAN_R2R_2D(ieCSDCTWPLAN2D,reCSDCTWfDIM1,reCSDCTWfDIM2,reCSDCTWIfn2D,reCSDCTWOfn2D,FFTW_REDFT01,FFTW_REDFT01,FFTW_ESTIMATE,FFTW_UNALIGNED)
  ELSE
!**************** NORMAL ARRAYS ********************
   CALL DFFTW_DESTROY_PLAN( CSFFTWPLAN1D)
   CALL DFFTW_DESTROY_PLAN(iCSFFTWPLAN1D)
   IF(ALLOCATED(rCSDCTWIfn1D).EQV..TRUE.) THEN
    DEALLOCATE(rCSDCTWIfn1D)
    ALLOCATE(rCSDCTWIfn1D(DIM1))
   ELSE
    ALLOCATE(rCSDCTWIfn1D(DIM1))
   END IF
   IF(ALLOCATED(rCSDCTWOfn1D).EQV..TRUE.) THEN
    DEALLOCATE(rCSDCTWOfn1D)
    ALLOCATE(rCSDCTWOfn1D(DIM1))
   ELSE
    ALLOCATE(rCSDCTWOfn1D(DIM1))
   END IF
   CALL DFFTW_PLAN_R2R_1D( CSDCTWPLAN1D,DIM1,rCSDCTWIfn1D,rCSDCTWOfn1D,FFTW_REDFT10,FFTW_ESTIMATE,FFTW_UNALIGNED)
   CALL DFFTW_PLAN_R2R_1D(iCSDCTWPLAN1D,DIM1,rCSDCTWIfn1D,rCSDCTWOfn1D,FFTW_REDFT01,FFTW_ESTIMATE,FFTW_UNALIGNED)
!**************** EXTENDED ARRAYS ********************
   CALL DFFTW_DESTROY_PLAN( eCSFFTWPLAN1D)
   CALL DFFTW_DESTROY_PLAN(ieCSFFTWPLAN1D)
   IF(ALLOCATED(reCSDCTWIfn1D).EQV..TRUE.) THEN
    DEALLOCATE(reCSDCTWIfn1D)
    ALLOCATE(reCSDCTWIfn1D(reCSDCTWfDIM1))
   ELSE
    ALLOCATE(reCSDCTWIfn1D(reCSDCTWfDIM1))
   END IF
   IF(ALLOCATED(reCSDCTWOfn1D).EQV..TRUE.) THEN
    DEALLOCATE(reCSDCTWOfn1D)
    ALLOCATE(reCSDCTWOfn1D(reCSDCTWfDIM1))
   ELSE
    ALLOCATE(reCSDCTWOfn1D(reCSDCTWfDIM1))
   END IF
   CALL DFFTW_PLAN_R2R_1D( eCSDCTWPLAN1D,reCSDCTWfDIM1,reCSDCTWIfn1D,reCSDCTWOfn1D,FFTW_REDFT10,FFTW_ESTIMATE,FFTW_UNALIGNED)
   CALL DFFTW_PLAN_R2R_1D(ieCSDCTWPLAN1D,reCSDCTWfDIM1,reCSDCTWIfn1D,reCSDCTWOfn1D,FFTW_REDFT01,FFTW_ESTIMATE,FFTW_UNALIGNED)
  END IF

  RETURN
 END SUBROUTINE CSDCTWSET

 SUBROUTINE r4r4DCTW1D(Ifn,Ofn)
  IMPLICIT NONE
  include "fftw3.f"
  REAL(4),     INTENT(IN)             :: Ifn(:)
  REAL(4),     INTENT(OUT)            :: Ofn(:)
  INTEGER(4)                          :: RfnMATDIMS
  INTEGER(4)                          :: iD1

  RfnMATDIMS=SIZE(Ofn)

  IF(RfnMATDIMS.EQ.rCSDCTWfDIM1.OR.RfnMATDIMS.EQ.reCSDCTWfDIM1) THEN
   IF(RfnMATDIMS.EQ.rCSDCTWfDIM1) THEN
    rCSDCTWIfn1D=1.0d0*Ifn
    CALL DFFTW_EXECUTE_R2R( CSDCTWPLAN1D,rCSDCTWIfn1D,rCSDCTWOfn1D)
    DO iD1=1,SIZE(Ofn)
     Ofn(iD1)=REAL(rCSDCTWOfn1D(iD1),4)
    END DO
   ELSE IF(RfnMATDIMS.EQ.reCSDCTWfDIM1) THEN
    reCSDCTWIfn1D=1.0d0*Ifn
    CALL DFFTW_EXECUTE_R2R( eCSDCTWPLAN1D,reCSDCTWIfn1D,reCSDCTWOfn1D)
    DO iD1=1,SIZE(Ofn)
     Ofn(iD1)=REAL(reCSDCTWOfn1D(iD1),4)
    END DO
   END IF
  ELSE
   CALL CSDCTWSET(RfnMATDIMS)
   IF(RfnMATDIMS.EQ.rCSDCTWfDIM1) THEN
    rCSDCTWIfn1D=1.0d0*Ifn
    CALL DFFTW_EXECUTE_R2R( CSDCTWPLAN1D,rCSDCTWIfn1D,rCSDCTWOfn1D)
    DO iD1=1,SIZE(Ofn)
     Ofn(iD1)=REAL(rCSDCTWOfn1D(iD1),4)
    END DO
   ELSE IF(RfnMATDIMS.EQ.reCSDCTWfDIM1) THEN
    reCSDCTWIfn1D=1.0d0*Ifn
    CALL DFFTW_EXECUTE_R2R( eCSDCTWPLAN1D,reCSDCTWIfn1D,reCSDCTWOfn1D)
    DO iD1=1,SIZE(Ofn)
     Ofn(iD1)=REAL(reCSDCTWOfn1D(iD1),4)
    END DO
   END IF
  END IF

  RETURN
 END SUBROUTINE r4r4DCTW1D

 SUBROUTINE r8r8DCTW1D(Ifn,Ofn)
  IMPLICIT NONE
  include "fftw3.f"
  REAL(8),     INTENT(IN)             :: Ifn(:)
  REAL(8),     INTENT(OUT)            :: Ofn(:)
  INTEGER(4)                          :: RfnMATDIMS

  RfnMATDIMS=SIZE(Ofn)

  IF(RfnMATDIMS.EQ.rCSDCTWfDIM1.OR.RfnMATDIMS.EQ.reCSDCTWfDIM1) THEN
   IF(RfnMATDIMS.EQ.rCSDCTWfDIM1) THEN
    rCSDCTWIfn1D=Ifn
    CALL DFFTW_EXECUTE_R2R( CSDCTWPLAN1D,rCSDCTWIfn1D,rCSDCTWOfn1D)
    Ofn=rCSDCTWOfn1D
   ELSE IF(RfnMATDIMS.EQ.reCSDCTWfDIM1) THEN
    reCSDCTWIfn1D=Ifn
    CALL DFFTW_EXECUTE_R2R( eCSDCTWPLAN1D,reCSDCTWIfn1D,reCSDCTWOfn1D)
    Ofn=reCSDCTWOfn1D
   END IF
  ELSE
   CALL CSDCTWSET(RfnMATDIMS)
   IF(RfnMATDIMS.EQ.rCSDCTWfDIM1) THEN
    rCSDCTWIfn1D=Ifn
    CALL DFFTW_EXECUTE_R2R( CSDCTWPLAN1D,rCSDCTWIfn1D,rCSDCTWOfn1D)
    Ofn=rCSDCTWOfn1D
   ELSE IF(RfnMATDIMS.EQ.reCSDCTWfDIM1) THEN
    reCSDCTWIfn1D=Ifn
    CALL DFFTW_EXECUTE_R2R( eCSDCTWPLAN1D,reCSDCTWIfn1D,reCSDCTWOfn1D)
    Ofn=reCSDCTWOfn1D
   END IF
  END IF

  RETURN
 END SUBROUTINE r8r8DCTW1D


 SUBROUTINE r4r4iDCTW1D(Ifn,Ofn)
  IMPLICIT NONE
  include "fftw3.f"
  REAL(4),     INTENT(IN)             :: Ifn(:)
  REAL(4),     INTENT(OUT)            :: Ofn(:)
  INTEGER(4)                          :: RfnMATDIMS
  INTEGER(4)                          :: iD1

  RfnMATDIMS=SIZE(Ofn)

  IF(RfnMATDIMS.EQ.rCSDCTWfDIM1.OR.RfnMATDIMS.EQ.reCSDCTWfDIM1) THEN
   IF(RfnMATDIMS.EQ.rCSDCTWfDIM1) THEN
    rCSDCTWIfn1D=1.0d0*Ifn
    CALL DFFTW_EXECUTE_R2R(iCSDCTWPLAN1D,rCSDCTWIfn1D,rCSDCTWOfn1D)
    DO iD1=1,SIZE(Ofn)
     Ofn(iD1)=REAL(rCSDCTWOfn1D(iD1),4)
    END DO
   ELSE IF(RfnMATDIMS.EQ.reCSDCTWfDIM1) THEN
    reCSDCTWIfn1D=1.0d0*Ifn
    CALL DFFTW_EXECUTE_R2R(ieCSDCTWPLAN1D,reCSDCTWIfn1D,reCSDCTWOfn1D)
    DO iD1=1,SIZE(Ofn)
     Ofn(iD1)=REAL(reCSDCTWOfn1D(iD1),4)
    END DO
   END IF
  ELSE
   CALL CSDCTWSET(RfnMATDIMS)
   IF(RfnMATDIMS.EQ.rCSDCTWfDIM1) THEN
    rCSDCTWIfn1D=1.0d0*Ifn
    CALL DFFTW_EXECUTE_R2R(iCSDCTWPLAN1D,rCSDCTWIfn1D,rCSDCTWOfn1D)
    DO iD1=1,SIZE(Ofn)
     Ofn(iD1)=REAL(rCSDCTWOfn1D(iD1),4)
    END DO
   ELSE IF(RfnMATDIMS.EQ.reCSDCTWfDIM1) THEN
    reCSDCTWIfn1D=1.0d0*Ifn
    CALL DFFTW_EXECUTE_R2R(ieCSDCTWPLAN1D,reCSDCTWIfn1D,reCSDCTWOfn1D)
    DO iD1=1,SIZE(Ofn)
     Ofn(iD1)=REAL(reCSDCTWOfn1D(iD1),4)
    END DO
   END IF
  END IF

  RETURN
 END SUBROUTINE r4r4iDCTW1D

 SUBROUTINE r8r8iDCTW1D(Ifn,Ofn)
  IMPLICIT NONE
  include "fftw3.f"
  REAL(8),     INTENT(IN)             :: Ifn(:)
  REAL(8),     INTENT(OUT)            :: Ofn(:)
  INTEGER(4)                          :: RfnMATDIMS

  RfnMATDIMS=SIZE(Ofn)

  IF(RfnMATDIMS.EQ.rCSDCTWfDIM1.OR.RfnMATDIMS.EQ.reCSDCTWfDIM1) THEN
   IF(RfnMATDIMS.EQ.rCSDCTWfDIM1) THEN
    rCSDCTWIfn1D=Ifn
    CALL DFFTW_EXECUTE_R2R(iCSDCTWPLAN1D,rCSDCTWIfn1D,rCSDCTWOfn1D)
    Ofn=rCSDCTWOfn1D
   ELSE IF(RfnMATDIMS.EQ.reCSDCTWfDIM1) THEN
    reCSDCTWIfn1D=Ifn
    CALL DFFTW_EXECUTE_R2R(ieCSDCTWPLAN1D,reCSDCTWIfn1D,reCSDCTWOfn1D)
    Ofn=reCSDCTWOfn1D
   END IF
  ELSE
   CALL CSDCTWSET(RfnMATDIMS)
   IF(RfnMATDIMS.EQ.rCSDCTWfDIM1) THEN
    rCSDCTWIfn1D=Ifn
    CALL DFFTW_EXECUTE_R2R(iCSDCTWPLAN1D,rCSDCTWIfn1D,rCSDCTWOfn1D)
    Ofn=rCSDCTWOfn1D
   ELSE IF(RfnMATDIMS.EQ.reCSDCTWfDIM1) THEN
    reCSDCTWIfn1D=Ifn
    CALL DFFTW_EXECUTE_R2R(ieCSDCTWPLAN1D,reCSDCTWIfn1D,reCSDCTWOfn1D)
    Ofn=reCSDCTWOfn1D
   END IF
  END IF

  RETURN
 END SUBROUTINE r8r8iDCTW1D

 SUBROUTINE r4r4DCTW2D(Ifn,Ofn)
  IMPLICIT NONE
  include "fftw3.f"
  REAL(4),     INTENT(IN)             :: Ifn(:,:)
  REAL(4),     INTENT(OUT)            :: Ofn(:,:)
  INTEGER(4)                          :: RfnMATDIMS(2)
  INTEGER(4)                          :: iD1,iD2

  RfnMATDIMS=SHAPE(Ofn)

  IF(RfnMATDIMS(1).EQ.rCSDCTWfDIM1.OR.RfnMATDIMS(1).EQ.reCSDCTWfDIM1) THEN
   IF(RfnMATDIMS(1).EQ.rCSDCTWfDIM1) THEN
    rCSDCTWIfn2D=1.0d0*Ifn
    CALL DFFTW_EXECUTE_R2R( CSDCTWPLAN2D,rCSDCTWIfn2D,rCSDCTWOfn2D)
    DO iD1=1,RfnMATDIMS(1)
     DO iD2=1,RfnMATDIMS(2)
      Ofn(iD1,iD2)=REAL(rCSDCTWOfn2D(iD1,iD2),4)
     END DO
    END DO
   ELSE IF(RfnMATDIMS(1).EQ.reCSDCTWfDIM1) THEN
    reCSDCTWIfn2D=1.0d0*Ifn
    CALL DFFTW_EXECUTE_R2R( eCSDCTWPLAN2D,reCSDCTWIfn2D,reCSDCTWOfn2D)
    DO iD1=1,RfnMATDIMS(1)
     DO iD2=1,RfnMATDIMS(2)
      Ofn(iD1,iD2)=REAL(reCSDCTWOfn2D(iD1,iD2),4)
     END DO
    END DO
   END IF
  ELSE
   CALL CSDCTWSET(RfnMATDIMS(1),RfnMATDIMS(2))
   IF(RfnMATDIMS(1).EQ.rCSDCTWfDIM1) THEN
    rCSDCTWIfn2D=1.0d0*Ifn
    CALL DFFTW_EXECUTE_R2R( CSDCTWPLAN2D,rCSDCTWIfn2D,rCSDCTWOfn2D)
    DO iD1=1,RfnMATDIMS(1)
     DO iD2=1,RfnMATDIMS(2)
      Ofn(iD1,iD2)=REAL(rCSDCTWOfn2D(iD1,iD2),4)
     END DO
    END DO
   ELSE IF(RfnMATDIMS(1).EQ.reCSDCTWfDIM1) THEN
    reCSDCTWIfn2D=1.0d0*Ifn
    CALL DFFTW_EXECUTE_R2R( eCSDCTWPLAN2D,reCSDCTWIfn2D,reCSDCTWOfn2D)
    DO iD1=1,RfnMATDIMS(1)
     DO iD2=1,RfnMATDIMS(2)
      Ofn(iD1,iD2)=REAL(reCSDCTWOfn2D(iD1,iD2),4)
     END DO
    END DO
   END IF
  END IF

  RETURN
 END SUBROUTINE r4r4DCTW2D

 SUBROUTINE r8r8DCTW2D(Ifn,Ofn)
  IMPLICIT NONE
  include "fftw3.f"
  REAL(8),     INTENT(IN)             :: Ifn(:,:)
  REAL(8),     INTENT(OUT)            :: Ofn(:,:)
  INTEGER(4)                          :: RfnMATDIMS(2)

  RfnMATDIMS=SHAPE(Ofn)

  IF(RfnMATDIMS(1).EQ.rCSDCTWfDIM1.OR.RfnMATDIMS(1).EQ.reCSDCTWfDIM1) THEN
   IF(RfnMATDIMS(1).EQ.rCSDCTWfDIM1) THEN
    rCSDCTWIfn2D=Ifn
    CALL DFFTW_EXECUTE_R2R( CSDCTWPLAN2D,rCSDCTWIfn2D,rCSDCTWOfn2D)
    Ofn=rCSDCTWOfn2D
   ELSE IF(RfnMATDIMS(1).EQ.reCSDCTWfDIM1) THEN
    reCSDCTWIfn2D=Ifn
    CALL DFFTW_EXECUTE_R2R( eCSDCTWPLAN2D,reCSDCTWIfn2D,reCSDCTWOfn2D)
    Ofn=reCSDCTWOfn2D
   END IF
  ELSE
   CALL CSDCTWSET(RfnMATDIMS(1),RfnMATDIMS(2))
   IF(RfnMATDIMS(1).EQ.rCSDCTWfDIM1) THEN
    rCSDCTWIfn2D=Ifn
    CALL DFFTW_EXECUTE_R2R( CSDCTWPLAN2D,rCSDCTWIfn2D,rCSDCTWOfn2D)
    Ofn=rCSDCTWOfn2D
   ELSE IF(RfnMATDIMS(1).EQ.reCSDCTWfDIM1) THEN
    reCSDCTWIfn2D=Ifn
    CALL DFFTW_EXECUTE_R2R( eCSDCTWPLAN2D,reCSDCTWIfn2D,reCSDCTWOfn2D)
    Ofn=reCSDCTWOfn2D
   END IF
  END IF

  RETURN
 END SUBROUTINE r8r8DCTW2D


 SUBROUTINE r4r4iDCTW2D(Ifn,Ofn)
  IMPLICIT NONE
  include "fftw3.f"
  REAL(4),     INTENT(IN)             :: Ifn(:,:)
  REAL(4),     INTENT(OUT)            :: Ofn(:,:)
  INTEGER(4)                          :: RfnMATDIMS(2)
  INTEGER(4)                          :: iD1,iD2

  RfnMATDIMS=SHAPE(Ofn)

  IF(RfnMATDIMS(1).EQ.rCSDCTWfDIM1.OR.RfnMATDIMS(1).EQ.reCSDCTWfDIM1) THEN
   IF(RfnMATDIMS(1).EQ.rCSDCTWfDIM1) THEN
    rCSDCTWIfn2D=1.0d0*Ifn
    CALL DFFTW_EXECUTE_R2R(iCSDCTWPLAN2D,rCSDCTWIfn2D,rCSDCTWOfn2D)
    DO iD1=1,RfnMATDIMS(1)
     DO iD2=1,RfnMATDIMS(2)
      Ofn(iD1,iD2)=REAL(rCSDCTWOfn2D(iD1,iD2),4)
     END DO
    END DO
   ELSE IF(RfnMATDIMS(1).EQ.reCSDCTWfDIM1) THEN
    reCSDCTWIfn2D=1.0d0*Ifn
    CALL DFFTW_EXECUTE_R2R(ieCSDCTWPLAN2D,reCSDCTWIfn2D,reCSDCTWOfn2D)
    DO iD1=1,RfnMATDIMS(1)
     DO iD2=1,RfnMATDIMS(2)
      Ofn(iD1,iD2)=REAL(reCSDCTWOfn2D(iD1,iD2),4)
     END DO
    END DO
   END IF
  ELSE
   CALL CSDCTWSET(RfnMATDIMS(1),RfnMATDIMS(2))
   IF(RfnMATDIMS(1).EQ.rCSDCTWfDIM1) THEN
    rCSDCTWIfn2D=1.0d0*Ifn
    CALL DFFTW_EXECUTE_R2R(iCSDCTWPLAN2D,rCSDCTWIfn2D,rCSDCTWOfn2D)
    DO iD1=1,RfnMATDIMS(1)
     DO iD2=1,RfnMATDIMS(2)
      Ofn(iD1,iD2)=REAL(rCSDCTWOfn2D(iD1,iD2),4)
     END DO
    END DO
   ELSE IF(RfnMATDIMS(1).EQ.reCSDCTWfDIM1) THEN
    reCSDCTWIfn2D=1.0d0*Ifn
    CALL DFFTW_EXECUTE_R2R(ieCSDCTWPLAN2D,reCSDCTWIfn2D,reCSDCTWOfn2D)
    DO iD1=1,RfnMATDIMS(1)
     DO iD2=1,RfnMATDIMS(2)
      Ofn(iD1,iD2)=REAL(reCSDCTWOfn2D(iD1,iD2),4)
     END DO
    END DO
   END IF
  END IF

  RETURN
 END SUBROUTINE r4r4iDCTW2D

 SUBROUTINE r8r8iDCTW2D(Ifn,Ofn)
  IMPLICIT NONE
  include "fftw3.f"
  REAL(8),     INTENT(IN)             :: Ifn(:,:)
  REAL(8),     INTENT(OUT)            :: Ofn(:,:)
  INTEGER(4)                          :: RfnMATDIMS(2)

  RfnMATDIMS=SHAPE(Ofn)

  IF(RfnMATDIMS(1).EQ.rCSDCTWfDIM1.OR.RfnMATDIMS(1).EQ.reCSDCTWfDIM1) THEN
   IF(RfnMATDIMS(1).EQ.rCSDCTWfDIM1) THEN
    rCSDCTWIfn2D=Ifn
    CALL DFFTW_EXECUTE_R2R(iCSDCTWPLAN2D,rCSDCTWIfn2D,rCSDCTWOfn2D)
    Ofn=rCSDCTWOfn2D
   ELSE IF(RfnMATDIMS(1).EQ.reCSDCTWfDIM1) THEN
    reCSDCTWIfn2D=Ifn
    CALL DFFTW_EXECUTE_R2R(ieCSDCTWPLAN2D,reCSDCTWIfn2D,reCSDCTWOfn2D)
    Ofn=reCSDCTWOfn2D
   END IF
  ELSE
   CALL CSDCTWSET(RfnMATDIMS(1),RfnMATDIMS(2))
   IF(RfnMATDIMS(1).EQ.rCSDCTWfDIM1) THEN
    rCSDCTWIfn2D=Ifn
    CALL DFFTW_EXECUTE_R2R(iCSDCTWPLAN2D,rCSDCTWIfn2D,rCSDCTWOfn2D)
    Ofn=rCSDCTWOfn2D
   ELSE IF(RfnMATDIMS(1).EQ.reCSDCTWfDIM1) THEN
    reCSDCTWIfn2D=Ifn
    CALL DFFTW_EXECUTE_R2R(ieCSDCTWPLAN2D,reCSDCTWIfn2D,reCSDCTWOfn2D)
    Ofn=reCSDCTWOfn2D
   END IF
  END IF

  RETURN
 END SUBROUTINE r8r8iDCTW2D

 SUBROUTINE r4r4DCTW3D(Ifn,Ofn)
  IMPLICIT NONE
  include "fftw3.f"
  REAL(4),     INTENT(IN)             :: Ifn(:,:,:)
  REAL(4),     INTENT(OUT)            :: Ofn(:,:,:)
  INTEGER(4)                          :: RfnMATDIMS(3)
  INTEGER(4)                          :: iD1,iD2,iD3

  RfnMATDIMS=SHAPE(Ofn)

  IF(RfnMATDIMS(1).EQ.rCSDCTWfDIM1.OR.RfnMATDIMS(1).EQ.reCSDCTWfDIM1) THEN
   IF(RfnMATDIMS(1).EQ.rCSDCTWfDIM1) THEN
    rCSDCTWIfn3D=1.0d0*Ifn
    CALL DFFTW_EXECUTE_R2R( CSDCTWPLAN3D,rCSDCTWIfn3D,rCSDCTWOfn3D)
    DO iD1=1,RfnMATDIMS(1)
     DO iD2=1,RfnMATDIMS(2)
      DO iD3=1,RfnMATDIMS(3)
       Ofn(iD1,iD2,iD3)=REAL(rCSDCTWOfn3D(iD1,iD2,iD3),4)
      END DO
     END DO
    END DO
   ELSE IF(RfnMATDIMS(1).EQ.reCSDCTWfDIM1) THEN
    reCSDCTWIfn3D=1.0d0*Ifn
    CALL DFFTW_EXECUTE_R2R( eCSDCTWPLAN3D,reCSDCTWIfn3D,reCSDCTWOfn3D)
    DO iD1=1,RfnMATDIMS(1)
     DO iD2=1,RfnMATDIMS(2)
      DO iD3=1,RfnMATDIMS(3)
       Ofn(iD1,iD2,iD3)=REAL(reCSDCTWOfn3D(iD1,iD2,iD3),4)
      END DO
     END DO
    END DO
   END IF
  ELSE
   CALL CSDCTWSET(RfnMATDIMS(1),RfnMATDIMS(2),RfnMATDIMS(3))
   IF(RfnMATDIMS(1).EQ.rCSDCTWfDIM1) THEN
    rCSDCTWIfn3D=1.0d0*Ifn
    CALL DFFTW_EXECUTE_R2R( CSDCTWPLAN3D,rCSDCTWIfn3D,rCSDCTWOfn3D)
    DO iD1=1,RfnMATDIMS(1)
     DO iD2=1,RfnMATDIMS(2)
      DO iD3=1,RfnMATDIMS(3)
       Ofn(iD1,iD2,iD3)=REAL(rCSDCTWOfn3D(iD1,iD2,iD3),4)
      END DO
     END DO
    END DO
   ELSE IF(RfnMATDIMS(1).EQ.reCSDCTWfDIM1) THEN
    reCSDCTWIfn3D=1.0d0*Ifn
    CALL DFFTW_EXECUTE_R2R( eCSDCTWPLAN3D,reCSDCTWIfn3D,reCSDCTWOfn3D)
    DO iD1=1,RfnMATDIMS(1)
     DO iD2=1,RfnMATDIMS(2)
      DO iD3=1,RfnMATDIMS(3)
       Ofn(iD1,iD2,iD3)=REAL(reCSDCTWOfn3D(iD1,iD2,iD3),4)
      END DO
     END DO
    END DO
   END IF
  END IF

  RETURN
 END SUBROUTINE r4r4DCTW3D

 SUBROUTINE r8r8DCTW3D(Ifn,Ofn)
  IMPLICIT NONE
  include "fftw3.f"
  REAL(8),     INTENT(IN)             :: Ifn(:,:,:)
  REAL(8),     INTENT(OUT)            :: Ofn(:,:,:)
  INTEGER(4)                          :: RfnMATDIMS(3)

  RfnMATDIMS=SHAPE(Ofn)

  IF(RfnMATDIMS(1).EQ.rCSDCTWfDIM1.OR.RfnMATDIMS(1).EQ.reCSDCTWfDIM1) THEN
   IF(RfnMATDIMS(1).EQ.rCSDCTWfDIM1) THEN
    rCSDCTWIfn3D=Ifn
    CALL DFFTW_EXECUTE_R2R( CSDCTWPLAN3D,rCSDCTWIfn3D,rCSDCTWOfn3D)
    Ofn=rCSDCTWOfn3D
   ELSE IF(RfnMATDIMS(1).EQ.reCSDCTWfDIM1) THEN
    reCSDCTWIfn3D=Ifn
    CALL DFFTW_EXECUTE_R2R( eCSDCTWPLAN3D,reCSDCTWIfn3D,reCSDCTWOfn3D)
    Ofn=reCSDCTWOfn3D
   END IF
  ELSE
   CALL CSDCTWSET(RfnMATDIMS(1),RfnMATDIMS(2),RfnMATDIMS(3))
   IF(RfnMATDIMS(1).EQ.rCSDCTWfDIM1) THEN
    rCSDCTWIfn3D=Ifn
    CALL DFFTW_EXECUTE_R2R( CSDCTWPLAN3D,rCSDCTWIfn3D,rCSDCTWOfn3D)
    Ofn=rCSDCTWOfn3D
   ELSE IF(RfnMATDIMS(1).EQ.reCSDCTWfDIM1) THEN
    reCSDCTWIfn3D=Ifn
    CALL DFFTW_EXECUTE_R2R( eCSDCTWPLAN3D,reCSDCTWIfn3D,reCSDCTWOfn3D)
    Ofn=reCSDCTWOfn3D
   END IF
  END IF

  RETURN
 END SUBROUTINE r8r8DCTW3D


 SUBROUTINE r4r4iDCTW3D(Ifn,Ofn)
  IMPLICIT NONE
  include "fftw3.f"
  REAL(4),     INTENT(IN)             :: Ifn(:,:,:)
  REAL(4),     INTENT(OUT)            :: Ofn(:,:,:)
  INTEGER(4)                          :: RfnMATDIMS(3)
  INTEGER(4)                          :: iD1,iD2,iD3

  RfnMATDIMS=SHAPE(Ofn)

  IF(RfnMATDIMS(1).EQ.rCSDCTWfDIM1.OR.RfnMATDIMS(1).EQ.reCSDCTWfDIM1) THEN
   IF(RfnMATDIMS(1).EQ.rCSDCTWfDIM1) THEN
    rCSDCTWIfn3D=1.0d0*Ifn
    CALL DFFTW_EXECUTE_R2R(iCSDCTWPLAN3D,rCSDCTWIfn3D,rCSDCTWOfn3D)
    DO iD1=1,RfnMATDIMS(1)
     DO iD2=1,RfnMATDIMS(2)
      DO iD3=1,RfnMATDIMS(3)
       Ofn(iD1,iD2,iD3)=REAL(rCSDCTWOfn3D(iD1,iD2,iD3),4)
      END DO
     END DO
    END DO
   ELSE IF(RfnMATDIMS(1).EQ.reCSDCTWfDIM1) THEN
    reCSDCTWIfn3D=1.0d0*Ifn
    CALL DFFTW_EXECUTE_R2R(ieCSDCTWPLAN3D,reCSDCTWIfn3D,reCSDCTWOfn3D)
    DO iD1=1,RfnMATDIMS(1)
     DO iD2=1,RfnMATDIMS(2)
      DO iD3=1,RfnMATDIMS(3)
       Ofn(iD1,iD2,iD3)=REAL(reCSDCTWOfn3D(iD1,iD2,iD3),4)
      END DO
     END DO
    END DO
   END IF
  ELSE
   CALL CSDCTWSET(RfnMATDIMS(1),RfnMATDIMS(2),RfnMATDIMS(3))
   IF(RfnMATDIMS(1).EQ.rCSDCTWfDIM1) THEN
    rCSDCTWIfn3D=1.0d0*Ifn
    CALL DFFTW_EXECUTE_R2R(iCSDCTWPLAN3D,rCSDCTWIfn3D,rCSDCTWOfn3D)
    DO iD1=1,RfnMATDIMS(1)
     DO iD2=1,RfnMATDIMS(2)
      DO iD3=1,RfnMATDIMS(3)
       Ofn(iD1,iD2,iD3)=REAL(rCSDCTWOfn3D(iD1,iD2,iD3),4)
      END DO
     END DO
    END DO
   ELSE IF(RfnMATDIMS(1).EQ.reCSDCTWfDIM1) THEN
    reCSDCTWIfn3D=1.0d0*Ifn
    CALL DFFTW_EXECUTE_R2R(ieCSDCTWPLAN3D,reCSDCTWIfn3D,reCSDCTWOfn3D)
    DO iD1=1,RfnMATDIMS(1)
     DO iD2=1,RfnMATDIMS(2)
      DO iD3=1,RfnMATDIMS(3)
       Ofn(iD1,iD2,iD3)=REAL(reCSDCTWOfn3D(iD1,iD2,iD3),4)
      END DO
     END DO
    END DO
   END IF
  END IF

  RETURN
 END SUBROUTINE r4r4iDCTW3D

 SUBROUTINE r8r8iDCTW3D(Ifn,Ofn)
  IMPLICIT NONE
  include "fftw3.f"
  REAL(8),     INTENT(IN)             :: Ifn(:,:,:)
  REAL(8),     INTENT(OUT)            :: Ofn(:,:,:)
  INTEGER(4)                          :: RfnMATDIMS(3)

  RfnMATDIMS=SHAPE(Ofn)

  IF(RfnMATDIMS(1).EQ.rCSDCTWfDIM1.OR.RfnMATDIMS(1).EQ.reCSDCTWfDIM1) THEN
   IF(RfnMATDIMS(1).EQ.rCSDCTWfDIM1) THEN
    rCSDCTWIfn3D=Ifn
    CALL DFFTW_EXECUTE_R2R(iCSDCTWPLAN3D,rCSDCTWIfn3D,rCSDCTWOfn3D)
    Ofn=rCSDCTWOfn3D
   ELSE IF(RfnMATDIMS(1).EQ.reCSDCTWfDIM1) THEN
    reCSDCTWIfn3D=Ifn
    CALL DFFTW_EXECUTE_R2R(ieCSDCTWPLAN3D,reCSDCTWIfn3D,reCSDCTWOfn3D)
    Ofn=reCSDCTWOfn3D
   END IF
  ELSE
   CALL CSDCTWSET(RfnMATDIMS(1),RfnMATDIMS(2),RfnMATDIMS(3))
   IF(RfnMATDIMS(1).EQ.rCSDCTWfDIM1) THEN
    rCSDCTWIfn3D=Ifn
    CALL DFFTW_EXECUTE_R2R(iCSDCTWPLAN3D,rCSDCTWIfn3D,rCSDCTWOfn3D)
    Ofn=rCSDCTWOfn3D
   ELSE IF(RfnMATDIMS(1).EQ.reCSDCTWfDIM1) THEN
    reCSDCTWIfn3D=Ifn
    CALL DFFTW_EXECUTE_R2R(ieCSDCTWPLAN3D,reCSDCTWIfn3D,reCSDCTWOfn3D)
    Ofn=reCSDCTWOfn3D
   END IF
  END IF

  RETURN
 END SUBROUTINE r8r8iDCTW3D




!**********************************************************************
!****** K-SPACE-(2/3) TO PREVENT THE ALIASING PROBLEM DUE TO FFT ******
!**********************************************************************
 SUBROUTINE C8addFFTalias1D(C8MAT,C8exMAT)
  IMPLICIT NONE
  COMPLEX(8),INTENT(IN)  :: C8MAT(:)
  COMPLEX(8),INTENT(OUT) :: C8exMAT(:)
  INTEGER(4)             :: MATDIMS
  INTEGER(4)             :: D1MAT12,D1MAT13

  MATDIMS=SIZE(C8MAT)
  D1MAT12=MATDIMS
  D1MAT13=((MATDIMS-1)/3)

  C8exMAT=CMPLX(0.0d0,0.0d0)
  C8exMAT(1:D1MAT12)=C8MAT(1:D1MAT12)

  RETURN
 END SUBROUTINE C8addFFTalias1D

 SUBROUTINE C8rmvFFTalias1D(C8exMAT,C8MAT)
  IMPLICIT NONE
  COMPLEX(8),INTENT(IN)  :: C8exMAT(:)
  COMPLEX(8),INTENT(OUT) :: C8MAT(:)
  INTEGER(4)             :: MATDIMS
  INTEGER(4)             :: D1MAT12,D1MAT13

  MATDIMS=SIZE(C8MAT)
  D1MAT12=MATDIMS
  D1MAT13=((MATDIMS-1)/3)

  C8MAT=CMPLX(0.0d0,0.0d0)
  C8MAT(1:D1MAT12)=C8exMAT(1:D1MAT12)

  RETURN
 END SUBROUTINE C8rmvFFTalias1D

 SUBROUTINE C8addFFTalias2D(C8MAT,C8exMAT)
  IMPLICIT NONE
  COMPLEX(8),INTENT(IN)  :: C8MAT(:,:)
  COMPLEX(8),INTENT(OUT) :: C8exMAT(:,:)
  INTEGER(4)             :: MATDIMS(2)
  INTEGER(4)             :: D1MAT12,D1MAT13,D2MAT12,D2MAT13

  MATDIMS=SHAPE(C8MAT)
  D1MAT12=MATDIMS(1)
  D2MAT12=MATDIMS(2)/2+1
  D1MAT13=((MATDIMS(1)-1)/3)
  D2MAT13=((MATDIMS(2)-1)/3)

  C8exMAT=CMPLX(0.0d0,0.0d0)
  C8exMAT(1:D1MAT12,1:D2MAT12)=C8MAT(1:D1MAT12,1:D2MAT12)
  C8exMAT(1:D1MAT12,D2MAT12+D2MAT13+1:MATDIMS(2)+D2MAT13)=C8MAT(1:D1MAT12,D2MAT12+1:MATDIMS(2))

  RETURN
 END SUBROUTINE C8addFFTalias2D

 SUBROUTINE C8rmvFFTalias2D(C8exMAT,C8MAT)
  IMPLICIT NONE
  COMPLEX(8),INTENT(IN)  :: C8exMAT(:,:)
  COMPLEX(8),INTENT(OUT) :: C8MAT(:,:)
  INTEGER(4)             :: MATDIMS(2)
  INTEGER(4)             :: D1MAT12,D1MAT13,D2MAT12,D2MAT13

  MATDIMS=SHAPE(C8MAT)
  D1MAT12=MATDIMS(1)
  D2MAT12=MATDIMS(2)/2+1
  D1MAT13=((MATDIMS(1)-1)/3)
  D2MAT13=((MATDIMS(2)-1)/3)

  C8MAT=CMPLX(0.0d0,0.0d0)
  C8MAT(1:D1MAT12,1:D2MAT12)=C8exMAT(1:D1MAT12,1:D2MAT12)
  C8MAT(1:D1MAT12,D2MAT12+1:MATDIMS(2))=C8exMAT(1:D1MAT12,D2MAT12+D2MAT13+1:MATDIMS(2)+D2MAT13)

  RETURN
 END SUBROUTINE C8rmvFFTalias2D

 SUBROUTINE C8addFFTalias3D(C8MAT,C8exMAT)
  IMPLICIT NONE
  COMPLEX(8),INTENT(IN)  :: C8MAT(:,:,:)
  COMPLEX(8),INTENT(OUT) :: C8exMAT(:,:,:)
  INTEGER(4)             :: MATDIMS(3)
  INTEGER(4)             :: D1MAT12,D1MAT13,D2MAT12,D2MAT13,D3MAT12,D3MAT13

  MATDIMS=SHAPE(C8MAT)
  D1MAT12=MATDIMS(1)
  D2MAT12=MATDIMS(2)/2+1
  D3MAT12=MATDIMS(3)/2+1
  D1MAT13=((MATDIMS(1)-1)/3)
  D2MAT13=((MATDIMS(2)-1)/3)
  D3MAT13=((MATDIMS(3)-1)/3)

  C8exMAT=CMPLX(0.0d0,0.0d0)
  C8exMAT(1:D1MAT12,1:D2MAT12,1:D3MAT12)=C8MAT(1:D1MAT12,1:D2MAT12,1:D3MAT12)
  C8exMAT(1:D1MAT12,D2MAT12+D2MAT13+1:MATDIMS(2)+D2MAT13,1:D3MAT12)=C8MAT(1:D1MAT12,D2MAT12+1:MATDIMS(2),1:D3MAT12)
  C8exMAT(1:D1MAT12,1:D2MAT12,D3MAT12+D3MAT13+1:MATDIMS(3)+D3MAT13)=C8MAT(1:D1MAT12,1:D2MAT12,D3MAT12+1:MATDIMS(3))

  RETURN
 END SUBROUTINE C8addFFTalias3D

 SUBROUTINE C8rmvFFTalias3D(C8exMAT,C8MAT)
  IMPLICIT NONE
  COMPLEX(8),INTENT(IN)  :: C8exMAT(:,:,:)
  COMPLEX(8),INTENT(OUT) :: C8MAT(:,:,:)
  INTEGER(4)             :: MATDIMS(3)
  INTEGER(4)             :: D1MAT12,D1MAT13,D2MAT12,D2MAT13,D3MAT12,D3MAT13

  MATDIMS=SHAPE(C8MAT)
  D1MAT12=MATDIMS(1)
  D2MAT12=MATDIMS(2)/2+1
  D3MAT12=MATDIMS(3)/2+1
  D1MAT13=((MATDIMS(1)-1)/3)
  D2MAT13=((MATDIMS(2)-1)/3)
  D3MAT13=((MATDIMS(3)-1)/3)

  C8MAT=CMPLX(0.0d0,0.0d0)
  C8MAT(1:D1MAT12,1:D2MAT12,1:D3MAT12)=C8exMAT(1:D1MAT12,1:D2MAT12,1:D3MAT12)
  C8MAT(1:D1MAT12,D2MAT12+1:MATDIMS(2),1:D3MAT12)=C8exMAT(1:D1MAT12,D2MAT12+D2MAT13+1:MATDIMS(2)+D2MAT13,1:D3MAT12)
  C8MAT(1:D1MAT12,1:D2MAT12,D3MAT12+1:MATDIMS(3))=C8exMAT(1:D1MAT12,1:D2MAT12,D3MAT12+D3MAT13+1:MATDIMS(3)+D3MAT13)

  RETURN
 END SUBROUTINE C8rmvFFTalias3D

!**************** TRADITIONAL METHOD ******************

 SUBROUTINE C8rmFFTalias1D(C8MAT)
  IMPLICIT NONE
  INTEGER(4) :: MATDIMS(1)
  INTEGER(4) :: D1MAT12,D1MAT23,D2MAT12,D2MAT23
  COMPLEX(8) :: C8MAT(:)

  MATDIMS=SIZE(C8MAT)
  D1MAT12=MATDIMS(1)
  D1MAT23=(2*MATDIMS(1)-2)/3

!****** ENFORCE DE-ALIASING IN K-SPACE MATRIX ******
  C8MAT(1:D1MAT23)=0.0d0
  C8MAT(D1MAT23+1:D1MAT12)=0.0d0
!****** ENFORCE A HERMITIAN IN K-SPACE MATRIX ******
  C8MAT(1)=REAL(C8MAT(1))

  RETURN
 END SUBROUTINE C8rmFFTalias1D

 SUBROUTINE C8rmFFTalias2D(C8MAT)
  IMPLICIT NONE
  INTEGER(4) :: MATDIMS(2)
  INTEGER(4) :: D1MAT12,D1MAT23,D2MAT12,D2MAT23
  COMPLEX(8) :: C8MAT(:,:)

  MATDIMS=SHAPE(C8MAT)
  D1MAT12=MATDIMS(1)
  D2MAT12=MATDIMS(2)/2+1
  D1MAT23=(((2*MATDIMS(1)-2)-1)/3)
  D2MAT23=((MATDIMS(2)-1)/3)

!****** ENFORCE DE-ALIASING IN K-SPACE MATRIX ******
  C8MAT(D1MAT23:D1MAT12,:)=CMPLX(0.0d0,0.0d0)
  C8MAT(1:D1MAT23,D2MAT23:MATDIMS(2)-D2MAT23)=CMPLX(0.0d0,0.0d0)
!****** ENFORCE A HERMITIAN IN K-SPACE MATRIX ******
  C8MAT(1,1)=REAL(C8MAT(1,1),8)
  C8MAT(1,D2MAT12+1:MATDIMS(2))=CONJG(C8MAT(1,D2MAT12-1:2:-1))

  RETURN
 END SUBROUTINE C8rmFFTalias2D

 SUBROUTINE r8rmFFTalias2D(r8MAT)
  IMPLICIT NONE
  INTEGER(4) :: MATDIMS(2)
  INTEGER(4) :: D1MAT12,D1MAT23,D2MAT12,D2MAT23
  REAL(8)    :: r8MAT(:,:)

  MATDIMS=SHAPE(r8MAT)
  D1MAT12=MATDIMS(1)
  D2MAT12=MATDIMS(2)/2+1
  D1MAT23=(((2*MATDIMS(1)-2)-1)/3)
  D2MAT23=((MATDIMS(2)-1)/3)

!****** ENFORCE DE-ALIASING IN K-SPACE MATRIX ******
  r8MAT(D1MAT23:D1MAT12,:)=0.0d0
  r8MAT(1:D1MAT23,D2MAT23:MATDIMS(2)-D2MAT23)=0.0d0
!****** ENFORCE A HERMITIAN IN K-SPACE MATRIX ******
 !r8MAT(1,1)=REAL(r8MAT(1,1),8)
 !r8MAT(1,D2MAT12+1:MATDIMS(2))=CONJG(r8MAT(1,D2MAT12-1:2:-1))

  RETURN
 END SUBROUTINE r8rmFFTalias2D

 SUBROUTINE C8rmFFTalias3D(C8MAT)
  IMPLICIT NONE
  INTEGER(4) :: I3D,MATDIMS(3)
  COMPLEX(8) :: C8MAT(:,:,:)
  
  MATDIMS=SHAPE(C8MAT)

  DO I3D=1,MATDIMS(3)
    CALL rmFFTalias(C8MAT(:,:,I3D))
  END DO

  RETURN
 END SUBROUTINE C8rmFFTalias3D

!********************************************************************
!                  PREPARE THE K-FIELDS MATRICES
!********************************************************************

 SUBROUTINE C8CSARRAY1D(psARRAY,csARRAY)
  IMPLICIT NONE
  COMPLEX(8) :: psARRAY(:),csARRAY(:)
  INTEGER(4) :: MATDIMS(1)
  INTEGER(4) :: D1MAT12,D2MAT12
  INTEGER(4) :: LXDIM

  MATDIMS=SIZE(csARRAY)
  LXDIM=MATDIMS(1)
  D1MAT12=MATDIMS(1)/2+1

  csARRAY(D1MAT12:LXDIM)=psARRAY(1:D1MAT12-1)
  csARRAY(1:D1MAT12-1)=ROT180(CONJG(psARRAY(1:D1MAT12-1)))

 END SUBROUTINE C8CSARRAY1D

 SUBROUTINE C8CSARRAY2D(psARRAY,csARRAY)
  IMPLICIT NONE
  COMPLEX(8) :: psARRAY(:,:),csARRAY(:,:)
  INTEGER(4) :: MATDIMS(2)
  INTEGER(4) :: D1MAT12,D2MAT12
  INTEGER(4) :: LXDIM,LYDIM

  MATDIMS=SHAPE(csARRAY)
  LXDIM=MATDIMS(1)
  LYDIM=MATDIMS(2)
  D1MAT12=MATDIMS(1)/2+1
  D2MAT12=MATDIMS(2)/2+1

  csARRAY(D1MAT12:LXDIM,D2MAT12:LYDIM)=psARRAY(1:D1MAT12-1,1:D2MAT12-1)
  csARRAY(D1MAT12:LXDIM,1:D2MAT12-1)=psARRAY(1:D1MAT12-1,D2MAT12:LYDIM)
  csARRAY(1:D1MAT12-1,1:D2MAT12-1)=ROT180(CONJG(psARRAY(1:D1MAT12-1,1:D2MAT12-1)))
  csARRAY(1:D1MAT12-1,D2MAT12:LYDIM)=ROT180(CONJG(psARRAY(1:D1MAT12-1,D2MAT12:LYDIM)))

 END SUBROUTINE C8CSARRAY2D

 SUBROUTINE C8CSARRAY3D(psARRAY,csARRAY)
  IMPLICIT NONE
  COMPLEX(8) :: psARRAY(:,:,:),csARRAY(:,:,:)
  INTEGER(4) :: MATDIMS(3)
  INTEGER(4) :: D1MAT12,D2MAT12,D3MAT12
  INTEGER(4) :: LXDIM,LYDIM,LZDIM

  MATDIMS=SHAPE(csARRAY)
  LXDIM=MATDIMS(1)
  LYDIM=MATDIMS(2)
  LXDIM=MATDIMS(3)
  D1MAT12=MATDIMS(1)/2+1
  D2MAT12=MATDIMS(2)/2+1
  D3MAT12=MATDIMS(3)/2+1

  csARRAY(D1MAT12:LXDIM,D2MAT12:LYDIM,1)=psARRAY(1:D1MAT12-1,1:D2MAT12-1,1)
  csARRAY(D1MAT12:LXDIM,1:D2MAT12-1,1)=psARRAY(1:D1MAT12-1,D2MAT12:LYDIM,1)
  csARRAY(1:D1MAT12-1,1:D2MAT12-1,1)=ROT180(CONJG(psARRAY(1:D1MAT12-1,1:D2MAT12-1,1)))
  csARRAY(1:D1MAT12-1,D2MAT12:LYDIM,1)=ROT180(CONJG(psARRAY(1:D1MAT12-1,D2MAT12:LYDIM,1)))

 END SUBROUTINE C8CSARRAY3D


END MODULE DOPERATORS

