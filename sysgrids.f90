MODULE SYSGRIDS
 USE FORTGRAPHER
 USE GEOAXES
 USE SYSINFO

 INTERFACE GEODSTNBTWN
  MODULE PROCEDURE R4GEODSTNBTWN,R8GEODSTNBTWN
 END INTERFACE GEODSTNBTWN

 INTERFACE GEOBEARINGBTWN 
  MODULE PROCEDURE R4GEOBEARINGBTWN,R8GEOBEARINGBTWN
 END INTERFACE GEOBEARINGBTWN

 CONTAINS


 SUBROUTINE GRIDBUILDER
  IMPLICIT NONE
  REAL(8), PARAMETER   :: PI=4.0d0*ATAN(1.0d0)
  REAL(4), ALLOCATABLE :: tX1D(:),tY1D(:),tZ1D(:)
  REAL(4)              :: xDST,yDST
  REAL(4)              :: R,BEARNG
  INTEGER(4)           :: iXDIM,iYDIM,iZDIM
  INTEGER(4)           :: nLAT,nLON,nALT
  INTEGER(4)           :: iLAT,iLON,iALT

  nLAT=XDIM;nLON=YDIM;nALT=ZDIM

  IF(ALLOCATED(X1D)) DEALLOCATE(X1D)
  IF(ALLOCATED(Y1D)) DEALLOCATE(Y1D)
  IF(ALLOCATED(Z1D)) DEALLOCATE(Z1D)
  ALLOCATE(X1D(XDIM))
  ALLOCATE(Y1D(YDIM))
  ALLOCATE(Z1D(ZDIM))

  IF(ALLOCATED(X3D)) DEALLOCATE(X3D)
  IF(ALLOCATED(Y3D)) DEALLOCATE(Y3D)
  IF(ALLOCATED(Z3D)) DEALLOCATE(Z3D)
  ALLOCATE(X3D(XDIM,YDIM,ZDIM))
  ALLOCATE(Y3D(XDIM,YDIM,ZDIM))
  ALLOCATE(Z3D(XDIM,YDIM,ZDIM))

  IF(EQUISPACED.AND.RECTGRID) THEN
   CALL LINVECTOR(Xsrt,Xend,XDIM,X1D)
   CALL LINVECTOR(Ysrt,Yend,YDIM,Y1D)
   CALL LINVECTOR(Zsrt,Zend,ZDIM,Z1D)
   CALL MESHGRID(X1D,Y1D,Z1D,X3D,Y3D,Z3D)
   IF(ALLOCATED(X1D)) DEALLOCATE(X1D)
   IF(ALLOCATED(Y1D)) DEALLOCATE(Y1D)
   IF(ALLOCATED(Z1D)) DEALLOCATE(Z1D)

   IF(GEOGRAPHICGRID) THEN
!******** BUILDING THE ALT(Z)-DIMESNION GRID ***********
    IF(ALLOCATED(ALT1D)) DEALLOCATE(ALT1D)
    ALLOCATE(ALT1D(nALT))
   !IF(ALLOCATED(ALT3D)) DEALLOCATE(ALT3D)
   !ALLOCATE(ALT3D(nLAT,nLON,nALT))
    IF(nALT.GT.1) THEN
     DO iALT=1,nALT
      ALT1D(iALT)=srtALT+1.0d-3*Z3D(1,1,iALT)
     END DO
    !DO iLAT=1,nLAT
    ! DO iLON=1,nLON
    !  ALT3D(iLAT,iLON,:)=ALT1D
    ! END DO
    !END DO
    ELSE IF(nALT.EQ.1) THEN
     ALT1D=srtALT
    !DO iLAT=1,nLAT
    ! DO iLON=1,nLON
    !  ALT3D(iLAT,iLON,:)=srtALT
    ! END DO
    !END DO
    END IF

!******** BUILDING THE LAT(X)-DIMESNION GRID ***********
    IF(ALLOCATED(LAT1D)) DEALLOCATE(LAT1D)
    ALLOCATE(LAT1D(nLAT))
   !IF(ALLOCATED(LAT3D)) DEALLOCATE(LAT3D)
   !ALLOCATE(LAT3D(nLAT,nLON,nALT))
    IF(nLAT.GT.1) THEN
     xDST=(X3D(2,1,1)-X3D(1,1,1))*1.0e-3
     BEARNG=GEOBEARINGBTWN(srtLAT,endLAT,srtLON,srtLON)
     DO iALT=1,nALT
      R=RE+ALT1D(iALT)
      LAT1D(1)=srtLAT 
      DO iLAT=2,nLAT
       LAT1D(iLAT)=RAD2DEG(ASIN(SIN(DEG2RAD(LAT1D(iLAT-1)))*COS(xDST/R)+COS(DEG2RAD(LAT1D(iLAT-1)))*SIN(xDST/R)*COS(BEARNG)))
      END DO
     !DO iLON=1,nLON
     ! LAT3D(:,iLON,iALT)=LAT1D
     !END DO
     END DO
    ELSE IF(nLAT.EQ.1) THEN
     LAT1D=srtLAT
    !DO iALT=1,nALT
    ! DO iLON=1,nLON
    !  ALT3D(:,iLON,iALT)=srtLAT
    ! END DO
    !END DO
    END IF

!******** BUILDING THE LON(Y)-DIMESNION GRID ***********
    IF(ALLOCATED(LON1D)) DEALLOCATE(LON1D)
    ALLOCATE(LON1D(nLON))
   !IF(ALLOCATED(LON3D)) DEALLOCATE(LON3D)
   !ALLOCATE(LON3D(nLAT,nLON,nALT))
    IF(nLON.GT.1) THEN
     yDST=(Y3D(1,2,1)-Y3D(1,1,1))*1.0e-3
     BEARNG=GEOBEARINGBTWN(srtLAT,srtLAT,srtLON,endLON)
     DO iALT=1,nALT
      R=RE+ALT1D(iALT)
      LON1D(1)=srtLON
      DO iLON=2,nLON
       LON1D(iLON)=LON1D(iLON-1)+RAD2DEG(ATAN2(SIN(yDST/R)*COS(DEG2RAD(srtLAT))*SIN(BEARNG),COS(yDST/R)-SIN(DEG2RAD(srtLAT))**2))
      END DO
     !DO iLAT=1,nLAT
     ! LON3D(iLAT,:,iALT)=LON1D
     !END DO
     END DO
    ELSE IF(nLON.EQ.1) THEN
     LON1D=srtLON
    !DO iALT=1,nALT
    ! DO iLAT=1,nLAT
    !  ALT3D(iLAT,:,iALT)=srtLON
    ! END DO
    !END DO
    END IF

   END IF
   PRINT*, "EQUISPACED R-SPACE 3D GRIDS BUILDING >>> DONE!"

  ELSE IF(CHEBYSHEVSPACED.AND.RECTGRID) THEN
   DO iXDIM=1,XDIM
    X1D(iXDIM)=COS((2.0d0*iXDIM-1.0d0)*PI/(2.0d0*XDIM))
   END DO
   X1D=1.0d0*((Xend-Xsrt)*X1D+(Xend+Xsrt))/2.0d0
   DO iYDIM=1,YDIM
    Y1D(iYDIM)=COS((2.0d0*iYDIM-1.0d0)*PI/(2.0d0*YDIM))
   END DO
   Y1D=1.0d0*((Yend-Ysrt)*Y1D+(Yend+Ysrt))/2.0d0
   DO IZDIM=1,ZDIM
    Z1D(iZDIM)=COS((2.0d0*iZDIM-1.0d0)*PI/(2.0d0*ZDIM))
   END DO
   Z1D=1.0d0*((Zend-Zsrt)*Z1D+(Zend+Zsrt))/2.0d0

   CALL MESHGRID(X1D,Y1D,Z1D,X3D,Y3D,Z3D)
   PRINT*, "CHEBYSHEV R-SPACE 3D GRIDS BUILDING >>> DONE!"
  END IF

  RETURN
 END SUBROUTINE GRIDBUILDER

!FUNCTION FINDLONBEARING(sLAT,sLON,R,d,TOL)
! IMPLICIT NONE
! REAL(4)            :: FINDLONBEARING
! REAL(4),INTENT(IN) :: sLAT,sLON,R,d
! REAL(4),OPTIONAL   :: TOL
! REAL(4)            :: eLON
! REAL(4)            :: sBEARING,eBEARING,tBEARING
! INTEGER(4)         :: ICOUNTER=0

! IF(PRESENT(TOL)) THEN
!  tBEARING=TOL
! ELSE
!  tBEARING=1.e-6
! END IF

! eBEARING=10.0
! sBEARING=0.0
! DO WHILE(ABS(eBEARING-sBEARING).LE.tBEARING)
!  sBEARING=eBEARING
!  eLON=sLON+RAD2DEG(ATAN2(SIN(d/R)*COS(DEG2RAD(sLAT))*SIN(sBEARING),COS(d/R)-SIN(DEG2RAD(sLAT))**2))
!  eBEARING=GEOBEARINGBTWN(sLAT,sLAT,sLON,eLON)
!  ICOUNTER=ICOUNTER+1
!  PRINT*, ICOUNTER,sBEARING,eBEARING
! END DO
! FINDLONBEARING=eBEARING
  
! RETURN
!END FUNCTION FINDLONBEARING


!**********************************************************
!************* BUILD THE UNIVERSAL TIME MATRIX ************
!**********************************************************
 SUBROUTINE DTLTMAT
  IMPLICIT NONE
  INTEGER(4) :: srtLTHUR,srtLTMIN,srtLTSEC
  INTEGER(4) :: endLTHUR,endLTMIN,endLTSEC
  INTEGER(4) :: stpLTHUR,stpLTMIN,stpLTSEC
  INTEGER(4) :: srtYYYY,srtMM,srtDD,srtMMDD
  INTEGER(4) :: endYYYY,endMM,endDD,endMMDD

  INTEGER(4) :: TEMPNUM1,TEMPNUM2,TEMPNUM3
  INTEGER(4) :: srtDY,endDY,NRDAYMON
  INTEGER(4) :: NoY,TNoD,CurrentYYYY
  INTEGER(4) :: I,J,K,L,srtJ,endJ,ICOUNTER
  INTEGER(4),ALLOCATABLE :: DoY(:)

  IF(srtLT.LT.0.OR.srtLT.GT.240000) THEN
    WRITE(*,*) "START LOCAL TIME MUST BE BETWEEN 0 AND 240000"
    RETURN
  END IF
  IF(endLT.LT.0.OR.endLT.GT.240000) THEN
    WRITE(*,*) "END LOCAL TIME MUST BE BETWEEN 0 AND 240000"
    RETURN
  END IF
  IF(srtLT.GT.endLT) THEN
    WRITE(*,*) "START LOCAL TIME IS NOT LARGE THAN END LOCAL TIME"
    RETURN
  END IF

  srtLTHUR=srtLT/10000
  srtLTMIN=MOD(srtLT,10000)/100
  srtLTSEC=MOD(MOD(srtLT,10000),100)

  endLTHUR=endLT/10000
  endLTMIN=MOD(endLT,10000)/100
  endLTSEC=MOD(MOD(endLT,10000),100)

  stpLTHUR=stpLT/10000
  stpLTMIN=MOD(stpLT,10000)/100
  stpLTSEC=MOD(MOD(stpLT,10000),100)

  IF(srtLT.EQ.endLT.OR.stpLT.EQ.0) THEN
    IF(ALLOCATED(LTHURMAT)) DEALLOCATE(LTHURMAT)
    IF(ALLOCATED(LTMINMAT)) DEALLOCATE(LTMINMAT)
    IF(ALLOCATED(LTSECMAT)) DEALLOCATE(LTSECMAT)
    ALLOCATE(LTHURMAT(1),LTMINMAT(1),LTSECMAT(1))
    LTHURMAT(1)=srtLTHUR
    LTMINMAT(1)=srtLTMIN
    LTSECMAT(1)=srtLTSEC
  ELSE
    TEMPNUM1=srtLTHUR*3600+srtLTMIN*60+srtLTSEC
    TEMPNUM2=endLTHUR*3600+endLTMIN*60+endLTSEC
    TEMPNUM3=stpLTHUR*3600+stpLTMIN*60+stpLTSEC
    IF(ALLOCATED(LTMAT))    DEALLOCATE(LTMAT)
    IF(ALLOCATED(LTHURMAT)) DEALLOCATE(LTHURMAT)
    IF(ALLOCATED(LTMINMAT)) DEALLOCATE(LTMINMAT)
    IF(ALLOCATED(LTSECMAT)) DEALLOCATE(LTSECMAT)
    ALLOCATE(LTMAT(((TEMPNUM2-TEMPNUM1)/TEMPNUM3)+1))
    ALLOCATE(LTHURMAT(((TEMPNUM2-TEMPNUM1)/TEMPNUM3)+1))
    ALLOCATE(LTMINMAT(((TEMPNUM2-TEMPNUM1)/TEMPNUM3)+1))
    ALLOCATE(LTSECMAT(((TEMPNUM2-TEMPNUM1)/TEMPNUM3)+1))
    CALL VARVECTOR(TEMPNUM1,TEMPNUM2,TEMPNUM3,LTMAT)
    DO I=1,SIZE(LTMAT)
      LTHURMAT(I)=LTMAT(I)/3600
      LTMINMAT(I)=MOD(LTMAT(I),3600)/60
      LTSECMAT(I)=MOD(MOD(LTMAT(I),3600),60)
    END DO
  END IF

  IF(srtDT.LT.19000101.OR.srtDT.GT.20201231) THEN
    WRITE(*,*) "START DATE MUST BE BETWEEN 19000101 AND 20201231"
    RETURN
  END IF
  IF(endDT.LT.19000101.OR.endDT.GT.20201231) THEN
    WRITE(*,*) "END DATE MUST BE BETWEEN 19000101 AND 20201231"
    RETURN
  END IF
  IF(srtDT.GT.endDT) THEN
    WRITE(*,*) "START DATE IS NOT LARGE THAN END DATE"
    RETURN
  END IF

  srtYYYY=srtDT/10000
  srtMM=MOD(srtDT,10000)/100
  srtDD=MOD(MOD(srtDT,10000),100)
  srtMMDD=100*srtMM+srtDD

  endYYYY=endDT/10000
  endMM=MOD(endDT,10000)/100
  endDD=MOD(MOD(endDT,10000),100)
  endMMDD=100*endMM+endDD

  IF(srtDT.EQ.endDT) THEN
    IF(ALLOCATED(DTMAT))     DEALLOCATE(DTMAT)
    IF(ALLOCATED(DTYYYYMAT)) DEALLOCATE(DTYYYYMAT)
    IF(ALLOCATED(DTMMMAT))   DEALLOCATE(DTMMMAT)
    IF(ALLOCATED(DTDDMAT))   DEALLOCATE(DTDDMAT)
    IF(ALLOCATED(DTMMDDMAT)) DEALLOCATE(DTMMDDMAT)
    ALLOCATE(DTYYYYMAT(1),DTMMMAT(1),DTDDMAT(1))
    ALLOCATE(DTMMDDMAT(1),DTMAT(1))
    DTYYYYMAT(1)=srtYYYY
    DTMMMAT(1)=srtMM
    DTDDMAT(1)=srtDD
    DTMMDDMAT(1)=srtMMDD
    CALL IDDD(0,srtYYYY,srtMM,srtDD,srtDY,NRDAYMON)
    DTMAT(1)=1000*DTYYYYMAT(1)+srtDY
  ELSEIF(srtYYYY.EQ.endYYYY) THEN
    CALL IDDD(0,srtYYYY,srtMM,srtDD,srtDY,NRDAYMON)
    CALL IDDD(0,endYYYY,endMM,endDD,endDY,NRDAYMON)
    IF(ALLOCATED(DTMAT))     DEALLOCATE(DTMAT)
    IF(ALLOCATED(DTYYYYMAT)) DEALLOCATE(DTYYYYMAT)
    IF(ALLOCATED(DTMMMAT))   DEALLOCATE(DTMMMAT)
    IF(ALLOCATED(DTDDMAT))   DEALLOCATE(DTDDMAT)
    IF(ALLOCATED(DTMMDDMAT)) DEALLOCATE(DTMMDDMAT)
    ALLOCATE(DTMAT((endDY-srtDY)+1))
    ALLOCATE(DTYYYYMAT((endDY-srtDY)+1))
    ALLOCATE(DTMMMAT((endDY-srtDY)+1))
    ALLOCATE(DTDDMAT((endDY-srtDY)+1))
    ALLOCATE(DTMMDDMAT((endDY-srtDY)+1))
    CALL VARVECTOR(srtDY,endDY,1,DTMAT)
    DTYYYYMAT=srtYYYY
    DO I=1,SIZE(DTMAT)
      CALL IDDD(1,srtYYYY,DTMMMAT(I),DTDDMAT(I),DTMAT(I),NRDAYMON)
      DTMMDDMAT(I)=100*DTMMMAT(I)+DTDDMAT(I)
      DTMAT(I)=1000*DTYYYYMAT(I)+DTMAT(I)
    END DO
  ELSEIF(srtYYYY.LT.endYYYY) THEN
    CALL IDDD(0,srtYYYY,srtMM,srtDD,srtDY,NRDAYMON)
    CALL IDDD(0,endYYYY,endMM,endDD,endDY,NRDAYMON)
    NoY=endYYYY-srtYYYY
    IF(ALLOCATED(DoY)) DEALLOCATE(DoY)
    ALLOCATE(DoY(NoY+1))
    IF(MOD(srtYYYY,4).EQ.0) THEN
      TNoD=1+(366-srtDY)
      DoY(1)=1+(366-srtDY)
    ELSE
      TNoD=1+(365-srtDY)
      DoY(1)=1+(365-srtDY)
    END IF
    TNoD=TNoD+endDY
    DoY(NoY+1)=endDY
    DO I=1,NoY-1
      CurrentYYYY=srtYYYY+I
      IF(MOD(CurrentYYYY,4).EQ.0) THEN
        TNoD=TNoD+366
        DoY(I+1)=366
      ELSE
        TNoD=TNoD+365
        DoY(I+1)=365
      END IF
    END DO
    IF(ALLOCATED(DTMAT))     DEALLOCATE(DTMAT)
    IF(ALLOCATED(DTYYYYMAT)) DEALLOCATE(DTYYYYMAT)
    IF(ALLOCATED(DTMMMAT))   DEALLOCATE(DTMMMAT)
    IF(ALLOCATED(DTDDMAT))   DEALLOCATE(DTDDMAT)
    IF(ALLOCATED(DTMMDDMAT)) DEALLOCATE(DTMMDDMAT)
    ALLOCATE(DTMAT(TNoD))
    ALLOCATE(DTYYYYMAT(TNoD))
    ALLOCATE(DTMMMAT(TNoD))
    ALLOCATE(DTDDMAT(TNoD))
    ALLOCATE(DTMMDDMAT(TNoD))

    ICOUNTER=1
    DO I=1,NoY+1
      CurrentYYYY=srtYYYY+(I-1)
      IF(CurrentYYYY.EQ.srtYYYY) THEN
        srtJ=srtDY
        endJ=(srtDY+DoY(I))-1
      ELSEIF(CurrentYYYY.EQ.endYYYY) THEN
        srtJ=1
        endJ=endDY
      ELSE
        srtJ=1
        endJ=DoY(I)
      END IF
      DO J=srtJ,endJ
        DTYYYYMAT(ICOUNTER)=CurrentYYYY
        DTMAT(ICOUNTER)=J
        CALL IDDD(1,CurrentYYYY,DTMMMAT(ICOUNTER),DTDDMAT(ICOUNTER),DTMAT(ICOUNTER),NRDAYMON)
        DTMMDDMAT(ICOUNTER)=100*DTMMMAT(ICOUNTER)+DTDDMAT(ICOUNTER)
        DTMAT(ICOUNTER)=1000*DTYYYYMAT(ICOUNTER)+DTMAT(ICOUNTER)
        ICOUNTER=ICOUNTER+1
      END DO
    END DO
  END IF

!       DO I=1,SIZE(DTMAT)
!          PRINT*, DTMAT(I),DTYYYYMAT(I),DTMMMAT(I),DTDDMAT(I),DTMMDDMAT(I)
!       END DO

 END SUBROUTINE DTLTMAT


 SUBROUTINE IYYDDD(iyr,iday,hrl,glong,iyd,secut)

! msistim calculates time parameters for the 
! nrlmsise00 neutral atmosphere model.

! the arguments are defined as follows:

! iyr    the julian year
! iday   the day of the year
! hr     the local time in hours
! glong  the geocentric longitude in degrees east
! iyd    the year and day in the form yyddd
! secut  the universal time in seconds

  iyd    = 1000 * mod(iyr,100) + iday
  hrut   = hrl - glong /15.

  do while ( hrut .lt. 0.  )
    hrut = hrut + 24.
  enddo

  do while ( hrut .ge. 24. )
    hrut = hrut - 24.
  enddo

  secut  = hrut * 3600.

  return
 END SUBROUTINE IYYDDD


 SUBROUTINE IDDD(IN,IYEAR,MONTH,IDAY,IDOY,NRDAYMO)
!-------------------------------------------------------------------
! CALCULATES DAY OF YEAR (IDOY, ddd) FROM YEAR (IYEAR, yy or yyyy), 
! MONTH (MONTH, mm) AND DAY OF MONTH (IDAY, dd) IF IN=0, OR MONTH 
! AND DAY FROM YEAR AND DAY OF YEAR IF IN=1. NRDAYMO is an output 
! parameter providing the number of days in the specific month.
!-------------------------------------------------------------------
  REAL(4) :: MM(12)

  MM=(/31,28,31,30,31,30,31,31,30,31,30,31/)
  IMO=0
  MOBE=0
!
!  leap year rule: years evenly divisible by 4 are leap years, except
!  years also evenly divisible by 100 are not leap years, except years 
!  also evenly divisible by 400 are leap years. The year 2000 therefore 
!  is a leap year. The 100 and 400 year exception rule
!     if((iyear/4*4.eq.iyear).and.(iyear/100*100.ne.iyear)) mm(2)=29
!  will become important again in the year 2100 which is not a leap 
!  year.
!
  MM(2)=28
  IF(IYEAR/4*4.EQ.IYEAR) MM(2)=29

  IF(IN.GT.0) GOTO 5

  MOSUM=0
  IF(MONTH.GT.1) THEN
    DO I=1,MONTH-1
       MOSUM=MOSUM+MM(i)
    END DO
  END IF
  IDOY=MOSUM+IDAY
  NRDAYMO=MM(MONTH)
  RETURN

5 IMO=IMO+1
  IF(IMO.GT.12) GOTO 55
  MOOLD=MOBE
  NRDAYMO=MM(IMO)
  MOBE=MOBE+nrdaymo
  IF(MOBE.LT.IDOY) GOTO 5
55 MONTH=IMO
  IDAY=IDOY-MOOLD
  RETURN

 END SUBROUTINE IDDD

  
!*************************************************************************
!  TO CALCULATE THE GEODISTANCE BETWEEN TWO POINTS ON EARTH COORDINATES
!*************************************************************************
 FUNCTION R4GEODSTNBTWN(R,LAT1,LAT2,LON1,LON2)
  IMPLICIT NONE
  REAL(4) :: LAT1,LAT2                 ! GEOGRAPHIC LATITUDES
  REAL(4) :: radLAT1,radLAT2
  REAL(4) :: LON1,LON2                 ! GEOGRAPHIC LONGITUDES
  REAL(4) :: radLON1,radLON2
  REAL(4) :: R
  REAL(4) :: A1,A2,R4GEODSTNBTWN

  radLAT1=DEG2RAD(LAT1)
  radLAT2=DEG2RAD(LAT2)
  radLON1=DEG2RAD(LON1)
  radLON2=DEG2RAD(LON2)
  A1=(SIN((radLAT2-radLAT1)/2)**2)+(COS(radLAT1)*COS(radLAT2)*(SIN((radLON2-radLON1)/2)**2))
  A2=1-A1
  R4GEODSTNBTWN=2.0*R*ATAN2(SQRT(A1),SQRT(A2))
 END FUNCTION R4GEODSTNBTWN

 FUNCTION R8GEODSTNBTWN(R,LAT1,LAT2,LON1,LON2)
  IMPLICIT NONE
  REAL(8) :: LAT1,LAT2                 ! GEOGRAPHIC LATITUDES
  REAL(8) :: radLAT1,radLAT2
  REAL(8) :: LON1,LON2                 ! GEOGRAPHIC LONGITUDES
  REAL(8) :: radLON1,radLON2
  REAL(8) :: R
  REAL(8) :: A1,A2,R8GEODSTNBTWN

  radLAT1=DEG2RAD(LAT1)
  radLAT2=DEG2RAD(LAT2)
  radLON1=DEG2RAD(LON1)
  radLON2=DEG2RAD(LON2)
  A1=(SIN((radLAT2-radLAT1)/2)**2)+(COS(radLAT1)*COS(radLAT2)*(SIN((radLON2-radLON1)/2)**2))
  A2=1-A1
  R8GEODSTNBTWN=2.0*R*ATAN2(SQRT(A1),SQRT(A2))
 END FUNCTION R8GEODSTNBTWN


!*************************************************************************
!  TO CALCULATE THE GEO-BEARING BETWEEN TWO POINTS ON EARTH COORDINATES
!*************************************************************************
 FUNCTION R4GEOBEARINGBTWN(LAT1,LAT2,LON1,LON2)
  IMPLICIT NONE
  REAL(4) :: LAT1,LAT2
  REAL(4) :: radLAT1,radLAT2
  REAL(4) :: LON1,LON2
  REAL(4) :: radLON1,radLON2
  REAL(4) :: R4GEOBEARINGBTWN

  radLAT1=DEG2RAD(LAT1)
  radLAT2=DEG2RAD(LAT2)
  radLON1=DEG2RAD(LON1)
  radLON2=DEG2RAD(LON2)
  R4GEOBEARINGBTWN=ATAN2(SIN(radLON2-radLON1)*COS(radLAT2),COS(radLAT1)*SIN(radLAT2)-SIN(radLAT1)*COS(radLAT2)*COS(radLON2-radLON1))
 END FUNCTION R4GEOBEARINGBTWN

 FUNCTION R8GEOBEARINGBTWN(LAT1,LAT2,LON1,LON2)
  IMPLICIT NONE
  REAL(8) :: LAT1,LAT2
  REAL(8) :: radLAT1,radLAT2
  REAL(8) :: LON1,LON2
  REAL(8) :: radLON1,radLON2
  REAL(8) :: R8GEOBEARINGBTWN

  radLAT1=DEG2RAD(LAT1)
  radLAT2=DEG2RAD(LAT2)
  radLON1=DEG2RAD(LON1)
  radLON2=DEG2RAD(LON2)
  R8GEOBEARINGBTWN=ATAN2(SIN(radLON2-radLON1)*COS(radLAT2),COS(radLAT1)*SIN(radLAT2)-SIN(radLAT1)*COS(radLAT2)*COS(radLON2-radLON1))
 END FUNCTION R8GEOBEARINGBTWN


!****************************************************************
!******* CALCULATING THE GEOMAGNETIC SHELLS (FLUX TUBES) ********
!****************************************************************
 SUBROUTINE BSHELL(L,PHIG,R,Q,IGRFYEAR)
  IMPLICIT NONE
      
  REAL :: L
  REAL(8) :: QMIN,QNMAX,QSMAX,QVALUE
  REAL(8), PARAMETER :: PI=4.0d0*ATAN(1.0d0)
! REAL(8) :: DR,RE,R,RM0,XED,YED,ZED,DRMIN,CN
  REAL(8) :: DR,R,RM0,XED,YED,ZED,DRMIN,CN
  REAL(8) :: RED,THETAED,PHIED,RED2,RCD,THETACD,PHICD
  REAL(8) :: PHIG,RG,THETAG,THETAN,PHIN
  REAL(8) :: IGRFYEAR
  REAL(8) :: THETAM0,X,Z,C,TEMP
  REAL(8), DIMENSION(3) :: EDXYZ,CDXYZ
  REAL(8), DIMENSION(:) :: Q
  REAL(8), ALLOCATABLE, DIMENSION(:,:) :: ED,CD,GEO
  INTEGER :: I,N,NN,NS
      
  X=1.0
  DRMIN=0.5
  CN=401.0
  N=INT(CN)
  NN=(N-1)/2;NS=(N-1)/2
  ALLOCATE(ED(N,3))
  ALLOCATE(CD(N,3))
  ALLOCATE(GEO(N,3))

! RE=6300.0
  RM0=R
      
! DO I=1,7
  DO WHILE(ABS(DR).LT.DRMIN)
    THETAM0=ASIN(SQRT(RM0/(R*L)))
    CALL ED2CD(RM0,THETAM0,PHIG,RG,THETACD,PHICD,IGRFYEAR)
    DR=RG-R
!   IF(ABS(DR).LT.DRMIN) GOTO 11
    RM0=RM0-ABS(DR)
  END DO
! print*, RM0
      
!11   QMIN=0
  QMIN=0
  Q(201)=QMIN
  QNMAX=COS(THETAM0)*(R/RM0)**2
  C=2/(CN-1)
      
  DO I=1,NN
    Q(I)=0.2*ASINH(X*SINH(5.0*QNMAX))
    X=X+C
  END DO
      
  X=-1.0
! DO I=1,7
  DO WHILE(ABS(DR).LT.DRMIN)
    THETAM0=ASIN(-SQRT(RM0/(R*L)))
    CALL ED2CD(RM0,THETAM0,PHIG,RG,THETACD,PHICD,IGRFYEAR)
    DR=RG-R
!   IF(ABS(DR).LT.DRMIN) GOTO 12
      RM0=RM0-ABS(DR)
  END DO
!   print*, RM0
      
!12 QSMAX=COS(THETAM0)*(R/RM0)**2
  QSMAX=COS(THETAM0)*(R/RM0)**2
  C=2/(CN-1)
      
  DO I=0,NS-1
    Q(401-I)=0.2*ASINH(X*SINH(5*QSMAX))
    X=X+C
  END DO

  ED(201,1)=R*L
  ED(201,2)=ASIN(SQRT(ED(201,1)/(R*L)))
  DO I=1,(N-1)/2
    ED(201-I,1)=NROOT(ED(202-I,1),L,Q(201-I))
    ED(201-I,2)=ASIN(SQRT(ED(201-I,1)/(R*L)))
    ED(201-I,3)=PHIED
    ED(201+I,1)=NROOT(ED(200+I,1),L,Q(201+I))
    ED(201+I,2)=ASIN(-SQRT(ED(201+I,1)/(R*L)))
    ED(201+I,3)=PHIED
  END DO
  DO I=1,N
    CALL ED2CD(ED(I,1),ED(I,2),ED(I,3),CD(I,1),CD(I,2),CD(I,3),IGRFYEAR)
    GEO(I,1)=CD(I,1)
    CALL CD2GEO(CD(I,2),CD(I,3),GEO(I,2),GEO(I,3),IGRFYEAR)
  END DO      

  print*, GEO(201,1),RAD2DEG(GEO(1,2)),RAD2DEG(GEO(1,3))
 END SUBROUTINE BSHELL
      

!**********************************************************
!***************** GEOGRAPHIC GRID ************************
!**********************************************************
!      SUBROUTINE FIELDGRID
!!             (/srtLAT,endLAT,srtLON,endLON,srtALT,endALT/)
!!              srtLAT=START POINT IN COLATITUDE (REAL(4) DEGREES: 0.0 -> 180.0)
!!              endLAT=END POINT IN LATITUDE EAST (REAL(4) DEGREES: 0.0 -> 360.0)
!!             (/nLAT,nLON,nALT/)
!!             nLAT=NUMBER OF POINTS ALONG LATITUDE RANGE (INTEGER(4))
!      IMPLICIT NONE
!      INTEGER(4) :: I,J,K,GEOGRIDID=0


!      IF(srtLAT.EQ.endLAT.OR.nLAT.EQ.1) THEN
!        vecLAT1D=srtLAT
!      ELSE
!        CALL LINVECTOR(srtLAT,endLAT,nLAT,vecLAT1D)
!      END IF
!      IF(srtLON.EQ.endLON.OR.nLON.EQ.1) THEN
!        vecLON1D=srtLON
!      ELSE
!        CALL LINVECTOR(srtLON,endLON,nLON,vecLON1D)
!      END IF
!      IF(srtALT.EQ.endALT.OR.nALT.EQ.1) THEN
!        vecALT1D=srtALT
!      ELSE
!        CALL LINVECTOR(srtALT,endALT,nALT,vecALT1D)
!      END IF
!      CALL MESHGRID(vecLAT1D,vecLON1D,vecLAT2D,vecLON2D)

!      DO I=1,nALT
!         DO J=1,nLAT
!            DO K=1,nLON
!               GEOGRIDID=GEOGRIDID+1
!               GEOMESHGRID(GEOGRIDID,1)=vecLAT2D(J,K)
!               GEOMESHGRID(GEOGRIDID,2)=vecLON2D(J,K)
!               GEOMESHGRID(GEOGRIDID,3)=vecLAT1D(I)
!            END DO
!          END DO
!      END DO

!     END SUBROUTINE FIELDGRID


!**********************************************************
!***************** OTHER FGUNCTIONS ***********************
!**********************************************************
 FUNCTION BQF(RI,L,Q)
  IMPLICIT NONE
  REAL(8) :: RI,Q,BQF,R=6371.0
  REAL :: L

  BQF=((Q**2/R**4)*(RI**4))+(RI/(L*R))-1
 END FUNCTION BQF
      
 FUNCTION NROOT(Z,L,Q)
  IMPLICIT NONE
  REAL(8) :: TOL,H,Z,NROOT,F,FH,DF,Q
  REAL :: L
  INTEGER :: I

  H=1E-1
  TOL=1E-5
! DO I=1,7
  DO WHILE(F.LE.TOL)
    F=BQF(Z,L,Q)
!   IF(F.LE.TOL) GOTO 21
    FH=BQF(Z+H,L,Q)
    DF=(FH-F)/H
!   DF=BQDF(Z,L,Q)	
    Z=Z-(F/DF)
  END DO
  NROOT=Z
!21   NROOT=Z
 END FUNCTION NROOT



END MODULE SYSGRIDS
