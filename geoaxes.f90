MODULE GEOAXES
 USE MATHSUBS

 INTERFACE GEOG2GEOM
   MODULE PROCEDURE r8GEOG2GEOM,r4GEOG2GEOM
 END INTERFACE

 INTERFACE GEOM2GEOG
   MODULE PROCEDURE r8GEOM2GEOG,r4GEOM2GEOG
 END INTERFACE

 INTERFACE GEO2CD
   MODULE PROCEDURE R8GEO2CD,R4GEO2CD
 END INTERFACE

 INTERFACE CD2GEO
   MODULE PROCEDURE R8CD2GEO,R4CD2GEO
 END INTERFACE

 INTERFACE CD2ED
   MODULE PROCEDURE R8CD2ED,R4CD2ED
 END INTERFACE

 INTERFACE ED2CD
   MODULE PROCEDURE R8ED2CD,R4ED2CD
 END INTERFACE

 INTERFACE GEO2GD
   MODULE PROCEDURE R8GEO2GD,R4GEO2GD
 END INTERFACE

 INTERFACE GD2GEO
   MODULE PROCEDURE R8GD2GEO,R4GD2GEO
 END INTERFACE

 INTERFACE IGRF
   MODULE PROCEDURE r8IGRF,r4IGRF
 END INTERFACE

 INTERFACE GETIGRF
   MODULE PROCEDURE r8GETIGRF,r4GETIGRF
 END INTERFACE 


 CONTAINS


!**********************************************************
!************** GEOGRAPHIC TO GEOMAGNETIC *****************
!**********************************************************
 SUBROUTINE r4GEOG2GEOM(RGEOG,THETAGEOG,PHIGEOG,RGEOM,THETAGEOM,PHIGEOM,IGRFYEAR)
  IMPLICIT NONE
  REAL(4), INTENT(OUT)         :: RGEOM,THETAGEOM,PHIGEOM
  REAL(4), INTENT(IN)          :: RGEOG,THETAGEOG,PHIGEOG
  REAL(4), INTENT(IN)          :: IGRFYEAR
  REAL(4)                      :: THETAGEOC,PHIGEOC

  CALL GEO2CD(THETAGEOG,PHIGEOG,THETAGEOC,PHIGEOC,IGRFYEAR)
  CALL CD2ED(RGEOG,THETAGEOC,PHIGEOC,RGEOM,THETAGEOM,PHIGEOM,IGRFYEAR)

  RETURN
 END SUBROUTINE r4GEOG2GEOM

 SUBROUTINE r8GEOG2GEOM(RGEOG,THETAGEOG,PHIGEOG,RGEOM,THETAGEOM,PHIGEOM,IGRFYEAR)
  IMPLICIT NONE
  REAL(8), INTENT(OUT)         :: RGEOM,THETAGEOM,PHIGEOM
  REAL(8), INTENT(IN)          :: RGEOG,THETAGEOG,PHIGEOG
  REAL(8), INTENT(IN)          :: IGRFYEAR
  REAL(8)                      :: THETAGEOC,PHIGEOC

  CALL GEO2CD(THETAGEOG,PHIGEOG,THETAGEOC,PHIGEOC,IGRFYEAR)
  CALL CD2ED(RGEOG,THETAGEOC,PHIGEOC,RGEOM,THETAGEOM,PHIGEOM,IGRFYEAR)

  RETURN
 END SUBROUTINE r8GEOG2GEOM

!**********************************************************
!************** GEOMAGNETIC TO GEOGRAPHIC *****************
!**********************************************************
 SUBROUTINE r4GEOM2GEOG(RGEOM,THETAGEOM,PHIGEOM,RGEOG,THETAGEOG,PHIGEOG,IGRFYEAR)
   IMPLICIT NONE
   REAL(4), INTENT(OUT)         :: RGEOG,THETAGEOG,PHIGEOG
   REAL(4), INTENT(IN)          :: RGEOM,THETAGEOM,PHIGEOM
   REAL(4), INTENT(IN)          :: IGRFYEAR
   REAL(4)                      :: THETAGEOC,PHIGEOC

   CALL ED2CD(RGEOM,THETAGEOM,PHIGEOM,RGEOG,THETAGEOC,PHIGEOC,IGRFYEAR)
   CALL CD2GEO(THETAGEOC,PHIGEOC,THETAGEOG,PHIGEOG,IGRFYEAR)

   RETURN
 END SUBROUTINE r4GEOM2GEOG

 SUBROUTINE r8GEOM2GEOG(RGEOM,THETAGEOM,PHIGEOM,RGEOG,THETAGEOG,PHIGEOG,IGRFYEAR)
  IMPLICIT NONE
   REAL(8), INTENT(OUT)         :: RGEOG,THETAGEOG,PHIGEOG
   REAL(8), INTENT(IN)          :: RGEOM,THETAGEOM,PHIGEOM
   REAL(8), INTENT(IN)          :: IGRFYEAR
   REAL(8)                      :: THETAGEOC,PHIGEOC

   CALL ED2CD(RGEOM,THETAGEOM,PHIGEOM,RGEOG,THETAGEOC,PHIGEOC,IGRFYEAR)
   CALL CD2GEO(THETAGEOC,PHIGEOC,THETAGEOG,PHIGEOG,IGRFYEAR)

   RETURN
 END SUBROUTINE r8GEOM2GEOG

!**********************************************************
!*********** GEOGRAPHIC TO GEOCENTRIC DIPOLE **************
!**********************************************************
 SUBROUTINE R4GEO2CD(THETAG,PHIG,THETACD,PHICD,IGRFYEAR,PSI)
  IMPLICIT NONE
  REAL(4) :: THETAN,PHIN,PHIS,THETAS,PHIE,THETAE
  REAL(4) :: THETAG,PHIG,THETACD,PHICD
  REAL(4) :: PHICD1,PHICD2,X,Y,Z
  REAL(4) :: Bo,IGRFYEAR
  REAL(4), OPTIONAL :: PSI
  REAL(4), PARAMETER :: PI=4.0*ATAN(1.0)
  INTEGER(4) :: STAT

!*** INPUTS ***!
! THETAG ... GEOGRAPHIC LATITUDE  (-PI/2 -> PI/2)
! PHIG   ... GEOGRAPHIC LONGITUDE (-PI -> PI)

!*** OUTPUTS ***!
! THETACD ... GEOCENTRIC DIPOLE LATITUDE  (-PI/2 -> PI/2)
! PHICD   ... GEOCENTRIC DIPOLE LONGITUDE (-PI -> PI)

!*** FIND THE CENTER DIPOLE POLES COORDINATES ***!
  CALL IGRF(IGRFYEAR,Bo,THETAN,PHIN)
  THETAS=PI-THETAN
  PHIS=PI+PHIN
      
!*** CONVERT TO CO-LATITUDE(0 -> PI) AND CO-LONGITUDE(0 -> 2*PI) ***!
  THETAG=PI/2.0-THETAG
  IF(PHIG.LT.0.0) PHIG=2.0*PI+PHIG
      
!***CALCULATING THETACD AND PHICD ***!
  IF(THETAG.EQ.0.0) THEN
    THETACD=THETAN
    PHICD=PHIG+PHIN
  ELSE IF(NINT(RAD2DEG(THETAG)).EQ.180) THEN
    THETACD=THETAS
    PHICD=PHIG+PHIS
  ELSE
    THETACD=ACOS(COS(THETAN)*COS(THETAG)+SIN(THETAN)*SIN(THETAG)*COS(PHIG-PHIN))
    X=(-COS(THETAG)+COS(THETAN)*COS(THETACD))/(SIN(THETAN)*SIN(THETACD))
    Y=(SIN(THETAG)*SIN(PHIG-PHIN))/SIN(THETACD)
    PHICD=ATAN2(Y,X)
  END IF

!*** CALCULATING PSI ***!
  IF(PRESENT(PSI)) THEN
    X=(COS(THETAN)-COS(THETAG)*COS(THETACD))/(SIN(THETAG)*SIN(THETACD))
    Y=-SIN(THETAN)*SIN(PHIG-PHIN)/SIN(THETACD)
    PSI=ATAN2(Y,X)
   !PSI=PI/2.0-PSI
  END IF

!*** CONVERT TO LATITUDE(-PI/2 -> PI/2) AND LONGITUDE(-PI -> PI) ***!
  THETACD=PI/2.0-THETACD
  IF(PHICD.GT.PI) PHICD=PHICD-2.0*PI

  RETURN
 END SUBROUTINE R4GEO2CD
      
 SUBROUTINE R8GEO2CD(THETAG,PHIG,THETACD,PHICD,IGRFYEAR,PSI)
  IMPLICIT NONE
  REAL(8) :: THETAN,PHIN,PHIS,THETAS,PHIE,THETAE
  REAL(8) :: THETAG,PHIG,THETACD,PHICD
  REAL(8) :: PHICD1,PHICD2,X,Y,Z
  REAL(8) :: Bo,IGRFYEAR
  REAL(8), OPTIONAL :: PSI
  REAL(8), PARAMETER :: PI=4.0d0*ATAN(1.0d0)
  INTEGER(4) :: STAT

  CALL IGRF(IGRFYEAR,Bo,THETAN,PHIN)
  THETAS=PI-THETAN
  PHIS=PI+PHIN

  THETAG=PI/2.0d0-THETAG
  IF(PHIG.LT.0.0d0) PHIG=2.0d0*PI+PHIG
      
! CALCULATING THETACD
  IF(THETAG.EQ.0.0d0) THEN
    THETACD=THETAN
    PHICD=PHIG+PHIN
  ELSE IF(NINT(RAD2DEG(THETAG)).EQ.180) THEN
    THETACD=THETAS
    PHICD=PHIG+PHIS
  ELSE
    THETACD=ACOS(COS(THETAN)*COS(THETAG)+SIN(THETAN)*SIN(THETAG)*COS(PHIG-PHIN))
! CALCULATING PHICD
    X=(-COS(THETAG)+COS(THETAN)*COS(THETACD))/(SIN(THETAN)*SIN(THETACD))
    Y=(SIN(THETAG)*SIN(PHIG-PHIN))/SIN(THETACD)
    PHICD=ATAN2(Y,X)
  END IF

! CALCULATING PSI
  IF(PRESENT(PSI)) THEN
    X=(COS(THETAN)-COS(THETAG)*COS(THETACD))/(SIN(THETAG)*SIN(THETACD))
    Y=-SIN(THETAN)*SIN(PHIG-PHIN)/SIN(THETACD)
    PSI=ATAN2(Y,X)
   !PSI=PI/2.0d0-PSI
  END IF

  THETACD=PI/2.0d0-THETACD
  IF(PHICD.GT.PI) PHICD=PHICD-2.0d0*PI

  RETURN
 END SUBROUTINE R8GEO2CD
      
!**********************************************************
!*********** GEOCENTRIC DIPOLE TO GEOGRAPHIC **************
!**********************************************************
 SUBROUTINE R4CD2GEO(THETACD,PHICD,THETAG,PHIG,IGRFYEAR)
  IMPLICIT NONE
  REAL(4) :: THETAN,PHIN,THETAS,PHIS,THETAE,PHIE
  REAL(4) :: THETAG,PHIG,THETACD,PHICD,PSI
  REAL(4) :: PHIG1,PHIG2,X,Y,Z
  REAL(4) :: Bo,IGRFYEAR
  REAL(4), PARAMETER :: PI=4.0*ATAN(1.0)
  INTEGER(4) :: STAT

  CALL IGRF(IGRFYEAR,Bo,THETAN,PHIN)
  THETAS=PI-THETAN
  PHIS=PI+PHIN

  THETACD=PI/2.0-THETACD
  IF(PHICD.LT.0.0) PHICD=2.0*PI+PHICD
      
! CALCULATING THETAG
  IF(NINT(RAD2DEG(THETACD)).EQ.NINT(RAD2DEG(THETAN)))THEN
   THETAG=0.0
   PHIG=PHICD-PHIN
  ELSE IF(NINT(RAD2DEG(THETACD)).EQ.NINT(RAD2DEG(THETAS)))THEN
    THETAG=PI
    PHIG=PHICD-PHIS
  ELSE
    THETAG=ACOS((COS(THETAN)*COS(THETACD))+(SIN(THETAN)*SIN(THETACD)*COS(PI-PHICD)))
! CALCULATING PHIG
    X=(COS(THETACD)-COS(THETAN)*COS(THETAG))/(SIN(THETAN)*SIN(THETAG))
    Y=SIN(THETACD)*SIN(PHICD)/SIN(THETAG)
    PHIG=PHIN+ATAN2(Y,X)
  END IF

  THETAG=PI/2.0-THETAG
  IF(PHIG.GT.PI) PHIG=PHIG-2.0*PI
      
  RETURN
 END SUBROUTINE R4CD2GEO
      
 SUBROUTINE R8CD2GEO(THETACD,PHICD,THETAG,PHIG,IGRFYEAR)
  IMPLICIT NONE
  REAL(8) :: THETAN,PHIN,THETAS,PHIS,THETAE,PHIE
  REAL(8) :: THETAG,PHIG,THETACD,PHICD,PSI
  REAL(8) :: PHIG1,PHIG2,X,Y,Z
  REAL(8) :: Bo,IGRFYEAR
  REAL(8), PARAMETER :: PI=4.0d0*ATAN(1.0d0)
  INTEGER(4) :: STAT

  CALL IGRF(IGRFYEAR,Bo,THETAN,PHIN)
  THETAS=PI-THETAN
  PHIS=PI+PHIN

  THETACD=PI/2.0d0-THETACD
  IF(PHICD.LT.0.0d0) PHICD=2.0d0*PI+PHICD
      
! CALCULATING THETAG
  IF(NINT(RAD2DEG(THETACD)).EQ.NINT(RAD2DEG(THETAN)))THEN
    THETAG=0.0d0
    PHIG=PHICD-PHIN
  ELSE IF(NINT(RAD2DEG(THETACD)).EQ.NINT(RAD2DEG(THETAS)))THEN
    THETAG=PI
    PHIG=PHICD-PHIS
  ELSE
    THETAG=ACOS((COS(THETAN)*COS(THETACD))+(SIN(THETAN)*SIN(THETACD)*COS(PI-PHICD)))
! CALCULATING PHIG
    X=(COS(THETACD)-COS(THETAN)*COS(THETAG))/(SIN(THETAN)*SIN(THETAG))
    Y=SIN(THETACD)*SIN(PHICD)/SIN(THETAG)
    PHIG=PHIN+ATAN2(Y,X)
  END IF

  THETAG=PI/2.0d0-THETAG
  IF(PHIG.GT.PI) PHIG=PHIG-2.0d0*PI
     
  RETURN
 END SUBROUTINE R8CD2GEO

!**********************************************************
!******* GEOCENTRIC DIPOLE TO ECCENTRIC DIPOLE ************
!**********************************************************
 SUBROUTINE R4CD2ED(RG,THETACD,PHICD,RED,THETAED,PHIED,IGRFYEAR)
  IMPLICIT NONE
  REAL(4) :: RG,XED,YED,ZED,REDX,REDY,REDZ,RED
  REAL(4) :: THETAED,PHIED,THETACD,PHICD
  REAL(4) :: IGRFYEAR,Bo,THETAN,PHIN
  REAL(4), DIMENSION(3) :: GEOXYZ,CDXYZ
  REAL(4), PARAMETER    :: PI=4.0*ATAN(1.0)
     
  CALL IGRF(IGRFYEAR,Bo,THETAN,PHIN,GEOXYZ,CDXYZ)

  THETACD=PI/2.0-THETACD
  IF(PHICD.LT.0.0) PHICD=2.0*PI+PHICD
      
  REDX=RG*SIN(THETACD)*COS(PHICD)-CDXYZ(1)
  REDY=RG*SIN(THETACD)*SIN(PHICD)-CDXYZ(2)
  REDZ=RG*COS(THETACD)-CDXYZ(3)

  PHIED=ATAN2(REDY,REDX)

  IF((NINT(RAD2DEG(PHIED)).EQ.90).OR.(NINT(RAD2DEG(PHIED)).EQ.270)) THEN
    THETAED=ATAN2(REDY,REDZ)
  ELSE
    THETAED=ATAN2(REDX,(REDZ*COS(PHIED)))
  END IF

  IF((NINT(RAD2DEG(THETAED)).EQ.90).OR.(NINT(RAD2DEG(THETAED)).EQ.270)) THEN
    RED=SQRT(REDX*REDX+REDY*REDY)
  ELSE
    RED=REDZ/COS(THETAED)
  END IF

  THETAED=PI/2.0-THETAED
  IF(PHIED.GT.PI) PHIED=PHIED-2.0*PI
      
  RETURN
 END SUBROUTINE R4CD2ED
      
 SUBROUTINE R8CD2ED(RG,THETACD,PHICD,RED,THETAED,PHIED,IGRFYEAR)
  IMPLICIT NONE
  REAL(8) :: RG,XED,YED,ZED,REDX,REDY,REDZ,RED
  REAL(8) :: THETAED,PHIED,THETACD,PHICD
  REAL(8) :: IGRFYEAR,Bo,THETAN,PHIN
  REAL(8), DIMENSION(3) :: GEOXYZ,CDXYZ
  REAL(8), PARAMETER    :: PI=4.0d0*ATAN(1.0d0)
    
  CALL IGRF(IGRFYEAR,Bo,THETAN,PHIN,GEOXYZ,CDXYZ)

  THETACD=PI/2.0d0-THETACD
  IF(PHICD.LT.0.0d0) PHICD=2.0d0*PI+PHICD
      
  REDX=RG*SIN(THETACD)*COS(PHICD)-CDXYZ(1)
  REDY=RG*SIN(THETACD)*SIN(PHICD)-CDXYZ(2)
  REDZ=RG*COS(THETACD)-CDXYZ(3)

  PHIED=ATAN2(REDY,REDX)

  IF((NINT(RAD2DEG(PHIED)).EQ.90).OR.(NINT(RAD2DEG(PHIED)).EQ.270)) THEN
    THETAED=ATAN2(REDY,REDZ)
  ELSE
    THETAED=ATAN2(REDX,(REDZ*COS(PHIED)))
  END IF

  IF((NINT(RAD2DEG(THETAED)).EQ.90).OR.(NINT(RAD2DEG(THETAED)).EQ.270)) THEN
    RED=SQRT(REDX*REDX+REDY*REDY)
  ELSE
    RED=REDZ/COS(THETAED)
  END IF

  THETAED=PI/2.0d0-THETAED
  IF(PHIED.GT.PI) PHIED=PHIED-2.0d0*PI

  RETURN
 END SUBROUTINE R8CD2ED
      
!**********************************************************
!******* ECCENTRIC DIPOLE TO GEOCENTRIC DIPOLE ************
!**********************************************************
 SUBROUTINE R4ED2CD(RED,THETAED,PHIED,RG,THETACD,PHICD,IGRFYEAR)
  IMPLICIT NONE
      
  REAL(4) :: XED,YED,ZED,RGX,RGY,RGZ,RED,RG
  REAL(4) :: THETAED,PHIED,THETACD,PHICD,PSI
  REAL(4) :: IGRFYEAR,Bo,THETAN,PHIN
  REAL(4), DIMENSION(3) :: GEOXYZ,CDXYZ
  REAL(4), PARAMETER    :: PI=4.0d0*ATAN(1.0d0)
      
  CALL IGRF(IGRFYEAR,Bo,THETAN,PHIN,GEOXYZ,CDXYZ)

  THETAED=PI/2.0-THETAED
  IF(PHIED.LT.0.0) PHIED=2.0*PI+PHIED
      
  RGX=RED*SIN(THETAED)*COS(PHIED)+CDXYZ(1)
  RGY=RED*SIN(THETAED)*SIN(PHIED)+CDXYZ(2)
  RGZ=RED*COS(THETAED)+CDXYZ(3)

  PHICD=ATAN2(RGY,RGX)

  IF((NINT(RAD2DEG(PHICD)).EQ.90).OR.(NINT(RAD2DEG(PHICD)).EQ.270)) THEN
    THETACD=ATAN2(RGY,RGZ)
  ELSE
    THETACD=ATAN2(RGX,(RGZ*COS(PHICD)))
  END IF

  IF((NINT(RAD2DEG(THETACD)).EQ.90).OR.(NINT(RAD2DEG(THETACD)).EQ.270)) THEN
    RG=SQRT(RGX*RGX+RGY*RGY)
  ELSE
    RG=RGZ/COS(THETACD)
  END IF
 
  THETACD=PI/2.0-THETACD
  IF(PHICD.GT.PI) PHICD=PHICD-2.0*PI

  RETURN
 END SUBROUTINE R4ED2CD      

 SUBROUTINE R8ED2CD(RED,THETAED,PHIED,RG,THETACD,PHICD,IGRFYEAR)
  IMPLICIT NONE
  REAL(8) :: XED,YED,ZED,RGX,RGY,RGZ,RED,RG
  REAL(8) :: THETAED,PHIED,THETACD,PHICD,PSI
  REAL(8) :: IGRFYEAR,Bo,THETAN,PHIN
  REAL(8), DIMENSION(3) :: GEOXYZ,CDXYZ
  REAL(8), PARAMETER    :: PI=4.0d0*ATAN(1.0d0)
       
  CALL IGRF(IGRFYEAR,Bo,THETAN,PHIN,GEOXYZ,CDXYZ)
 
  THETACD=PI/2.0d0-THETACD
  IF(PHICD.LT.0.0d0) PHICD=2.0d0*PI+PHICD
      
  RGX=RED*SIN(THETAED)*COS(PHIED)+CDXYZ(1)
  RGY=RED*SIN(THETAED)*SIN(PHIED)+CDXYZ(2)
  RGZ=RED*COS(THETAED)+CDXYZ(3)

  PHICD=ATAN2(RGY,RGX)

  IF((NINT(RAD2DEG(PHICD)).EQ.90).OR.(NINT(RAD2DEG(PHICD)).EQ.270)) THEN
    THETACD=ATAN2(RGY,RGZ)
  ELSE
    THETACD=ATAN2(RGX,(RGZ*COS(PHICD)))
  END IF

  IF((NINT(RAD2DEG(THETACD)).EQ.90).OR.(NINT(RAD2DEG(THETACD)).EQ.270)) THEN
    RG=SQRT(RGX*RGX+RGY*RGY)
  ELSE
    RG=RGZ/COS(THETACD)
  END IF
 
  THETACD=PI/2.0d0-THETACD
  IF(PHICD.GT.PI) PHICD=PHICD-2.0d0*PI

  RETURN
 END SUBROUTINE R8ED2CD      

!**********************************************************
!***************** GEOGRAPHIC TO GEODETIC *****************
!**********************************************************
 SUBROUTINE R4GEO2GD(R,THETAG,PHIG,ALT,THETAGD,PHIGD)
!
! Geocentric to geodetic conversion for coordinates
! INPUTS: GEOCENTRIC COORDINATES
! THETAG= COLATITUDE (TO SOUTH IN RADIANS)
! PHIG= LONGITUDE (TO EAST IN RADIANS)
! R    = RADIAL DISTANCE FROM THE GEOCENTER (IN KM)
! Output: GEODETIC COORDINATES
! THETAGD = COLATITUDE (TO SOUTH IN RADIANS)
! PHIGD = LONGITUDE (TO EAST IN RADIANS)
! ALT   = HEIGHT ABOVE THE SPHEROID (IN KM)
!
!     implicit real*8 (A-H,O-Z)
  IMPLICIT NONE
  REAL, PARAMETER :: PI=4.0d0*ATAN(1.0d0)
  REAL::RPD,EPS
  REAL::THETAG,PHIG,THETAGD,PHIGD,CLAT,ALT,R
  REAL::BETA
  REAL::A,B,AA,BB,EE,X,XP,Y,YP,A0,A1,A2,A3,A4
  REAL::P1,P2,P3,P4,Q1,Q2,Q3,G
  INTEGER::IQUAD,IT,MAXIT


!     rpd=datan(1.d0)/45.d0
  MAXIT=300         ! max number of iterations allowed
  A = 6378.135    ! semi major axis, WGS 1972
  B = 6356.751    ! semi minor axis
!
! Special cases
!
  IF(RAD2DEG(THETAG).LT.0.0.OR.RAD2DEG(THETAG).GT.180.0) THEN
!     print*, rad2deg(thetag)
    write(*,*)'Geocentric colat, out of range in subroutine CTODB'
    stop
  endif

  if(NINT(RAD2DEG(THETAG)).EQ.0.OR.NINT(RAD2DEG(THETAG)).EQ.180)THEN
    THETAGD=THETAG
    PHIGD=PHIG
    ALT= R-B
    return
  endif

!
! Evaluate EPS, the allowed error for the computed root, according to
! the precision of the computer
!
  EPS=1.0e-3 ! starting value
!100  continue
!     if(1.0e8+EPS.gt.1.0e8) then
!       EPS=EPS/2.0
!       goto 100
!     endif
!     write(*,*)'Precision limit, EPS=',EPS

!
! Setup equations
!
  if(RAD2DEG(THETAG).LE.90.0) then  ! Ist quadrant
    IQUAD=1
    CLAT=THETAG              ! colat in radians
  else                      ! 2nd quadrant
    IQUAD=2
    CLAT=PI-THETAG           ! image i n ist quadrant
  endif

  AA= A*A
  BB= B*B
  EE= 1.0-(BB/AA)          ! eccentricity squared
  XP= R*sin(CLAT)           ! x coord for geodetic point
  YP= R*cos(CLAT)           ! y coord for geodetic point
  if(YP.le.10.0*EPS) YP=0.0
  A4= EE*EE
  A3=-2.0*(XP*EE)
  A2= (XP*XP)+(YP*YP)*(BB/AA)-EE*(EE*AA)
  A1= 2.0*(XP*(AA-BB))
  A0=-(AA*XP)*XP
!
! Find root X by Newton's method
!
  X = 0.5*(A+B)*sin(CLAT) ! first approx, root
  do IT=1,MAXIT
    P1=A4*X + A3            ! evaluate quartic
    P2=P1*X + A2
    P3=P2*X + A1
    P4=P3*X + A0
    Q1=4.0*X + 3.0*A3    ! evaluate derivative
    Q2 = Q1*X + 2.0*A2
    Q3 = Q2*X + A1
    G=-P4/Q3
    X= X+G                 ! new approximation to root
!       if(mod(IT,5) .eq.0) write(*,*) IT,' Root=',X,G
    if(abs(G).le.EPS) goto 200 ! close enough
  end do
  write(*,800) MAXIT
 800  format(' Root not found after',i4,' iterations in CTODB')
  stop

!
! Find Y
!
 200  Y = (B/A)*(sqrt((A+X)*(A-X)))
  if(abs(A-X).le.10.0*EPS) Y=0.0
  if(Y.le.10.0*EPS) Y=0.0
!
! Find the geodetic colatitude and longitude
!     BETA=ATAN(Y/(X*(1-EE)))
  BETA=ATAN((AA*Y)/(BB*X))
  if(IQUAD.eq.1) then
    THETAGD=(PI/2.0)-BETA            ! colat (deg) in 1st quadrant
  else
    THETAGD=(PI/2.0)+BETA            ! colat (deg) in 2nd quadrant
  endif
  PHIGD=PHIG
!
! Find height, positive or negative
!
  ALT = sqrt((X-XP)*(X-XP)+(Y-YP)*(Y-YP))  ! km above ellipsoid
  if(YP.lt.Y) ALT=-ALT              ! inside ellipsoid, negative

  return
 END SUBROUTINE R4GEO2GD

 SUBROUTINE R8GEO2GD(R,THETAG,PHIG,ALT,THETAGD,PHIGD)
!
! Geocentric to geodetic conversion for coordinates
! INPUTS: GEOCENTRIC COORDINATES
! THETAG= COLATITUDE (TO SOUTH IN RADIANS)
! PHIG= LONGITUDE (TO EAST IN RADIANS)
! R    = RADIAL DISTANCE FROM THE GEOCENTER (IN KM)
! Output: GEODETIC COORDINATES
! THETAGD = COLATITUDE (TO SOUTH IN RADIANS)
! PHIGD = LONGITUDE (TO EAST IN RADIANS)
! ALT   = HEIGHT ABOVE THE SPHEROID (IN KM)
!

  IMPLICIT NONE
  REAL(8), PARAMETER :: PI=4.0d0*ATAN(1.0d0)
  REAL(8)::RPD,EPS
  REAL(8)::THETAG,PHIG,THETAGD,PHIGD,CLAT,ALT,R
  REAL(8)::BETA
  REAL(8)::A,B,AA,BB,EE,X,XP,Y,YP,A0,A1,A2,A3,A4
  REAL(8)::P1,P2,P3,P4,Q1,Q2,Q3,G
  INTEGER::IQUAD,IT,MAXIT


!     rpd=datan(1.d0)/45.d0
      MAXIT=300         ! max number of iterations allowed
      A = 6378.135d0    ! semi major axis, WGS 1972
      B = 6356.751d0    ! semi minor axis
!
! Special cases
!
  IF(RAD2DEG(THETAG).LT.0.d0.OR.RAD2DEG(THETAG).GT.180.d0) THEN
    write(*,*)'Geocentric colat, out of range in subroutine CTODB'
    stop
  endif

  if(NINT(RAD2DEG(THETAG)).EQ.0.OR.NINT(RAD2DEG(THETAG)).EQ.180)THEN
    THETAGD=THETAG
    PHIGD=PHIG
    ALT= R-B
   return
  endif

!
! Evaluate EPS, the allowed error for the computed root, according to
! the precision of the computer
!
  EPS=1.d-4 ! starting value
 100  continue
  if(1.d8+EPS.gt.1.d8) then
    EPS=EPS/2.d0
    goto 100
  endif
!     write(*,*)'Precision limit, EPS=',EPS

!
! Setup equations
!
  if(RAD2DEG(THETAG).LE.90.d0) then  ! Ist quadrant
    IQUAD=1
    CLAT=THETAG              ! colat in radians
  else                      ! 2nd quadrant
    IQUAD=2
    CLAT=PI-THETAG           ! image i n ist quadrant
  endif

  AA= A*A
  BB= B*B
  EE= 1.d0-(BB/AA)          ! eccentricity squared
  XP= R*sin(CLAT)           ! x coord for geodetic point
  YP= R*cos(CLAT)           ! y coord for geodetic point
  if(YP.le.10.d0*EPS) YP=0.d0
  A4= EE*EE
  A3=-2.d0*(XP*EE)
  A2= (XP*XP)+(YP*YP)*(BB/AA)-EE*(EE*AA)
  A1= 2.d0*(XP*(AA-BB))
  A0=-(AA*XP)*XP
!
! Find root X by Newton's method
!
  X = 0.5d0*(A+B)*sin(CLAT) ! first approx, root
  do IT=1,MAXIT
    P1=A4*X + A3            ! evaluate quartic
    P2=P1*X + A2
    P3=P2*X + A1
    P4=P3*X + A0
    Q1=4.d0*X + 3.d0*A3    ! evaluate derivative
    Q2 = Q1*X + 2.d0*A2
    Q3 = Q2*X + A1
    G=-P4/Q3
    X= X+G                 ! new approximation to root
!       if(mod(IT,5) .eq.0) write(*,*) IT,' Root=',X,G
    if(abs(G).le.EPS) goto 200 ! close enough
  end do
  write(*,800) MAXIT
 800  format(' Root not found after',i4,' iterations in CTODB')
  stop

!
! Find Y
!
 200  Y = (B/A)*(sqrt((A+X)*(A-X)))
  if(abs(A-X).le.10.d0*EPS) Y=0.d0
  if(Y.le.10.d0*EPS) Y=0.d0
!
! Find the geodetic colatitude and longitude
!     BETA=ATAN(Y/(X*(1-EE)))
  BETA=ATAN((AA*Y)/(BB*X))
  if(IQUAD.eq.1) then
    THETAGD=(PI/2.0d0)-BETA            ! colat (deg) in 1st quadrant
  else
    THETAGD=(PI/2.0d0)+BETA            ! colat (deg) in 2nd quadrant
  endif
  PHIGD=PHIG
!
! Find height, positive or negative
!
  ALT = dsqrt((X-XP)*(X-XP)+(Y-YP)*(Y-YP))  ! km above ellipsoid
  if(YP.lt.Y) ALT=-ALT              ! inside ellipsoid, negative

  return
 END SUBROUTINE R8GEO2GD

!**********************************************************
!***************** GEODETIC TO GEOGRAPHIC *****************
!**********************************************************
 SUBROUTINE R4GD2GEO(ALT,THETAGD,PHIGD,R,THETAG,PHIG)
  IMPLICIT NONE
  REAL, PARAMETER :: PI=4.0d0*ATAN(1.0d0)
  REAL::RPD,A,B,AA,BB,B2A2,X,Y,XP,YP
  REAL::BETA,TANB
  REAL::THETAGD,THETAG,ALT,PHIG,PHIGD,R

!     rpd=datan(1.d0)/45.d0
  A = 6378.135    ! semi major axis, WGS 1972
  B = 6356.750    ! semi minor axis
!
! Special cases
!
  if(RAD2DEG(THETAGD).lt.0.0.or.RAD2DEG(THETAGD).gt.180.0) then ! quit
    write(*,*)'Geodetic colat, out of range in subroutine DTOCB'
    stop
  endif

  if(NINT(RAD2DEG(THETAGD)).EQ.0.OR.NINT(RAD2DEG(THETAGD)).EQ.180) THEN
    THETAG=THETAGD
    PHIG=PHIGD
    R = ALT+B
    return
  endif

  AA=A*A
  BB=B*B
  B2A2=(BB/AA)
  BETA=(PI/2.0-THETAGD)
  TANB=tan(BETA)
  X=A/sqrt(1.0+B2A2*(TANB*TANB))
  Y=X*TANB*B2A2
  XP=X+ALT*cos(BETA)
  YP=Y+ALT*sin(BETA)
  R=sqrt(XP*XP+YP*YP)
  THETAG=acos(YP/R)
  PHIG=PHIGD

  return
 END SUBROUTINE R4GD2GEO

 SUBROUTINE R8GD2GEO(ALT,THETAGD,PHIGD,R,THETAG,PHIG)
  IMPLICIT NONE
  REAL(8), PARAMETER :: PI=4.0d0*ATAN(1.0d0)
  REAL(8)::RPD,A,B,AA,BB,B2A2,X,Y,XP,YP
  REAL(8)::BETA,TANB
  REAL(8)::THETAGD,THETAG,ALT,PHIG,PHIGD,R

!     rpd=datan(1.d0)/45.d0
  A = 6378.135d0    ! semi major axis, WGS 1972
  B = 6356.750d0    ! semi minor axis
!
! Special cases
!
  if(RAD2DEG(THETAGD).lt.0.d0.or.RAD2DEG(THETAGD).gt.180.d0) then ! quit
    write(*,*)'Geodetic colat, out of range in subroutine DTOCB'
    stop
  endif

  if(NINT(RAD2DEG(THETAGD)).EQ.0.OR.NINT(RAD2DEG(THETAGD)).EQ.180) THEN
    THETAG=THETAGD
    PHIG=PHIGD
    R = ALT+B
    return
  endif

  AA=A*A
  BB=B*B
  B2A2=(BB/AA)
  BETA=(PI/2.0d0-THETAGD)
  TANB=tan(BETA)
  X=A/sqrt(1.0d0+B2A2*(TANB*TANB))
  Y=X*TANB*B2A2
  XP=X+ALT*cos(BETA)
  YP=Y+ALT*sin(BETA)
  R=dsqrt(XP*XP+YP*YP)
  THETAG=acos(YP/R)
  PHIG=PHIGD

  return
 END SUBROUTINE R8GD2GEO


!******************************************************************************************
!******** IGRF Gaussian Coefficients and Geomagnetic Field Intensity Components ***********
!******************************************************************************************
 SUBROUTINE r4IGRF(IGRFYEAR,Bo,THETAN,PHIN,GEOXYZ,CDXYZ)
  IMPLICIT NONE
  REAL(4)             :: IGRFYEAR
  REAL(4)             :: Bo
  REAL(4), OPTIONAL   :: THETAN,PHIN
  REAL(4), OPTIONAL   :: GEOXYZ(3)
  REAL(4), OPTIONAL   :: CDXYZ(3)
  REAL(4), PARAMETER  :: PI=4.0d0*ATAN(1.0d0)

  REAL(4) :: GGUS(1:13,0:13),HGUS(1:13,1:13)
  REAL(4) :: Lo,L1,L2,E
  REAL(4) :: RE=6371.0
  REAL(4) :: D,THETA0,PHI0,THETACD,PHICD

  CALL GETIGRF(IGRFYEAR,GGUS,HGUS)

  Bo=SQRT(GGUS(1,0)**2+GGUS(1,1)**2+HGUS(1,1)**2)
  IF(PRESENT(THETAN)) THETAN=ACOS(-GGUS(1,0)/Bo)
  IF(PRESENT(PHIN))   PHIN=ATAN2(HGUS(1,1),GGUS(1,1))-PI

  IF(PRESENT(GEOXYZ)) THEN
    Lo=2*GGUS(1,0)*GGUS(2,0)+SQRT(3.0)*(GGUS(1,1)*GGUS(2,1)+HGUS(1,1)*HGUS(2,1))
    L1= -GGUS(1,1)*GGUS(2,0)+SQRT(3.0)*(GGUS(1,0)*GGUS(2,1)+GGUS(1,1)*GGUS(2,2)+HGUS(1,1)*HGUS(2,2))
    L2= -HGUS(1,1)*GGUS(2,0)+SQRT(3.0)*(GGUS(1,0)*HGUS(2,1)-HGUS(1,1)*GGUS(2,2)+GGUS(1,1)*HGUS(2,2))
    E =(Lo*GGUS(1,0)+L1*GGUS(1,1)+L2*HGUS(1,1))/(4.0*Bo**2)

    GEOXYZ(1)=(RE*(L1-GGUS(1,1)*E))/(3.0*Bo**2)
    GEOXYZ(2)=(RE*(L2-HGUS(1,1)*E))/(3.0*Bo**2)
    GEOXYZ(3)=(RE*(Lo-GGUS(1,0)*E))/(3.0*Bo**2)
  END IF

  IF(PRESENT(CDXYZ)) THEN
    D=SQRT(GEOXYZ(1)**2+GEOXYZ(2)**2+GEOXYZ(3)**2)
    THETA0=ACOS(GEOXYZ(3)/D)
    PHI0=ATAN2(GEOXYZ(2),GEOXYZ(1))
! CONVERT FROM CO-LATITUDE TO LATITUDE
    THETA0=PI/2.0-THETA0
! CONVERT FROM CO-LONGITUDE TO LONGITUDE
    IF(PHI0.GT.PI) PHI0=PHI0-2.0*PI

    CALL GEO2CD(THETA0,PHI0,THETACD,PHICD,IGRFYEAR)

    IF(PHICD.LT.0) THEN
     CDXYZ(1)=D*SIN(PI/2-THETACD)*COS(PHICD+2*PI)
     CDXYZ(2)=D*SIN(PI/2-THETACD)*SIN(PHICD+2*PI)
     CDXYZ(3)=D*COS(PI/2-THETACD)
    ELSE
     CDXYZ(1)=D*SIN(PI/2-THETACD)*COS(PHICD)
     CDXYZ(2)=D*SIN(PI/2-THETACD)*SIN(PHICD)
     CDXYZ(3)=D*COS(PI/2-THETACD)
    END IF
  END IF

  RETURN
 END SUBROUTINE r4IGRF

 SUBROUTINE r8IGRF(IGRFYEAR,Bo,THETAN,PHIN,GEOXYZ,CDXYZ)
  IMPLICIT NONE
  REAL(8)             :: IGRFYEAR
  REAL(8)             :: Bo
  REAL(8), OPTIONAL   :: THETAN,PHIN
  REAL(8), OPTIONAL   :: GEOXYZ(3)
  REAL(8), OPTIONAL   :: CDXYZ(3)
  REAL(8), PARAMETER  :: PI=4.0d0*ATAN(1.0d0)

  REAL(8) :: GGUS(1:13,0:13),HGUS(1:13,1:13)
  REAL(8) :: Lo,L1,L2,E
  REAL(8) :: RE=6371.0
  REAL(8) :: D,THETA0,PHI0,THETACD,PHICD

  CALL GETIGRF(IGRFYEAR,GGUS,HGUS)

  Bo=SQRT(GGUS(1,0)**2+GGUS(1,1)**2+HGUS(1,1)**2)
  IF(PRESENT(THETAN)) THETAN=ACOS(-GGUS(1,0)/Bo)
  IF(PRESENT(PHIN))   PHIN=ATAN2(HGUS(1,1),GGUS(1,1))-PI

  IF(PRESENT(GEOXYZ)) THEN
    Lo=2*GGUS(1,0)*GGUS(2,0)+SQRT(3.0)*(GGUS(1,1)*GGUS(2,1)+HGUS(1,1)*HGUS(2,1))
    L1= -GGUS(1,1)*GGUS(2,0)+SQRT(3.0)*(GGUS(1,0)*GGUS(2,1)+GGUS(1,1)*GGUS(2,2)+HGUS(1,1)*HGUS(2,2))
    L2= -HGUS(1,1)*GGUS(2,0)+SQRT(3.0)*(GGUS(1,0)*HGUS(2,1)-HGUS(1,1)*GGUS(2,2)+GGUS(1,1)*HGUS(2,2))
    E =(Lo*GGUS(1,0)+L1*GGUS(1,1)+L2*HGUS(1,1))/(4.0*Bo**2)

    GEOXYZ(1)=(RE*(L1-GGUS(1,1)*E))/(3.0*Bo**2)
    GEOXYZ(2)=(RE*(L2-HGUS(1,1)*E))/(3.0*Bo**2)
    GEOXYZ(3)=(RE*(Lo-GGUS(1,0)*E))/(3.0*Bo**2)
  END IF

  IF(PRESENT(CDXYZ)) THEN
    D=SQRT(GEOXYZ(1)**2+GEOXYZ(2)**2+GEOXYZ(3)**2)
    THETA0=ACOS(GEOXYZ(3)/D)
    PHI0=ATAN2(GEOXYZ(2),GEOXYZ(1))
! CONVERT FROM CO-LATITUDE TO LATITUDE
    THETA0=PI/2.0-THETA0
! CONVERT FROM CO-LONGITUDE TO LONGITUDE
    IF(PHI0.GT.PI) PHI0=PHI0-2.0*PI

    CALL GEO2CD(THETA0,PHI0,THETACD,PHICD,IGRFYEAR)

    IF(PHICD.LT.0) THEN
     CDXYZ(1)=D*SIN(PI/2-THETACD)*COS(PHICD+2*PI)
     CDXYZ(2)=D*SIN(PI/2-THETACD)*SIN(PHICD+2*PI)
     CDXYZ(3)=D*COS(PI/2-THETACD)
    ELSE
     CDXYZ(1)=D*SIN(PI/2-THETACD)*COS(PHICD)
     CDXYZ(2)=D*SIN(PI/2-THETACD)*SIN(PHICD)
     CDXYZ(3)=D*COS(PI/2-THETACD)
    END IF
  END IF

  RETURN
 END SUBROUTINE r8IGRF


 SUBROUTINE r4GETIGRF(IGRFYEAR,GGUS,HGUS)
  IMPLICIT NONE
  REAL(4)                 :: GGUS(1:13,0:13)
  REAL(4)                 :: HGUS(1:13,1:13)
  REAL(4)                 :: IGRFYEAR
  INTEGER(4)              :: MATDIMS(2)
  INTEGER(4)              :: IND1,IND2
  INTEGER(4)              :: INDEX1,INDEX2,ID,RDFLAG=0
  INTEGER(4)              :: YID,IGRFCYEAR,IGRFPYEAR,IGRFNYEAR
  CHARACTER(200)          :: RANDOM=""


  MATDIMS=SHAPE(GGUS)
  IF((MATDIMS(1).LT.13).OR.(MATDIMS(2).LT.14)) THEN
   PRINT*, "INPUT MATRIX HAS TO BE 13X14"
   RETURN
  END IF
  MATDIMS=SHAPE(HGUS)
  IF((MATDIMS(1).LT.13).OR.(MATDIMS(2).LT.13)) THEN
   PRINT*, "INPUT MATRIX HAS TO BE 13X13"
   RETURN
  END IF
 
  DO ID=1,24
    IGRFCYEAR=1900.0+5.0*REAL(ID-1)
    IGRFNYEAR=1900.0+5.0*REAL(ID)
    IF((IGRFCYEAR.LE.IGRFYEAR).AND.(IGRFNYEAR.GT.IGRFYEAR)) THEN
     YID=ID
     EXIT
    END IF
  END DO

  OPEN(101,FILE='igrf12coeffs.txt',STATUS='OLD',FORM='FORMATTED',ACTION='READ',POSITION='REWIND')
  DO ID=1,4
   READ(101,'(A)',IOSTAT=RDFLAG), RANDOM
  END DO
  DO ID=1,195
   READ(101,'(A)',IOSTAT=RDFLAG), RANDOM
   IF(RDFLAG.LT.0) EXIT
   READ(RANDOM(2:4),*) INDEX1
   READ(RANDOM(5:7),*) INDEX2
   IF(YID.LE.20) THEN
    IND1=7*YID+1
    IND2=IND1+7
    IF(RANDOM(1:1).EQ."g") THEN
     READ(RANDOM(IND1:IND2),*) GGUS(INDEX1,INDEX2)
    ElSE IF(RANDOM(1:1).EQ."h") THEN
     READ(RANDOM(IND1:IND2),*) HGUS(INDEX1,INDEX2)
    END IF
   ELSE IF(YID.LE.21) THEN
    IND1=7*(21)+1
    IND2=IND1+8
    IF(RANDOM(1:1).EQ."g") THEN
     READ(RANDOM(IND1:IND2),*) GGUS(INDEX1,INDEX2)
    ElSE IF(RANDOM(1:1).EQ."h") THEN
     READ(RANDOM(IND1:IND2),*) HGUS(INDEX1,INDEX2)
    END IF
   ELSE IF(YID.LE.22) THEN
    IND1=7*(21)+10
    IND2=IND1+9
    IF(RANDOM(1:1).EQ."g") THEN
     READ(RANDOM(IND1:IND2),*) GGUS(INDEX1,INDEX2)
    ElSE IF(RANDOM(1:1).EQ."h") THEN
     READ(RANDOM(IND1:IND2),*) HGUS(INDEX1,INDEX2)
    END IF
   ELSE IF(YID.LE.23) THEN
    IND1=7*(21)+20
    IND2=IND1+9
    IF(RANDOM(1:1).EQ."g") THEN
     READ(RANDOM(IND1:IND2),*) GGUS(INDEX1,INDEX2)
    ElSE IF(RANDOM(1:1).EQ."h") THEN
     READ(RANDOM(IND1:IND2),*) HGUS(INDEX1,INDEX2)
    END IF
   ELSE IF(YID.LE.24) THEN
    IND1=7*(21)+30
    IND2=IND1+8
    IF(RANDOM(1:1).EQ."g") THEN
     READ(RANDOM(IND1:IND2),*) GGUS(INDEX1,INDEX2)
    ElSE IF(RANDOM(1:1).EQ."h") THEN
     READ(RANDOM(IND1:IND2),*) HGUS(INDEX1,INDEX2)
    END IF
   END IF
  END DO

  RETURN
 END SUBROUTINE r4GETIGRF

 SUBROUTINE r8GETIGRF(IGRFYEAR,GGUS,HGUS)
  IMPLICIT NONE
  REAL(8)                 :: GGUS(1:13,0:13)
  REAL(8)                 :: HGUS(1:13,1:13)
  REAL(8)                 :: IGRFYEAR
  INTEGER(8)              :: MATDIMS(2)
  INTEGER(8)              :: IND1,IND2
  INTEGER(8)              :: INDEX1,INDEX2,ID,RDFLAG=0
  INTEGER(8)              :: YID,IGRFCYEAR,IGRFPYEAR,IGRFNYEAR
  CHARACTER(200)          :: RANDOM=""


  MATDIMS=SHAPE(GGUS)
  IF((MATDIMS(1).LT.13).OR.(MATDIMS(2).LT.14)) THEN
   PRINT*, "INPUT MATRIX HAS TO BE 13X14"
   RETURN
  END IF
  MATDIMS=SHAPE(HGUS)
  IF((MATDIMS(1).LT.13).OR.(MATDIMS(2).LT.13)) THEN
   PRINT*, "INPUT MATRIX HAS TO BE 13X13"
   RETURN
  END IF
 
  DO ID=1,24
    IGRFCYEAR=1900.0+5.0*REAL(ID-1)
    IGRFNYEAR=1900.0+5.0*REAL(ID)
    IF((IGRFCYEAR.LE.IGRFYEAR).AND.(IGRFNYEAR.GT.IGRFYEAR)) THEN
     YID=ID
     EXIT
    END IF
  END DO

  OPEN(101,FILE='igrf12coeffs.txt',STATUS='OLD',FORM='FORMATTED',ACTION='READ',POSITION='REWIND')
  DO ID=1,4
   READ(101,'(A)',IOSTAT=RDFLAG), RANDOM
  END DO
  DO ID=1,195
   READ(101,'(A)',IOSTAT=RDFLAG), RANDOM
   IF(RDFLAG.LT.0) EXIT
   READ(RANDOM(2:4),*) INDEX1
   READ(RANDOM(5:7),*) INDEX2
   IF(YID.LE.20) THEN
    IND1=7*YID+1
    IND2=IND1+7
    IF(RANDOM(1:1).EQ."g") THEN
     READ(RANDOM(IND1:IND2),*) GGUS(INDEX1,INDEX2)
    ElSE IF(RANDOM(1:1).EQ."h") THEN
     READ(RANDOM(IND1:IND2),*) HGUS(INDEX1,INDEX2)
    END IF
   ELSE IF(YID.LE.21) THEN
    IND1=7*(21)+1
    IND2=IND1+8
    IF(RANDOM(1:1).EQ."g") THEN
     READ(RANDOM(IND1:IND2),*) GGUS(INDEX1,INDEX2)
    ElSE IF(RANDOM(1:1).EQ."h") THEN
     READ(RANDOM(IND1:IND2),*) HGUS(INDEX1,INDEX2)
    END IF
   ELSE IF(YID.LE.22) THEN
    IND1=7*(21)+10
    IND2=IND1+9
    IF(RANDOM(1:1).EQ."g") THEN
     READ(RANDOM(IND1:IND2),*) GGUS(INDEX1,INDEX2)
    ElSE IF(RANDOM(1:1).EQ."h") THEN
     READ(RANDOM(IND1:IND2),*) HGUS(INDEX1,INDEX2)
    END IF
   ELSE IF(YID.LE.23) THEN
    IND1=7*(21)+20
    IND2=IND1+9
    IF(RANDOM(1:1).EQ."g") THEN
     READ(RANDOM(IND1:IND2),*) GGUS(INDEX1,INDEX2)
    ElSE IF(RANDOM(1:1).EQ."h") THEN
     READ(RANDOM(IND1:IND2),*) HGUS(INDEX1,INDEX2)
    END IF
   ELSE IF(YID.LE.24) THEN
    IND1=7*(21)+30
    IND2=IND1+8
    IF(RANDOM(1:1).EQ."g") THEN
     READ(RANDOM(IND1:IND2),*) GGUS(INDEX1,INDEX2)
    ElSE IF(RANDOM(1:1).EQ."h") THEN
     READ(RANDOM(IND1:IND2),*) HGUS(INDEX1,INDEX2)
    END IF
   END IF
  END DO

  RETURN
 END SUBROUTINE r8GETIGRF


END MODULE GEOAXES
